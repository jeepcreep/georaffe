{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/global/window.js"],"sourcesContent":["var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n"],"names":[],"mappings":"AAAA,IAAI;AAEJ,IAAI,OAAO,WAAW,aAAa;IAC/B,MAAM;AACV,OAAO,IAAI,OAAO,WAAW,aAAa;IACtC,MAAM;AACV,OAAO,IAAI,OAAO,SAAS,aAAY;IACnC,MAAM;AACV,OAAO;IACH,MAAM,CAAC;AACX;AAEA,OAAO,OAAO,GAAG"}},
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/src/shared/lib/lazy-dynamic/loadable.tsx"],"sourcesContent":["unable to read source [project]/node_modules/next/src/shared/lib/lazy-dynamic/loadable.tsx"],"names":["convertModule","mod","hasDefault","default","defaultOptions","loader","Promise","resolve","loading","ssr","Loadable","options","opts","Lazy","lazy","then","Loading","LoadableComponent","props","fallbackElement","isLoading","pastDelay","error","children","window","PreloadCss","moduleIds","modules","BailoutToCSR","reason","Suspense","fallback","displayName"],"mappings":";;;;+BAwEA,WAAA;;;eAAA;;;;;;;AAnEA,yFAAyF;AACzF,qGAAqG;AACrG,qEAAqE;AACrE,SAASA,cACPC,GAA4D;IAI5D,iHAAiH;IACjH,SAAS;IACT,8BAA8B;IAC9B,iBAAiB;IACjB,+CAA+C;IAC/C,wBAAwB;IACxB,MAAMC,aAAaD,OAAO,aAAaA;IACvC,OAAO;QACLE,SAASD,aACL,IAA4BC,OAAO,GAClCF;IACP;AACF;AAEA,MAAMG,iBAAiB;IACrBC,QAAQ,IAAMC,QAAQC,OAAO,CAACP,cAAc,IAAM;IAClDQ,SAAS;IACTC,KAAK;AACP;AASA,SAASC,SAASC,OAAwB;IACxC,MAAMC,OAAO;QAAE,GAAGR,cAAc;QAAE,GAAGO,OAAO;IAAC;IAC7C,MAAME,OAAAA,WAAAA,GAAOC,CAAAA,GAAAA,OAAAA,IAAI,EAAC,IAAMF,KAAKP,MAAM,GAAGU,IAAI,CAACf;IAC3C,MAAMgB,UAAUJ,KAAKJ,OAAO;IAE5B,SAASS,kBAAkBC,KAAU;QACnC,MAAMC,kBAAkBH,UAAAA,WAAAA,GACtB,CAAA,GAAA,YAAA,GAAA,EAACA,SAAAA;YAAQI,WAAW;YAAMC,WAAW;YAAMC,OAAO;aAChD;QAEJ,MAAMC,WAAWX,KAAKH,GAAG,GAAA,WAAA,GACvB,CAAA,GAAA,YAAA,IAAA,EAAA,YAAA,QAAA,EAAA;;gBAEG,OAAOe,WAAW,cAAA,WAAA,GACjB,CAAA,GAAA,YAAA,GAAA,EAACC,YAAAA,UAAU,EAAA;oBAACC,WAAWd,KAAKe,OAAO;qBACjC;8BACJ,CAAA,GAAA,YAAA,GAAA,EAACd,MAAAA;oBAAM,GAAGK,KAAK;;;2BAGjB,CAAA,GAAA,YAAA,GAAA,EAACU,qBAAAA,YAAY,EAAA;YAACC,QAAO;sBACnB,WAAA,GAAA,CAAA,GAAA,YAAA,GAAA,EAAChB,MAAAA;gBAAM,GAAGK,KAAK;;;QAInB,OAAA,WAAA,GAAO,CAAA,GAAA,YAAA,GAAA,EAACY,OAAAA,QAAQ,EAAA;YAACC,UAAUZ;sBAAkBI;;IAC/C;IAEAN,kBAAkBe,WAAW,GAAG;IAEhC,OAAOf;AACT;MAEA,WAAeP"}},
    {"offset": {"line": 90, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/next/src/shared/lib/app-dynamic.tsx"],"sourcesContent":["unable to read source [project]/node_modules/next/src/shared/lib/app-dynamic.tsx"],"names":["dynamic","dynamicOptions","options","mergedOptions","loadableOptions","loading","error","isLoading","pastDelay","p","message","br","stack","loader","Loadable","modules","loadableGenerated"],"mappings":";;;;+BAiCA,WAAA;;;eAAwBA;;;;;;;AAAT,SAASA,QACtBC,cAA6C,EAC7CC,OAA2B;QAmChBC;IAjCX,IAAIC,kBAAsC;QACxC,wDAAwD;QACxDC,SAAS,CAAA;gBAAC,EAAEC,KAAK,EAAEC,SAAS,EAAEC,SAAS,EAAE,GAAA;YACvC,IAAI,CAACA,WAAW,OAAO;YACvB,wCAA2C;gBACzC,IAAID,WAAW;oBACb,OAAO;gBACT;gBACA,IAAID,OAAO;oBACT,OAAA,WAAA,GACE,CAAA,GAAA,YAAA,IAAA,EAACG,KAAAA;;4BACEH,MAAMI,OAAO;0CACd,CAAA,GAAA,YAAA,GAAA,EAACC,MAAAA,CAAAA;4BACAL,MAAMM,KAAK;;;gBAGlB;YACF;YACA,OAAO;QACT;IACF;IAEA,IAAI,OAAOX,mBAAmB,YAAY;QACxCG,gBAAgBS,MAAM,GAAGZ;IAC3B;IAEA,MAAME,gBAAgB;QACpB,GAAGC,eAAe;QAClB,GAAGF,OAAO;IACZ;IAEA,OAAOY,CAAAA,GAAAA,UAAAA,OAAQ,EAAC;QACd,GAAGX,aAAa;QAChBY,SAAO,CAAEZ,mCAAAA,cAAca,iBAAiB,KAAA,OAAA,KAAA,IAA/Bb,iCAAiCY,OAAO;IACnD;AACF"}},
    {"offset": {"line": 151, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@react-leaflet/core/lib/context.js"],"sourcesContent":["import { createContext, useContext } from 'react';\nexport const CONTEXT_VERSION = 1;\nexport function createLeafletContext(map) {\n    return Object.freeze({\n        __version: CONTEXT_VERSION,\n        map\n    });\n}\nexport function extendContext(source, extra) {\n    return Object.freeze({\n        ...source,\n        ...extra\n    });\n}\nexport const LeafletContext = createContext(null);\nexport const LeafletProvider = LeafletContext.Provider;\nexport function useLeafletContext() {\n    const context = useContext(LeafletContext);\n    if (context == null) {\n        throw new Error('No context provided: useLeafletContext() can only be used in a descendant of <MapContainer>');\n    }\n    return context;\n}\n"],"names":[],"mappings":";;;;;;;;;;;AACO,MAAM,kBAAkB;AACxB,SAAS,qBAAqB,GAAG;IACpC,OAAO,OAAO,MAAM,CAAC;QACjB,WAAW;QACX;IACJ;AACJ;AACO,SAAS,cAAc,MAAM,EAAE,KAAK;IACvC,OAAO,OAAO,MAAM,CAAC;QACjB,GAAG,MAAM;QACT,GAAG,KAAK;IACZ;AACJ;AACO,MAAM,iBAAiB,CAAA,GAAA,+MAAA,CAAA,gBAAa,AAAD,EAAE;AACrC,MAAM,kBAAkB,eAAe,QAAQ;AAC/C,SAAS;IACZ,MAAM,UAAU,CAAA,GAAA,+MAAA,CAAA,aAAU,AAAD,EAAE;IAC3B,IAAI,WAAW,MAAM;QACjB,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;AACX"}},
    {"offset": {"line": 189, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 194, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@react-leaflet/core/lib/element.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nexport function createElementObject(instance, context, container) {\n    return Object.freeze({\n        instance,\n        context,\n        container\n    });\n}\nexport function createElementHook(createElement, updateElement) {\n    if (updateElement == null) {\n        return function useImmutableLeafletElement(props, context) {\n            const elementRef = useRef();\n            if (!elementRef.current) elementRef.current = createElement(props, context);\n            return elementRef;\n        };\n    }\n    return function useMutableLeafletElement(props, context) {\n        const elementRef = useRef();\n        if (!elementRef.current) elementRef.current = createElement(props, context);\n        const propsRef = useRef(props);\n        const { instance  } = elementRef.current;\n        useEffect(function updateElementProps() {\n            if (propsRef.current !== props) {\n                updateElement(instance, props, propsRef.current);\n                propsRef.current = props;\n            }\n        }, [\n            instance,\n            props,\n            context\n        ]);\n        return elementRef;\n    };\n}\n"],"names":[],"mappings":";;;;;;;AACO,SAAS,oBAAoB,QAAQ,EAAE,OAAO,EAAE,SAAS;IAC5D,OAAO,OAAO,MAAM,CAAC;QACjB;QACA;QACA;IACJ;AACJ;AACO,SAAS,kBAAkB,aAAa,EAAE,aAAa;IAC1D,IAAI,iBAAiB,MAAM;QACvB,OAAO,SAAS,2BAA2B,KAAK,EAAE,OAAO;YACrD,MAAM,aAAa,CAAA,GAAA,+MAAA,CAAA,SAAM,AAAD;YACxB,IAAI,CAAC,WAAW,OAAO,EAAE,WAAW,OAAO,GAAG,cAAc,OAAO;YACnE,OAAO;QACX;IACJ;IACA,OAAO,SAAS,yBAAyB,KAAK,EAAE,OAAO;QACnD,MAAM,aAAa,CAAA,GAAA,+MAAA,CAAA,SAAM,AAAD;QACxB,IAAI,CAAC,WAAW,OAAO,EAAE,WAAW,OAAO,GAAG,cAAc,OAAO;QACnE,MAAM,WAAW,CAAA,GAAA,+MAAA,CAAA,SAAM,AAAD,EAAE;QACxB,MAAM,EAAE,QAAQ,EAAG,GAAG,WAAW,OAAO;QACxC,CAAA,GAAA,+MAAA,CAAA,YAAS,AAAD,EAAE,SAAS;YACf,IAAI,SAAS,OAAO,KAAK,OAAO;gBAC5B,cAAc,UAAU,OAAO,SAAS,OAAO;gBAC/C,SAAS,OAAO,GAAG;YACvB;QACJ,GAAG;YACC;YACA;YACA;SACH;QACD,OAAO;IACX;AACJ"}},
    {"offset": {"line": 234, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 239, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@react-leaflet/core/lib/component.js"],"sourcesContent":["import React, { forwardRef, useEffect, useImperativeHandle, useState } from 'react';\nimport { createPortal } from 'react-dom';\nimport { LeafletProvider } from './context.js';\nexport function createContainerComponent(useElement) {\n    function ContainerComponent(props, forwardedRef) {\n        const { instance , context  } = useElement(props).current;\n        useImperativeHandle(forwardedRef, ()=>instance);\n        return props.children == null ? null : /*#__PURE__*/ React.createElement(LeafletProvider, {\n            value: context\n        }, props.children);\n    }\n    return /*#__PURE__*/ forwardRef(ContainerComponent);\n}\nexport function createDivOverlayComponent(useElement) {\n    function OverlayComponent(props, forwardedRef) {\n        const [isOpen, setOpen] = useState(false);\n        const { instance  } = useElement(props, setOpen).current;\n        useImperativeHandle(forwardedRef, ()=>instance);\n        useEffect(function updateOverlay() {\n            if (isOpen) {\n                instance.update();\n            }\n        }, [\n            instance,\n            isOpen,\n            props.children\n        ]);\n        // @ts-ignore _contentNode missing in type definition\n        const contentNode = instance._contentNode;\n        return contentNode ? /*#__PURE__*/ createPortal(props.children, contentNode) : null;\n    }\n    return /*#__PURE__*/ forwardRef(OverlayComponent);\n}\nexport function createLeafComponent(useElement) {\n    function LeafComponent(props, forwardedRef) {\n        const { instance  } = useElement(props).current;\n        useImperativeHandle(forwardedRef, ()=>instance);\n        return null;\n    }\n    return /*#__PURE__*/ forwardRef(LeafComponent);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAGO,SAAS,yBAAyB,UAAU;IAC/C,SAAS,mBAAmB,KAAK,EAAE,YAAY;QAC3C,MAAM,EAAE,QAAQ,EAAG,OAAO,EAAG,GAAG,WAAW,OAAO,OAAO;QACzD,CAAA,GAAA,+MAAA,CAAA,sBAAmB,AAAD,EAAE,cAAc,IAAI;QACtC,OAAO,MAAM,QAAQ,IAAI,OAAO,OAAO,WAAW,GAAG,+MAAA,CAAA,UAAK,CAAC,aAAa,CAAC,4JAAA,CAAA,kBAAe,EAAE;YACtF,OAAO;QACX,GAAG,MAAM,QAAQ;IACrB;IACA,OAAO,WAAW,GAAG,CAAA,GAAA,+MAAA,CAAA,aAAU,AAAD,EAAE;AACpC;AACO,SAAS,0BAA0B,UAAU;IAChD,SAAS,iBAAiB,KAAK,EAAE,YAAY;QACzC,MAAM,CAAC,QAAQ,QAAQ,GAAG,CAAA,GAAA,+MAAA,CAAA,WAAQ,AAAD,EAAE;QACnC,MAAM,EAAE,QAAQ,EAAG,GAAG,WAAW,OAAO,SAAS,OAAO;QACxD,CAAA,GAAA,+MAAA,CAAA,sBAAmB,AAAD,EAAE,cAAc,IAAI;QACtC,CAAA,GAAA,+MAAA,CAAA,YAAS,AAAD,EAAE,SAAS;YACf,IAAI,QAAQ;gBACR,SAAS,MAAM;YACnB;QACJ,GAAG;YACC;YACA;YACA,MAAM,QAAQ;SACjB;QACD,qDAAqD;QACrD,MAAM,cAAc,SAAS,YAAY;QACzC,OAAO,cAAc,WAAW,GAAG,CAAA,GAAA,sNAAA,CAAA,eAAY,AAAD,EAAE,MAAM,QAAQ,EAAE,eAAe;IACnF;IACA,OAAO,WAAW,GAAG,CAAA,GAAA,+MAAA,CAAA,aAAU,AAAD,EAAE;AACpC;AACO,SAAS,oBAAoB,UAAU;IAC1C,SAAS,cAAc,KAAK,EAAE,YAAY;QACtC,MAAM,EAAE,QAAQ,EAAG,GAAG,WAAW,OAAO,OAAO;QAC/C,CAAA,GAAA,+MAAA,CAAA,sBAAmB,AAAD,EAAE,cAAc,IAAI;QACtC,OAAO;IACX;IACA,OAAO,WAAW,GAAG,CAAA,GAAA,+MAAA,CAAA,aAAU,AAAD,EAAE;AACpC"}},
    {"offset": {"line": 289, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 294, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@react-leaflet/core/lib/control.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport { useLeafletContext } from './context.js';\nexport function createControlHook(useElement) {\n    return function useLeafletControl(props) {\n        const context = useLeafletContext();\n        const elementRef = useElement(props, context);\n        const { instance  } = elementRef.current;\n        const positionRef = useRef(props.position);\n        const { position  } = props;\n        useEffect(function addControl() {\n            instance.addTo(context.map);\n            return function removeControl() {\n                instance.remove();\n            };\n        }, [\n            context.map,\n            instance\n        ]);\n        useEffect(function updateControl() {\n            if (position != null && position !== positionRef.current) {\n                instance.setPosition(position);\n                positionRef.current = position;\n            }\n        }, [\n            instance,\n            position\n        ]);\n        return elementRef;\n    };\n}\n"],"names":[],"mappings":";;;;;;;;AAEO,SAAS,kBAAkB,UAAU;IACxC,OAAO,SAAS,kBAAkB,KAAK;QACnC,MAAM,UAAU,CAAA,GAAA,4JAAA,CAAA,oBAAiB,AAAD;QAChC,MAAM,aAAa,WAAW,OAAO;QACrC,MAAM,EAAE,QAAQ,EAAG,GAAG,WAAW,OAAO;QACxC,MAAM,cAAc,CAAA,GAAA,+MAAA,CAAA,SAAM,AAAD,EAAE,MAAM,QAAQ;QACzC,MAAM,EAAE,QAAQ,EAAG,GAAG;QACtB,CAAA,GAAA,+MAAA,CAAA,YAAS,AAAD,EAAE,SAAS;YACf,SAAS,KAAK,CAAC,QAAQ,GAAG;YAC1B,OAAO,SAAS;gBACZ,SAAS,MAAM;YACnB;QACJ,GAAG;YACC,QAAQ,GAAG;YACX;SACH;QACD,CAAA,GAAA,+MAAA,CAAA,YAAS,AAAD,EAAE,SAAS;YACf,IAAI,YAAY,QAAQ,aAAa,YAAY,OAAO,EAAE;gBACtD,SAAS,WAAW,CAAC;gBACrB,YAAY,OAAO,GAAG;YAC1B;QACJ,GAAG;YACC;YACA;SACH;QACD,OAAO;IACX;AACJ"}},
    {"offset": {"line": 330, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 335, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@react-leaflet/core/lib/attribution.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nexport function useAttribution(map, attribution) {\n    const attributionRef = useRef(attribution);\n    useEffect(function updateAttribution() {\n        if (attribution !== attributionRef.current && map.attributionControl != null) {\n            if (attributionRef.current != null) {\n                map.attributionControl.removeAttribution(attributionRef.current);\n            }\n            if (attribution != null) {\n                map.attributionControl.addAttribution(attribution);\n            }\n        }\n        attributionRef.current = attribution;\n    }, [\n        map,\n        attribution\n    ]);\n}\n"],"names":[],"mappings":";;;;;;AACO,SAAS,eAAe,GAAG,EAAE,WAAW;IAC3C,MAAM,iBAAiB,CAAA,GAAA,+MAAA,CAAA,SAAM,AAAD,EAAE;IAC9B,CAAA,GAAA,+MAAA,CAAA,YAAS,AAAD,EAAE,SAAS;QACf,IAAI,gBAAgB,eAAe,OAAO,IAAI,IAAI,kBAAkB,IAAI,MAAM;YAC1E,IAAI,eAAe,OAAO,IAAI,MAAM;gBAChC,IAAI,kBAAkB,CAAC,iBAAiB,CAAC,eAAe,OAAO;YACnE;YACA,IAAI,eAAe,MAAM;gBACrB,IAAI,kBAAkB,CAAC,cAAc,CAAC;YAC1C;QACJ;QACA,eAAe,OAAO,GAAG;IAC7B,GAAG;QACC;QACA;KACH;AACL"}},
    {"offset": {"line": 358, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@react-leaflet/core/lib/events.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nexport function useEventHandlers(element, eventHandlers) {\n    const eventHandlersRef = useRef();\n    useEffect(function addEventHandlers() {\n        if (eventHandlers != null) {\n            element.instance.on(eventHandlers);\n        }\n        eventHandlersRef.current = eventHandlers;\n        return function removeEventHandlers() {\n            if (eventHandlersRef.current != null) {\n                element.instance.off(eventHandlersRef.current);\n            }\n            eventHandlersRef.current = null;\n        };\n    }, [\n        element,\n        eventHandlers\n    ]);\n}\n"],"names":[],"mappings":";;;;;;AACO,SAAS,iBAAiB,OAAO,EAAE,aAAa;IACnD,MAAM,mBAAmB,CAAA,GAAA,+MAAA,CAAA,SAAM,AAAD;IAC9B,CAAA,GAAA,+MAAA,CAAA,YAAS,AAAD,EAAE,SAAS;QACf,IAAI,iBAAiB,MAAM;YACvB,QAAQ,QAAQ,CAAC,EAAE,CAAC;QACxB;QACA,iBAAiB,OAAO,GAAG;QAC3B,OAAO,SAAS;YACZ,IAAI,iBAAiB,OAAO,IAAI,MAAM;gBAClC,QAAQ,QAAQ,CAAC,GAAG,CAAC,iBAAiB,OAAO;YACjD;YACA,iBAAiB,OAAO,GAAG;QAC/B;IACJ,GAAG;QACC;QACA;KACH;AACL"}},
    {"offset": {"line": 387, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 392, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@react-leaflet/core/lib/pane.js"],"sourcesContent":["export function withPane(props, context) {\n    const pane = props.pane ?? context.pane;\n    return pane ? {\n        ...props,\n        pane\n    } : props;\n}\n"],"names":[],"mappings":";;;AAAO,SAAS,SAAS,KAAK,EAAE,OAAO;IACnC,MAAM,OAAO,MAAM,IAAI,IAAI,QAAQ,IAAI;IACvC,OAAO,OAAO;QACV,GAAG,KAAK;QACR;IACJ,IAAI;AACR"}},
    {"offset": {"line": 402, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 407, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@react-leaflet/core/lib/layer.js"],"sourcesContent":["import { useEffect } from 'react';\nimport { useAttribution } from './attribution.js';\nimport { useLeafletContext } from './context.js';\nimport { useEventHandlers } from './events.js';\nimport { withPane } from './pane.js';\nexport function useLayerLifecycle(element, context) {\n    useEffect(function addLayer() {\n        const container = context.layerContainer ?? context.map;\n        container.addLayer(element.instance);\n        return function removeLayer() {\n            context.layerContainer?.removeLayer(element.instance);\n            context.map.removeLayer(element.instance);\n        };\n    }, [\n        context,\n        element\n    ]);\n}\nexport function createLayerHook(useElement) {\n    return function useLayer(props) {\n        const context = useLeafletContext();\n        const elementRef = useElement(withPane(props, context), context);\n        useAttribution(context.map, props.attribution);\n        useEventHandlers(elementRef.current, props.eventHandlers);\n        useLayerLifecycle(elementRef.current, context);\n        return elementRef;\n    };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAKO,SAAS,kBAAkB,OAAO,EAAE,OAAO;IAC9C,CAAA,GAAA,+MAAA,CAAA,YAAS,AAAD,EAAE,SAAS;QACf,MAAM,YAAY,QAAQ,cAAc,IAAI,QAAQ,GAAG;QACvD,UAAU,QAAQ,CAAC,QAAQ,QAAQ;QACnC,OAAO,SAAS;YACZ,QAAQ,cAAc,EAAE,YAAY,QAAQ,QAAQ;YACpD,QAAQ,GAAG,CAAC,WAAW,CAAC,QAAQ,QAAQ;QAC5C;IACJ,GAAG;QACC;QACA;KACH;AACL;AACO,SAAS,gBAAgB,UAAU;IACtC,OAAO,SAAS,SAAS,KAAK;QAC1B,MAAM,UAAU,CAAA,GAAA,4JAAA,CAAA,oBAAiB,AAAD;QAChC,MAAM,aAAa,WAAW,CAAA,GAAA,yJAAA,CAAA,WAAQ,AAAD,EAAE,OAAO,UAAU;QACxD,CAAA,GAAA,gKAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ,GAAG,EAAE,MAAM,WAAW;QAC7C,CAAA,GAAA,2JAAA,CAAA,mBAAgB,AAAD,EAAE,WAAW,OAAO,EAAE,MAAM,aAAa;QACxD,kBAAkB,WAAW,OAAO,EAAE;QACtC,OAAO;IACX;AACJ"}},
    {"offset": {"line": 445, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 450, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@react-leaflet/core/lib/div-overlay.js"],"sourcesContent":["import { useAttribution } from './attribution.js';\nimport { useLeafletContext } from './context.js';\nimport { useEventHandlers } from './events.js';\nimport { withPane } from './pane.js';\nexport function createDivOverlayHook(useElement, useLifecycle) {\n    return function useDivOverlay(props, setOpen) {\n        const context = useLeafletContext();\n        const elementRef = useElement(withPane(props, context), context);\n        useAttribution(context.map, props.attribution);\n        useEventHandlers(elementRef.current, props.eventHandlers);\n        useLifecycle(elementRef.current, context, props, setOpen);\n        return elementRef;\n    };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAIO,SAAS,qBAAqB,UAAU,EAAE,YAAY;IACzD,OAAO,SAAS,cAAc,KAAK,EAAE,OAAO;QACxC,MAAM,UAAU,CAAA,GAAA,4JAAA,CAAA,oBAAiB,AAAD;QAChC,MAAM,aAAa,WAAW,CAAA,GAAA,yJAAA,CAAA,WAAQ,AAAD,EAAE,OAAO,UAAU;QACxD,CAAA,GAAA,gKAAA,CAAA,iBAAc,AAAD,EAAE,QAAQ,GAAG,EAAE,MAAM,WAAW;QAC7C,CAAA,GAAA,2JAAA,CAAA,mBAAgB,AAAD,EAAE,WAAW,OAAO,EAAE,MAAM,aAAa;QACxD,aAAa,WAAW,OAAO,EAAE,SAAS,OAAO;QACjD,OAAO;IACX;AACJ"}},
    {"offset": {"line": 472, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 477, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@react-leaflet/core/lib/path.js"],"sourcesContent":["import { useEffect, useRef } from 'react';\nimport { useLeafletContext } from './context.js';\nimport { useEventHandlers } from './events.js';\nimport { useLayerLifecycle } from './layer.js';\nimport { withPane } from './pane.js';\nexport function usePathOptions(element, props) {\n    const optionsRef = useRef();\n    useEffect(function updatePathOptions() {\n        if (props.pathOptions !== optionsRef.current) {\n            const options = props.pathOptions ?? {};\n            element.instance.setStyle(options);\n            optionsRef.current = options;\n        }\n    }, [\n        element,\n        props\n    ]);\n}\nexport function createPathHook(useElement) {\n    return function usePath(props) {\n        const context = useLeafletContext();\n        const elementRef = useElement(withPane(props, context), context);\n        useEventHandlers(elementRef.current, props.eventHandlers);\n        useLayerLifecycle(elementRef.current, context);\n        usePathOptions(elementRef.current, props);\n        return elementRef;\n    };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;AAKO,SAAS,eAAe,OAAO,EAAE,KAAK;IACzC,MAAM,aAAa,CAAA,GAAA,+MAAA,CAAA,SAAM,AAAD;IACxB,CAAA,GAAA,+MAAA,CAAA,YAAS,AAAD,EAAE,SAAS;QACf,IAAI,MAAM,WAAW,KAAK,WAAW,OAAO,EAAE;YAC1C,MAAM,UAAU,MAAM,WAAW,IAAI,CAAC;YACtC,QAAQ,QAAQ,CAAC,QAAQ,CAAC;YAC1B,WAAW,OAAO,GAAG;QACzB;IACJ,GAAG;QACC;QACA;KACH;AACL;AACO,SAAS,eAAe,UAAU;IACrC,OAAO,SAAS,QAAQ,KAAK;QACzB,MAAM,UAAU,CAAA,GAAA,4JAAA,CAAA,oBAAiB,AAAD;QAChC,MAAM,aAAa,WAAW,CAAA,GAAA,yJAAA,CAAA,WAAQ,AAAD,EAAE,OAAO,UAAU;QACxD,CAAA,GAAA,2JAAA,CAAA,mBAAgB,AAAD,EAAE,WAAW,OAAO,EAAE,MAAM,aAAa;QACxD,CAAA,GAAA,0JAAA,CAAA,oBAAiB,AAAD,EAAE,WAAW,OAAO,EAAE;QACtC,eAAe,WAAW,OAAO,EAAE;QACnC,OAAO;IACX;AACJ"}},
    {"offset": {"line": 515, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 520, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@react-leaflet/core/lib/generic.js"],"sourcesContent":["import { createContainerComponent, createDivOverlayComponent, createLeafComponent } from './component.js';\nimport { createControlHook } from './control.js';\nimport { createElementHook, createElementObject } from './element.js';\nimport { createLayerHook } from './layer.js';\nimport { createDivOverlayHook } from './div-overlay.js';\nimport { createPathHook } from './path.js';\nexport function createControlComponent(createInstance) {\n    function createElement(props, context) {\n        return createElementObject(createInstance(props), context);\n    }\n    const useElement = createElementHook(createElement);\n    const useControl = createControlHook(useElement);\n    return createLeafComponent(useControl);\n}\nexport function createLayerComponent(createElement, updateElement) {\n    const useElement = createElementHook(createElement, updateElement);\n    const useLayer = createLayerHook(useElement);\n    return createContainerComponent(useLayer);\n}\nexport function createOverlayComponent(createElement, useLifecycle) {\n    const useElement = createElementHook(createElement);\n    const useOverlay = createDivOverlayHook(useElement, useLifecycle);\n    return createDivOverlayComponent(useOverlay);\n}\nexport function createPathComponent(createElement, updateElement) {\n    const useElement = createElementHook(createElement, updateElement);\n    const usePath = createPathHook(useElement);\n    return createContainerComponent(usePath);\n}\nexport function createTileLayerComponent(createElement, updateElement) {\n    const useElement = createElementHook(createElement, updateElement);\n    const useLayer = createLayerHook(useElement);\n    return createLeafComponent(useLayer);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAMO,SAAS,uBAAuB,cAAc;IACjD,SAAS,cAAc,KAAK,EAAE,OAAO;QACjC,OAAO,CAAA,GAAA,4JAAA,CAAA,sBAAmB,AAAD,EAAE,eAAe,QAAQ;IACtD;IACA,MAAM,aAAa,CAAA,GAAA,4JAAA,CAAA,oBAAiB,AAAD,EAAE;IACrC,MAAM,aAAa,CAAA,GAAA,4JAAA,CAAA,oBAAiB,AAAD,EAAE;IACrC,OAAO,CAAA,GAAA,8JAAA,CAAA,sBAAmB,AAAD,EAAE;AAC/B;AACO,SAAS,qBAAqB,aAAa,EAAE,aAAa;IAC7D,MAAM,aAAa,CAAA,GAAA,4JAAA,CAAA,oBAAiB,AAAD,EAAE,eAAe;IACpD,MAAM,WAAW,CAAA,GAAA,0JAAA,CAAA,kBAAe,AAAD,EAAE;IACjC,OAAO,CAAA,GAAA,8JAAA,CAAA,2BAAwB,AAAD,EAAE;AACpC;AACO,SAAS,uBAAuB,aAAa,EAAE,YAAY;IAC9D,MAAM,aAAa,CAAA,GAAA,4JAAA,CAAA,oBAAiB,AAAD,EAAE;IACrC,MAAM,aAAa,CAAA,GAAA,mKAAA,CAAA,uBAAoB,AAAD,EAAE,YAAY;IACpD,OAAO,CAAA,GAAA,8JAAA,CAAA,4BAAyB,AAAD,EAAE;AACrC;AACO,SAAS,oBAAoB,aAAa,EAAE,aAAa;IAC5D,MAAM,aAAa,CAAA,GAAA,4JAAA,CAAA,oBAAiB,AAAD,EAAE,eAAe;IACpD,MAAM,UAAU,CAAA,GAAA,yJAAA,CAAA,iBAAc,AAAD,EAAE;IAC/B,OAAO,CAAA,GAAA,8JAAA,CAAA,2BAAwB,AAAD,EAAE;AACpC;AACO,SAAS,yBAAyB,aAAa,EAAE,aAAa;IACjE,MAAM,aAAa,CAAA,GAAA,4JAAA,CAAA,oBAAiB,AAAD,EAAE,eAAe;IACpD,MAAM,WAAW,CAAA,GAAA,0JAAA,CAAA,kBAAe,AAAD,EAAE;IACjC,OAAO,CAAA,GAAA,8JAAA,CAAA,sBAAmB,AAAD,EAAE;AAC/B"}},
    {"offset": {"line": 568, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 573, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@react-leaflet/core/lib/grid-layer.js"],"sourcesContent":["export function updateGridLayer(layer, props, prevProps) {\n    const { opacity , zIndex  } = props;\n    if (opacity != null && opacity !== prevProps.opacity) {\n        layer.setOpacity(opacity);\n    }\n    if (zIndex != null && zIndex !== prevProps.zIndex) {\n        layer.setZIndex(zIndex);\n    }\n}\n"],"names":[],"mappings":";;;AAAO,SAAS,gBAAgB,KAAK,EAAE,KAAK,EAAE,SAAS;IACnD,MAAM,EAAE,OAAO,EAAG,MAAM,EAAG,GAAG;IAC9B,IAAI,WAAW,QAAQ,YAAY,UAAU,OAAO,EAAE;QAClD,MAAM,UAAU,CAAC;IACrB;IACA,IAAI,UAAU,QAAQ,WAAW,UAAU,MAAM,EAAE;QAC/C,MAAM,SAAS,CAAC;IACpB;AACJ"}},
    {"offset": {"line": 585, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 590, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@react-leaflet/core/lib/media-overlay.js"],"sourcesContent":["import { LatLngBounds } from 'leaflet';\nexport function updateMediaOverlay(overlay, props, prevProps) {\n    if (props.bounds instanceof LatLngBounds && props.bounds !== prevProps.bounds) {\n        overlay.setBounds(props.bounds);\n    }\n    if (props.opacity != null && props.opacity !== prevProps.opacity) {\n        overlay.setOpacity(props.opacity);\n    }\n    if (props.zIndex != null && props.zIndex !== prevProps.zIndex) {\n        // @ts-ignore missing in definition but inherited from ImageOverlay\n        overlay.setZIndex(props.zIndex);\n    }\n}\n"],"names":[],"mappings":";;;;;;AACO,SAAS,mBAAmB,OAAO,EAAE,KAAK,EAAE,SAAS;IACxD,IAAI,MAAM,MAAM,YAAY,iJAAA,CAAA,eAAY,IAAI,MAAM,MAAM,KAAK,UAAU,MAAM,EAAE;QAC3E,QAAQ,SAAS,CAAC,MAAM,MAAM;IAClC;IACA,IAAI,MAAM,OAAO,IAAI,QAAQ,MAAM,OAAO,KAAK,UAAU,OAAO,EAAE;QAC9D,QAAQ,UAAU,CAAC,MAAM,OAAO;IACpC;IACA,IAAI,MAAM,MAAM,IAAI,QAAQ,MAAM,MAAM,KAAK,UAAU,MAAM,EAAE;QAC3D,mEAAmE;QACnE,QAAQ,SAAS,CAAC,MAAM,MAAM;IAClC;AACJ"}},
    {"offset": {"line": 608, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 613, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/react-leaflet/lib/MapContainer.js"],"sourcesContent":["function _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nimport { LeafletProvider, createLeafletContext } from '@react-leaflet/core';\nimport { Map as LeafletMap } from 'leaflet';\nimport React, { forwardRef, useCallback, useEffect, useImperativeHandle, useState } from 'react';\nfunction MapContainerComponent({ bounds , boundsOptions , center , children , className , id , placeholder , style , whenReady , zoom , ...options }, forwardedRef) {\n    const [props] = useState({\n        className,\n        id,\n        style\n    });\n    const [context, setContext] = useState(null);\n    useImperativeHandle(forwardedRef, ()=>context?.map ?? null, [\n        context\n    ]);\n    const mapRef = useCallback((node)=>{\n        if (node !== null && context === null) {\n            const map = new LeafletMap(node, options);\n            if (center != null && zoom != null) {\n                map.setView(center, zoom);\n            } else if (bounds != null) {\n                map.fitBounds(bounds, boundsOptions);\n            }\n            if (whenReady != null) {\n                map.whenReady(whenReady);\n            }\n            setContext(createLeafletContext(map));\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    useEffect(()=>{\n        return ()=>{\n            context?.map.remove();\n        };\n    }, [\n        context\n    ]);\n    const contents = context ? /*#__PURE__*/ React.createElement(LeafletProvider, {\n        value: context\n    }, children) : placeholder ?? null;\n    return /*#__PURE__*/ React.createElement(\"div\", _extends({}, props, {\n        ref: mapRef\n    }), contents);\n}\nexport const MapContainer = /*#__PURE__*/ forwardRef(MapContainerComponent);\n"],"names":[],"mappings":";;;;;;;AAAA,SAAS;IACL,WAAW,OAAO,MAAM,IAAI,SAAS,MAAM;QACvC,IAAI,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAI;YACrC,IAAI,SAAS,SAAS,CAAC,EAAE;YACzB,IAAI,IAAI,OAAO,OAAO;gBAClB,IAAI,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,QAAQ,MAAM;oBACnD,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI;gBAC7B;YACJ;QACJ;QACA,OAAO;IACX;IACA,OAAO,SAAS,KAAK,CAAC,IAAI,EAAE;AAChC;;;;AAIA,SAAS,sBAAsB,EAAE,MAAM,EAAG,aAAa,EAAG,MAAM,EAAG,QAAQ,EAAG,SAAS,EAAG,EAAE,EAAG,WAAW,EAAG,KAAK,EAAG,SAAS,EAAG,IAAI,EAAG,GAAG,SAAS,EAAE,YAAY;IAC9J,MAAM,CAAC,MAAM,GAAG,CAAA,GAAA,+MAAA,CAAA,WAAQ,AAAD,EAAE;QACrB;QACA;QACA;IACJ;IACA,MAAM,CAAC,SAAS,WAAW,GAAG,CAAA,GAAA,+MAAA,CAAA,WAAQ,AAAD,EAAE;IACvC,CAAA,GAAA,+MAAA,CAAA,sBAAmB,AAAD,EAAE,cAAc,IAAI,SAAS,OAAO,MAAM;QACxD;KACH;IACD,MAAM,SAAS,CAAA,GAAA,+MAAA,CAAA,cAAW,AAAD,EAAE,CAAC;QACxB,IAAI,SAAS,QAAQ,YAAY,MAAM;YACnC,MAAM,MAAM,IAAI,iJAAA,CAAA,MAAU,CAAC,MAAM;YACjC,IAAI,UAAU,QAAQ,QAAQ,MAAM;gBAChC,IAAI,OAAO,CAAC,QAAQ;YACxB,OAAO,IAAI,UAAU,MAAM;gBACvB,IAAI,SAAS,CAAC,QAAQ;YAC1B;YACA,IAAI,aAAa,MAAM;gBACnB,IAAI,SAAS,CAAC;YAClB;YACA,WAAW,CAAA,GAAA,4JAAA,CAAA,uBAAoB,AAAD,EAAE;QACpC;IACJ,uDAAuD;IACvD,GAAG,EAAE;IACL,CAAA,GAAA,+MAAA,CAAA,YAAS,AAAD,EAAE;QACN,OAAO;YACH,SAAS,IAAI;QACjB;IACJ,GAAG;QACC;KACH;IACD,MAAM,WAAW,UAAU,WAAW,GAAG,+MAAA,CAAA,UAAK,CAAC,aAAa,CAAC,4JAAA,CAAA,kBAAe,EAAE;QAC1E,OAAO;IACX,GAAG,YAAY,eAAe;IAC9B,OAAO,WAAW,GAAG,+MAAA,CAAA,UAAK,CAAC,aAAa,CAAC,OAAO,SAAS,CAAC,GAAG,OAAO;QAChE,KAAK;IACT,IAAI;AACR;AACO,MAAM,eAAe,WAAW,GAAG,CAAA,GAAA,+MAAA,CAAA,aAAU,AAAD,EAAE"}},
    {"offset": {"line": 677, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 682, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/react-leaflet/lib/TileLayer.js"],"sourcesContent":["import { createElementObject, createTileLayerComponent, updateGridLayer, withPane } from '@react-leaflet/core';\nimport { TileLayer as LeafletTileLayer } from 'leaflet';\nexport const TileLayer = createTileLayerComponent(function createTileLayer({ url , ...options }, context) {\n    const layer = new LeafletTileLayer(url, withPane(options, context));\n    return createElementObject(layer, context);\n}, function updateTileLayer(layer, props, prevProps) {\n    updateGridLayer(layer, props, prevProps);\n    const { url  } = props;\n    if (url != null && url !== prevProps.url) {\n        layer.setUrl(url);\n    }\n});\n"],"names":[],"mappings":";;;;;;;;;;;AAEO,MAAM,YAAY,CAAA,GAAA,4JAAA,CAAA,2BAAwB,AAAD,EAAE,SAAS,gBAAgB,EAAE,GAAG,EAAG,GAAG,SAAS,EAAE,OAAO;IACpG,MAAM,QAAQ,IAAI,iJAAA,CAAA,YAAgB,CAAC,KAAK,CAAA,GAAA,yJAAA,CAAA,WAAQ,AAAD,EAAE,SAAS;IAC1D,OAAO,CAAA,GAAA,4JAAA,CAAA,sBAAmB,AAAD,EAAE,OAAO;AACtC,GAAG,SAAS,gBAAgB,KAAK,EAAE,KAAK,EAAE,SAAS;IAC/C,CAAA,GAAA,kKAAA,CAAA,kBAAe,AAAD,EAAE,OAAO,OAAO;IAC9B,MAAM,EAAE,GAAG,EAAG,GAAG;IACjB,IAAI,OAAO,QAAQ,QAAQ,UAAU,GAAG,EAAE;QACtC,MAAM,MAAM,CAAC;IACjB;AACJ"}},
    {"offset": {"line": 703, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 708, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/react-leaflet/lib/Marker.js"],"sourcesContent":["import { createElementObject, createLayerComponent, extendContext } from '@react-leaflet/core';\nimport { Marker as LeafletMarker } from 'leaflet';\nexport const Marker = createLayerComponent(function createMarker({ position , ...options }, ctx) {\n    const marker = new LeafletMarker(position, options);\n    return createElementObject(marker, extendContext(ctx, {\n        overlayContainer: marker\n    }));\n}, function updateMarker(marker, props, prevProps) {\n    if (props.position !== prevProps.position) {\n        marker.setLatLng(props.position);\n    }\n    if (props.icon != null && props.icon !== prevProps.icon) {\n        marker.setIcon(props.icon);\n    }\n    if (props.zIndexOffset != null && props.zIndexOffset !== prevProps.zIndexOffset) {\n        marker.setZIndexOffset(props.zIndexOffset);\n    }\n    if (props.opacity != null && props.opacity !== prevProps.opacity) {\n        marker.setOpacity(props.opacity);\n    }\n    if (marker.dragging != null && props.draggable !== prevProps.draggable) {\n        if (props.draggable === true) {\n            marker.dragging.enable();\n        } else {\n            marker.dragging.disable();\n        }\n    }\n});\n"],"names":[],"mappings":";;;;;;;;;;AAEO,MAAM,SAAS,CAAA,GAAA,4JAAA,CAAA,uBAAoB,AAAD,EAAE,SAAS,aAAa,EAAE,QAAQ,EAAG,GAAG,SAAS,EAAE,GAAG;IAC3F,MAAM,SAAS,IAAI,iJAAA,CAAA,SAAa,CAAC,UAAU;IAC3C,OAAO,CAAA,GAAA,4JAAA,CAAA,sBAAmB,AAAD,EAAE,QAAQ,CAAA,GAAA,4JAAA,CAAA,gBAAa,AAAD,EAAE,KAAK;QAClD,kBAAkB;IACtB;AACJ,GAAG,SAAS,aAAa,MAAM,EAAE,KAAK,EAAE,SAAS;IAC7C,IAAI,MAAM,QAAQ,KAAK,UAAU,QAAQ,EAAE;QACvC,OAAO,SAAS,CAAC,MAAM,QAAQ;IACnC;IACA,IAAI,MAAM,IAAI,IAAI,QAAQ,MAAM,IAAI,KAAK,UAAU,IAAI,EAAE;QACrD,OAAO,OAAO,CAAC,MAAM,IAAI;IAC7B;IACA,IAAI,MAAM,YAAY,IAAI,QAAQ,MAAM,YAAY,KAAK,UAAU,YAAY,EAAE;QAC7E,OAAO,eAAe,CAAC,MAAM,YAAY;IAC7C;IACA,IAAI,MAAM,OAAO,IAAI,QAAQ,MAAM,OAAO,KAAK,UAAU,OAAO,EAAE;QAC9D,OAAO,UAAU,CAAC,MAAM,OAAO;IACnC;IACA,IAAI,OAAO,QAAQ,IAAI,QAAQ,MAAM,SAAS,KAAK,UAAU,SAAS,EAAE;QACpE,IAAI,MAAM,SAAS,KAAK,MAAM;YAC1B,OAAO,QAAQ,CAAC,MAAM;QAC1B,OAAO;YACH,OAAO,QAAQ,CAAC,OAAO;QAC3B;IACJ;AACJ"}},
    {"offset": {"line": 744, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 749, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/react-leaflet/lib/Popup.js"],"sourcesContent":["import { createElementObject, createOverlayComponent } from '@react-leaflet/core';\nimport { Popup as LeafletPopup } from 'leaflet';\nimport { useEffect } from 'react';\nexport const Popup = createOverlayComponent(function createPopup(props, context) {\n    const popup = new LeafletPopup(props, context.overlayContainer);\n    return createElementObject(popup, context);\n}, function usePopupLifecycle(element, context, { position  }, setOpen) {\n    useEffect(function addPopup() {\n        const { instance  } = element;\n        function onPopupOpen(event) {\n            if (event.popup === instance) {\n                instance.update();\n                setOpen(true);\n            }\n        }\n        function onPopupClose(event) {\n            if (event.popup === instance) {\n                setOpen(false);\n            }\n        }\n        context.map.on({\n            popupopen: onPopupOpen,\n            popupclose: onPopupClose\n        });\n        if (context.overlayContainer == null) {\n            // Attach to a Map\n            if (position != null) {\n                instance.setLatLng(position);\n            }\n            instance.openOn(context.map);\n        } else {\n            // Attach to container component\n            context.overlayContainer.bindPopup(instance);\n        }\n        return function removePopup() {\n            context.map.off({\n                popupopen: onPopupOpen,\n                popupclose: onPopupClose\n            });\n            context.overlayContainer?.unbindPopup();\n            context.map.removeLayer(instance);\n        };\n    }, [\n        element,\n        context,\n        setOpen,\n        position\n    ]);\n});\n"],"names":[],"mappings":";;;;;;;;;;;AAGO,MAAM,QAAQ,CAAA,GAAA,4JAAA,CAAA,yBAAsB,AAAD,EAAE,SAAS,YAAY,KAAK,EAAE,OAAO;IAC3E,MAAM,QAAQ,IAAI,iJAAA,CAAA,QAAY,CAAC,OAAO,QAAQ,gBAAgB;IAC9D,OAAO,CAAA,GAAA,4JAAA,CAAA,sBAAmB,AAAD,EAAE,OAAO;AACtC,GAAG,SAAS,kBAAkB,OAAO,EAAE,OAAO,EAAE,EAAE,QAAQ,EAAG,EAAE,OAAO;IAClE,CAAA,GAAA,+MAAA,CAAA,YAAS,AAAD,EAAE,SAAS;QACf,MAAM,EAAE,QAAQ,EAAG,GAAG;QACtB,SAAS,YAAY,KAAK;YACtB,IAAI,MAAM,KAAK,KAAK,UAAU;gBAC1B,SAAS,MAAM;gBACf,QAAQ;YACZ;QACJ;QACA,SAAS,aAAa,KAAK;YACvB,IAAI,MAAM,KAAK,KAAK,UAAU;gBAC1B,QAAQ;YACZ;QACJ;QACA,QAAQ,GAAG,CAAC,EAAE,CAAC;YACX,WAAW;YACX,YAAY;QAChB;QACA,IAAI,QAAQ,gBAAgB,IAAI,MAAM;YAClC,kBAAkB;YAClB,IAAI,YAAY,MAAM;gBAClB,SAAS,SAAS,CAAC;YACvB;YACA,SAAS,MAAM,CAAC,QAAQ,GAAG;QAC/B,OAAO;YACH,gCAAgC;YAChC,QAAQ,gBAAgB,CAAC,SAAS,CAAC;QACvC;QACA,OAAO,SAAS;YACZ,QAAQ,GAAG,CAAC,GAAG,CAAC;gBACZ,WAAW;gBACX,YAAY;YAChB;YACA,QAAQ,gBAAgB,EAAE;YAC1B,QAAQ,GAAG,CAAC,WAAW,CAAC;QAC5B;IACJ,GAAG;QACC;QACA;QACA;QACA;KACH;AACL"}},
    {"offset": {"line": 806, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 811, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/react-leaflet/lib/hooks.js"],"sourcesContent":["import { useLeafletContext } from '@react-leaflet/core';\nimport { useEffect } from 'react';\nexport function useMap() {\n    return useLeafletContext().map;\n}\nexport function useMapEvent(type, handler) {\n    const map = useMap();\n    useEffect(function addMapEventHandler() {\n        // @ts-ignore event type\n        map.on(type, handler);\n        return function removeMapEventHandler() {\n            // @ts-ignore event type\n            map.off(type, handler);\n        };\n    }, [\n        map,\n        type,\n        handler\n    ]);\n    return map;\n}\nexport function useMapEvents(handlers) {\n    const map = useMap();\n    useEffect(function addMapEventHandlers() {\n        map.on(handlers);\n        return function removeMapEventHandlers() {\n            map.off(handlers);\n        };\n    }, [\n        map,\n        handlers\n    ]);\n    return map;\n}\n"],"names":[],"mappings":";;;;;;;;;;AAEO,SAAS;IACZ,OAAO,CAAA,GAAA,4JAAA,CAAA,oBAAiB,AAAD,IAAI,GAAG;AAClC;AACO,SAAS,YAAY,IAAI,EAAE,OAAO;IACrC,MAAM,MAAM;IACZ,CAAA,GAAA,+MAAA,CAAA,YAAS,AAAD,EAAE,SAAS;QACf,wBAAwB;QACxB,IAAI,EAAE,CAAC,MAAM;QACb,OAAO,SAAS;YACZ,wBAAwB;YACxB,IAAI,GAAG,CAAC,MAAM;QAClB;IACJ,GAAG;QACC;QACA;QACA;KACH;IACD,OAAO;AACX;AACO,SAAS,aAAa,QAAQ;IACjC,MAAM,MAAM;IACZ,CAAA,GAAA,+MAAA,CAAA,YAAS,AAAD,EAAE,SAAS;QACf,IAAI,EAAE,CAAC;QACP,OAAO,SAAS;YACZ,IAAI,GAAG,CAAC;QACZ;IACJ,GAAG;QACC;QACA;KACH;IACD,OAAO;AACX"}},
    {"offset": {"line": 853, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 858, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/react-leaflet/lib/ImageOverlay.js"],"sourcesContent":["import { createElementObject, createLayerComponent, extendContext, updateMediaOverlay } from '@react-leaflet/core';\nimport { LatLngBounds, ImageOverlay as LeafletImageOverlay } from 'leaflet';\nexport const ImageOverlay = createLayerComponent(function createImageOveraly({ bounds , url , ...options }, ctx) {\n    const overlay = new LeafletImageOverlay(url, bounds, options);\n    return createElementObject(overlay, extendContext(ctx, {\n        overlayContainer: overlay\n    }));\n}, function updateImageOverlay(overlay, props, prevProps) {\n    updateMediaOverlay(overlay, props, prevProps);\n    if (props.bounds !== prevProps.bounds) {\n        const bounds = props.bounds instanceof LatLngBounds ? props.bounds : new LatLngBounds(props.bounds);\n        overlay.setBounds(bounds);\n    }\n    if (props.url !== prevProps.url) {\n        overlay.setUrl(props.url);\n    }\n});\n"],"names":[],"mappings":";;;;;;;;;;;AAEO,MAAM,eAAe,CAAA,GAAA,4JAAA,CAAA,uBAAoB,AAAD,EAAE,SAAS,mBAAmB,EAAE,MAAM,EAAG,GAAG,EAAG,GAAG,SAAS,EAAE,GAAG;IAC3G,MAAM,UAAU,IAAI,iJAAA,CAAA,eAAmB,CAAC,KAAK,QAAQ;IACrD,OAAO,CAAA,GAAA,4JAAA,CAAA,sBAAmB,AAAD,EAAE,SAAS,CAAA,GAAA,4JAAA,CAAA,gBAAa,AAAD,EAAE,KAAK;QACnD,kBAAkB;IACtB;AACJ,GAAG,SAAS,mBAAmB,OAAO,EAAE,KAAK,EAAE,SAAS;IACpD,CAAA,GAAA,qKAAA,CAAA,qBAAkB,AAAD,EAAE,SAAS,OAAO;IACnC,IAAI,MAAM,MAAM,KAAK,UAAU,MAAM,EAAE;QACnC,MAAM,SAAS,MAAM,MAAM,YAAY,iJAAA,CAAA,eAAY,GAAG,MAAM,MAAM,GAAG,IAAI,iJAAA,CAAA,eAAY,CAAC,MAAM,MAAM;QAClG,QAAQ,SAAS,CAAC;IACtB;IACA,IAAI,MAAM,GAAG,KAAK,UAAU,GAAG,EAAE;QAC7B,QAAQ,MAAM,CAAC,MAAM,GAAG;IAC5B;AACJ"}},
    {"offset": {"line": 884, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 889, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/leaflet-defaulticon-compatibility/src/Icon.Default.compatibility.js"],"sourcesContent":["import * as L from 'leaflet';\n\n\nL.Icon.Default.mergeOptions({\n\t// Erase default options, so that they can be overridden by _initializeOptions if not supplied.\n\ticonUrl: null,\n\ticonRetinaUrl: null,\n\tshadowUrl: null,\n\ticonSize: null,\n\ticonAnchor: null,\n\tpopupAnchor: null,\n\ttooltipAnchor: null,\n\tshadowSize: null,\n\n\t// @option classNamePrefix: String = 'leaflet-default-icon-'\n\t// Prefix for the classes defined in CSS that contain the Icon options.\n\t// See the leaflet-defaulticon-compatibility.css file as a starter.\n\t// Expected suffixes are \"icon\", \"shadow\", \"popup\" and \"tooltip\".\n\tclassNamePrefix: 'leaflet-default-icon-',\n});\n\n\nL.Icon.Default.include({\n\n\t_needsInit: true,\n\n\t// Override to make sure options are retrieved from CSS.\n\t_getIconUrl: function (name) {\n\t\t// @option imagePath: String\n\t\t// `Icon.Default` will try to auto-detect the location of\n\t\t// the blue icon images. If you are placing these images in a\n\t\t// non-standard way, set this option to point to the right\n\t\t// path, before any marker is added to a map.\n\t\t// Caution: do not use this option with inline base64 image(s).\n\t\tvar imagePath = this.options.imagePath || L.Icon.Default.imagePath || '';\n\t\t// Deprecated (IconDefault.imagePath), backwards-compatibility only\n\n\t\tif (this._needsInit) {\n\t\t\t// Modifying imagePath option after _getIconUrl has been called\n\t\t\t// once in this instance of IconDefault will no longer have any\n\t\t\t// effect.\n\t\t\tthis._initializeOptions(imagePath);\n\t\t}\n\n\t\treturn imagePath + L.Icon.prototype._getIconUrl.call(this, name);\n\t},\n\n\t// Initialize all necessary options for this instance.\n\t_initializeOptions: function (imagePath) {\n\t\tthis._setOptions('icon', _detectIconOptions, imagePath);\n\t\tthis._setOptions('shadow', _detectIconOptions, imagePath);\n\t\tthis._setOptions('popup', _detectDivOverlayOptions);\n\t\tthis._setOptions('tooltip', _detectDivOverlayOptions);\n\t\tthis._needsInit = false;\n\t},\n\n\t// Retrieve values from CSS and assign to this instance options.\n\t_setOptions: function (name, detectorFn, imagePath) {\n\t\tvar options = this.options,\n\t\t    prefix = options.classNamePrefix,\n\t\t    optionValues = detectorFn(prefix + name, imagePath);\n\n\t\tfor (var optionName in optionValues) {\n\t\t\toptions[name + optionName] = options[name + optionName] || optionValues[optionName];\n\t\t}\n\t}\n\n});\n\n\n// Retrieve icon option values from CSS (icon or shadow).\nfunction _detectIconOptions(className, imagePath) {\n\tvar el = L.DomUtil.create('div',  className, document.body),\n\t    urlsContainer = _getBkgImageOrCursor(el),\n\t    urls = _extractUrls(urlsContainer, imagePath),\n\t    iconX = _getStyleInt(el, 'width'),\n\t    iconY = _getStyleInt(el, 'height'),\n\t    anchorNX = _getStyleInt(el, 'margin-left'),\n\t    anchorNY = _getStyleInt(el, 'margin-top');\n\n\tel.parentNode.removeChild(el);\n\n\treturn {\n\t\tUrl: urls[0],\n\t\tRetinaUrl: urls[1],\n\t\tSize: [iconX, iconY],\n\t\tAnchor: [-anchorNX, -anchorNY]\n\t};\n}\n\n// Retrieve anchor option values from CSS (popup or tooltip).\nfunction _detectDivOverlayOptions(className) {\n\tvar el = L.DomUtil.create('div', className, document.body),\n\t    anchorX = _getStyleInt(el, 'margin-left'),\n\t    anchorY = _getStyleInt(el, 'margin-top');\n\n\tel.parentNode.removeChild(el);\n\n\treturn {\n\t\tAnchor: [anchorX, anchorY]\n\t};\n}\n\n// Read the CSS url (could be path or inline base64), may be multiple.\n// First: normal icon\n// Second: Retina icon\nfunction _extractUrls(urlsContainer, imagePath) {\n\tvar re = /url\\(['\"]?([^\"']*?)['\"]?\\)/gi, // Match anything between url( and ), possibly with single or double quotes.\n\t    urls = [],\n\t    m = re.exec(urlsContainer);\n\n\twhile (m) {\n\t\t// Keep the entire URL from CSS rule, so that each image can have its own full URL.\n\t\t// Except in the case imagePath is provided: remove the path part (i.e. keep only the file name).\n\t\turls.push(imagePath ? _stripPath(m[1]) : m[1]);\n\t\tm = re.exec(urlsContainer);\n\t}\n\n\treturn urls;\n}\n\n// Remove anything before the last slash (/) occurrence (inclusive).\n// Caution: will give unexpected result if url is inline base64 data\n// => do not specify imagePath in that case!\nfunction _stripPath(url) {\n\treturn url.substr(url.lastIndexOf('/') + 1);\n}\n\nfunction _getStyleInt(el, style) {\n\treturn parseInt(_getStyle(el, style), 10);\n}\n\n// Factorize style reading fallback for IE8.\nfunction _getStyle(el, style) {\n\treturn L.DomUtil.getStyle(el, style) || L.DomUtil.getStyle(el, _kebabToCamelCase(style));\n}\n\n// When Firefox high contrast (colours override) option is enabled,\n// \"background-image\" is overridden by the browser as \"none\".\n// In that case, fallback to \"cursor\". But keep \"background-image\"\n// as primary source because IE expects cursor URL as relative to HTML page\n// instead of relative to CSS file.\nfunction _getBkgImageOrCursor(el) {\n\tvar bkgImage = _getStyle(el, 'background-image');\n\n\treturn bkgImage && bkgImage !== 'none' ? bkgImage : _getStyle(el, 'cursor');\n}\n\n// Convert kebab-case CSS property name to camelCase for IE currentStyle.\nfunction _kebabToCamelCase(prop) {\n\treturn prop.replace(/-(\\w)/g, function (str, w) {\n\t\treturn w.toUpperCase();\n\t});\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1014, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1018, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/leaflet-rastercoords/rastercoords.js"],"sourcesContent":["/**\n * leaflet plugin for plain image map projection\n * @copyright 2016- commenthol\n * @license MIT\n */\n/* globals define */\n/* eslint no-var:off */\n\n;(function (factory) {\n  var L\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['leaflet'], factory)\n  } else if (typeof module !== 'undefined') {\n    // Node/CommonJS\n    L = require('leaflet')\n    module.exports = factory(L)\n  } else {\n    // Browser globals\n    if (typeof window.L === 'undefined') {\n      throw new Error('Leaflet must be loaded first')\n    }\n    factory(window.L)\n  }\n}(function (L) {\n  /**\n   * L.RasterCoords\n   * @param {L.map} map - the map used\n   * @param {Array} imgsize - [ width, height ] image dimensions\n   * @param {Number} [tilesize] - tilesize in pixels. Default=256\n   * @param {Boolean} setmaxbounds - automatically set map max bounds. Default=true\n   */\n  L.RasterCoords = function (map, imgsize, tilesize, setmaxbounds = true) {\n    this.map = map\n    this.width = imgsize[0]\n    this.height = imgsize[1]\n    this.tilesize = tilesize || 256\n    this.zoom = this.zoomLevel()\n    if (setmaxbounds && this.width && this.height) {\n      this.setMaxBounds()\n    }\n  }\n\n  L.RasterCoords.prototype = {\n    /**\n     * calculate accurate zoom level for the given image size\n     */\n    zoomLevel: function () {\n      return Math.ceil(\n        Math.log(\n          Math.max(this.width, this.height) /\n          this.tilesize\n        ) / Math.log(2)\n      )\n    },\n    /**\n     * unproject `coords` to the raster coordinates used by the raster image projection\n     * @param {Array} coords - [ x, y ]\n     * @return {L.LatLng} - internal coordinates\n     */\n    unproject: function (coords) {\n      return this.map.unproject(coords, this.zoom)\n    },\n    /**\n     * project `coords` back to image coordinates\n     * @param {Array} coords - [ x, y ]\n     * @return {L.LatLng} - image coordinates\n     */\n    project: function (coords) {\n      return this.map.project(coords, this.zoom)\n    },\n    /**\n     * get the max bounds of the image\n     */\n    getMaxBounds: function () {\n      var southWest = this.unproject([0, this.height])\n      var northEast = this.unproject([this.width, 0])\n      return new L.LatLngBounds(southWest, northEast)\n    },\n    /**\n     * sets the max bounds on map\n     */\n    setMaxBounds: function () {\n      var bounds = this.getMaxBounds()\n      this.map.setMaxBounds(bounds)\n    }\n  }\n\n  return L.RasterCoords\n}))\n; // eslint-disable-line semi\n"],"names":[],"mappings":"AAAA;;;;CAIC,GACD,kBAAkB;AAGhB,CAAA,SAAU,OAAO;IACjB,IAAI;IACJ,IAAI,OAAO,WAAW,cAAc,OAAO,GAAG,EAAE;QAC9C,MAAM;QACN,wDAAoB;IACtB,OAAO,IAAI,OAAO,WAAW,aAAa;QACxC,gBAAgB;QAChB;QACA,OAAO,OAAO,GAAG,QAAQ;IAC3B,OAAO;QACL,kBAAkB;QAClB,IAAI,OAAO,OAAO,CAAC,KAAK,aAAa;YACnC,MAAM,IAAI,MAAM;QAClB;QACA,QAAQ,OAAO,CAAC;IAClB;AACF,CAAA,EAAE,SAAU,CAAC;IACX;;;;;;GAMC,GACD,EAAE,YAAY,GAAG,SAAU,GAAG,EAAE,OAAO,EAAE,QAAQ,EAAE,eAAe,IAAI;QACpE,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC,EAAE;QACvB,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC,EAAE;QACxB,IAAI,CAAC,QAAQ,GAAG,YAAY;QAC5B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,SAAS;QAC1B,IAAI,gBAAgB,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,EAAE;YAC7C,IAAI,CAAC,YAAY;QACnB;IACF;IAEA,EAAE,YAAY,CAAC,SAAS,GAAG;QACzB;;KAEC,GACD,WAAW;YACT,OAAO,KAAK,IAAI,CACd,KAAK,GAAG,CACN,KAAK,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,IAChC,IAAI,CAAC,QAAQ,IACX,KAAK,GAAG,CAAC;QAEjB;QACA;;;;KAIC,GACD,WAAW,SAAU,MAAM;YACzB,OAAO,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,QAAQ,IAAI,CAAC,IAAI;QAC7C;QACA;;;;KAIC,GACD,SAAS,SAAU,MAAM;YACvB,OAAO,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,QAAQ,IAAI,CAAC,IAAI;QAC3C;QACA;;KAEC,GACD,cAAc;YACZ,IAAI,YAAY,IAAI,CAAC,SAAS,CAAC;gBAAC;gBAAG,IAAI,CAAC,MAAM;aAAC;YAC/C,IAAI,YAAY,IAAI,CAAC,SAAS,CAAC;gBAAC,IAAI,CAAC,KAAK;gBAAE;aAAE;YAC9C,OAAO,IAAI,EAAE,YAAY,CAAC,WAAW;QACvC;QACA;;KAEC,GACD,cAAc;YACZ,IAAI,SAAS,IAAI,CAAC,YAAY;YAC9B,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC;QACxB;IACF;IAEA,OAAO,EAAE,YAAY;AACvB,IACE,2BAA2B"}},
    {"offset": {"line": 1098, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1103, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@allmaps/stdlib/dist/fetch.js"],"sourcesContent":["export async function fetchUrl(input, init, fetchFn) {\n    let response;\n    if (typeof fetchFn === 'function') {\n        response = await fetchFn(input, init);\n    }\n    else {\n        response = await fetch(input, init);\n    }\n    if (!response.ok) {\n        throw new Error(response.statusText);\n    }\n    return response;\n}\nexport async function fetchJson(input, init, fetchFn) {\n    const response = await fetchUrl(input, init, fetchFn);\n    return await response.json();\n}\nexport async function fetchImageInfo(imageUri, init, fetchFn) {\n    return await fetchJson(`${imageUri}/info.json`, init, fetchFn);\n}\nexport async function fetchImageBitmap(input, init, fetchFn) {\n    const response = await fetchUrl(input, init, fetchFn);\n    const blob = await response.blob();\n    return await createImageBitmap(blob);\n}\n"],"names":[],"mappings":";;;;;;AAAO,eAAe,SAAS,KAAK,EAAE,IAAI,EAAE,OAAO;IAC/C,IAAI;IACJ,IAAI,OAAO,YAAY,YAAY;QAC/B,WAAW,MAAM,QAAQ,OAAO;IACpC,OACK;QACD,WAAW,MAAM,MAAM,OAAO;IAClC;IACA,IAAI,CAAC,SAAS,EAAE,EAAE;QACd,MAAM,IAAI,MAAM,SAAS,UAAU;IACvC;IACA,OAAO;AACX;AACO,eAAe,UAAU,KAAK,EAAE,IAAI,EAAE,OAAO;IAChD,MAAM,WAAW,MAAM,SAAS,OAAO,MAAM;IAC7C,OAAO,MAAM,SAAS,IAAI;AAC9B;AACO,eAAe,eAAe,QAAQ,EAAE,IAAI,EAAE,OAAO;IACxD,OAAO,MAAM,UAAU,CAAC,EAAE,SAAS,UAAU,CAAC,EAAE,MAAM;AAC1D;AACO,eAAe,iBAAiB,KAAK,EAAE,IAAI,EAAE,OAAO;IACvD,MAAM,WAAW,MAAM,SAAS,OAAO,MAAM;IAC7C,MAAM,OAAO,MAAM,SAAS,IAAI;IAChC,OAAO,MAAM,kBAAkB;AACnC"}},
    {"offset": {"line": 1133, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1138, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@allmaps/stdlib/dist/api.js"],"sourcesContent":["import { fetchJson } from './fetch.js';\nfunction fetchAnnotationsByIiifUrl(url) {\n    // TODO: move base URLs to env/config file\n    return fetchJson(`https://annotations.allmaps.org/?url=${url}`);\n}\nasync function fetchAnnotationsForImage(parsedImage) {\n    try {\n        const annotations = await fetchAnnotationsByIiifUrl(`${parsedImage.uri}/info.json`);\n        return [annotations];\n    }\n    catch (err) {\n        return [];\n    }\n}\nasync function fetchAnnotationsForManifest(parsedManifest) {\n    try {\n        const annotations = await fetchAnnotationsByIiifUrl(parsedManifest.uri);\n        return [annotations];\n    }\n    catch (err) {\n        const annotations = [];\n        for (const canvas of parsedManifest.canvases) {\n            const imageAnnotations = await fetchAnnotationsForImage(canvas.image);\n            annotations.push(...imageAnnotations);\n        }\n        return annotations;\n    }\n}\nasync function fetchAnnotationsForCollection(parsedCollection) {\n    try {\n        const annotations = await fetchAnnotationsByIiifUrl(parsedCollection.uri);\n        return [annotations];\n    }\n    catch (err) {\n        const annotations = [];\n        for (const item of parsedCollection.items) {\n            if (item.type === 'collection') {\n                const itemAnnotations = await fetchAnnotationsForCollection(item);\n                annotations.push(...itemAnnotations);\n            }\n            else if (item.type === 'manifest' && 'canvases' in item) {\n                const itemAnnotations = await fetchAnnotationsForManifest(item);\n                annotations.push(...itemAnnotations);\n            }\n        }\n        return annotations;\n    }\n}\nexport function fetchAnnotationsFromApi(parsedIiif) {\n    if (parsedIiif.type === 'image') {\n        return fetchAnnotationsForImage(parsedIiif);\n    }\n    else if (parsedIiif.type === 'manifest') {\n        return fetchAnnotationsForManifest(parsedIiif);\n    }\n    else if (parsedIiif.type === 'collection') {\n        return fetchAnnotationsForCollection(parsedIiif);\n    }\n    else {\n        throw new Error('Unsupported IIIF resource');\n    }\n}\n"],"names":[],"mappings":";;;;;;AACA,SAAS,0BAA0B,GAAG;IAClC,0CAA0C;IAC1C,OAAO,CAAA,GAAA,oJAAA,CAAA,YAAS,AAAD,EAAE,CAAC,qCAAqC,EAAE,IAAI,CAAC;AAClE;AACA,eAAe,yBAAyB,WAAW;IAC/C,IAAI;QACA,MAAM,cAAc,MAAM,0BAA0B,CAAC,EAAE,YAAY,GAAG,CAAC,UAAU,CAAC;QAClF,OAAO;YAAC;SAAY;IACxB,EACA,OAAO,KAAK;QACR,OAAO,EAAE;IACb;AACJ;AACA,eAAe,4BAA4B,cAAc;IACrD,IAAI;QACA,MAAM,cAAc,MAAM,0BAA0B,eAAe,GAAG;QACtE,OAAO;YAAC;SAAY;IACxB,EACA,OAAO,KAAK;QACR,MAAM,cAAc,EAAE;QACtB,KAAK,MAAM,UAAU,eAAe,QAAQ,CAAE;YAC1C,MAAM,mBAAmB,MAAM,yBAAyB,OAAO,KAAK;YACpE,YAAY,IAAI,IAAI;QACxB;QACA,OAAO;IACX;AACJ;AACA,eAAe,8BAA8B,gBAAgB;IACzD,IAAI;QACA,MAAM,cAAc,MAAM,0BAA0B,iBAAiB,GAAG;QACxE,OAAO;YAAC;SAAY;IACxB,EACA,OAAO,KAAK;QACR,MAAM,cAAc,EAAE;QACtB,KAAK,MAAM,QAAQ,iBAAiB,KAAK,CAAE;YACvC,IAAI,KAAK,IAAI,KAAK,cAAc;gBAC5B,MAAM,kBAAkB,MAAM,8BAA8B;gBAC5D,YAAY,IAAI,IAAI;YACxB,OACK,IAAI,KAAK,IAAI,KAAK,cAAc,cAAc,MAAM;gBACrD,MAAM,kBAAkB,MAAM,4BAA4B;gBAC1D,YAAY,IAAI,IAAI;YACxB;QACJ;QACA,OAAO;IACX;AACJ;AACO,SAAS,wBAAwB,UAAU;IAC9C,IAAI,WAAW,IAAI,KAAK,SAAS;QAC7B,OAAO,yBAAyB;IACpC,OACK,IAAI,WAAW,IAAI,KAAK,YAAY;QACrC,OAAO,4BAA4B;IACvC,OACK,IAAI,WAAW,IAAI,KAAK,cAAc;QACvC,OAAO,8BAA8B;IACzC,OACK;QACD,MAAM,IAAI,MAAM;IACpB;AACJ"}},
    {"offset": {"line": 1204, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1209, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@allmaps/stdlib/dist/background-color.js"],"sourcesContent":["const DEFAULT_BIN_SIZE = 5;\nconst DEFAULT_RESOLUTION = 2;\nexport function getImageData(imageBitmap, mask) {\n    const canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n    const context = canvas.getContext('2d');\n    if (!context) {\n        throw new Error('Could not create OffscreenCanvas context');\n    }\n    if (mask) {\n        context.fillStyle = 'rgba(0, 0, 0, 0)';\n        context.fillRect(0, 0, imageBitmap.width, imageBitmap.height);\n        context.beginPath();\n        context.moveTo(mask[0][0], mask[0][1]);\n        mask.slice(1).forEach((point) => context.lineTo(point[0], point[1]));\n        context.closePath();\n        context.clip();\n    }\n    context.drawImage(imageBitmap, 0, 0);\n    return context.getImageData(0, 0, imageBitmap.width, imageBitmap.height);\n}\nexport function getColorsArray(imageData, resolution = DEFAULT_RESOLUTION) {\n    const colors = [];\n    for (let x = 0; x < imageData.width; x += resolution) {\n        for (let y = 0; y < imageData.height; y += resolution) {\n            const startIndex = (x + y * imageData.width) * 4;\n            const opacity = imageData.data[startIndex + 3];\n            if (opacity > 0) {\n                const color = [\n                    imageData.data[startIndex],\n                    imageData.data[startIndex + 1],\n                    imageData.data[startIndex + 2]\n                ];\n                colors.push(color);\n            }\n        }\n    }\n    return colors;\n}\nexport function getColorHistogram(colors, binSize = DEFAULT_BIN_SIZE) {\n    const histogram = {};\n    for (const color of colors) {\n        const bin = createColorBin(color, binSize);\n        if (!histogram[bin]) {\n            histogram[bin] = {\n                count: 0,\n                color\n            };\n        }\n        histogram[bin].count += 1;\n    }\n    return histogram;\n}\nexport function getMaxOccurringColor(histogram) {\n    let max = Number.NEGATIVE_INFINITY;\n    let maxOccurringColor;\n    for (const { count, color } of Object.values(histogram)) {\n        if (count > max) {\n            max = count;\n            maxOccurringColor = color;\n        }\n    }\n    if (!maxOccurringColor) {\n        throw new Error('Histogram is empty');\n    }\n    return {\n        count: max,\n        color: maxOccurringColor\n    };\n}\nfunction createColorBin(color, binSize) {\n    return color.map((c) => Math.round(c / binSize)).toString();\n}\n"],"names":[],"mappings":";;;;;;AAAA,MAAM,mBAAmB;AACzB,MAAM,qBAAqB;AACpB,SAAS,aAAa,WAAW,EAAE,IAAI;IAC1C,MAAM,SAAS,IAAI,gBAAgB,YAAY,KAAK,EAAE,YAAY,MAAM;IACxE,MAAM,UAAU,OAAO,UAAU,CAAC;IAClC,IAAI,CAAC,SAAS;QACV,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,MAAM;QACN,QAAQ,SAAS,GAAG;QACpB,QAAQ,QAAQ,CAAC,GAAG,GAAG,YAAY,KAAK,EAAE,YAAY,MAAM;QAC5D,QAAQ,SAAS;QACjB,QAAQ,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC,EAAE;QACrC,KAAK,KAAK,CAAC,GAAG,OAAO,CAAC,CAAC,QAAU,QAAQ,MAAM,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE;QAClE,QAAQ,SAAS;QACjB,QAAQ,IAAI;IAChB;IACA,QAAQ,SAAS,CAAC,aAAa,GAAG;IAClC,OAAO,QAAQ,YAAY,CAAC,GAAG,GAAG,YAAY,KAAK,EAAE,YAAY,MAAM;AAC3E;AACO,SAAS,eAAe,SAAS,EAAE,aAAa,kBAAkB;IACrE,MAAM,SAAS,EAAE;IACjB,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,KAAK,EAAE,KAAK,WAAY;QAClD,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,KAAK,WAAY;YACnD,MAAM,aAAa,CAAC,IAAI,IAAI,UAAU,KAAK,IAAI;YAC/C,MAAM,UAAU,UAAU,IAAI,CAAC,aAAa,EAAE;YAC9C,IAAI,UAAU,GAAG;gBACb,MAAM,QAAQ;oBACV,UAAU,IAAI,CAAC,WAAW;oBAC1B,UAAU,IAAI,CAAC,aAAa,EAAE;oBAC9B,UAAU,IAAI,CAAC,aAAa,EAAE;iBACjC;gBACD,OAAO,IAAI,CAAC;YAChB;QACJ;IACJ;IACA,OAAO;AACX;AACO,SAAS,kBAAkB,MAAM,EAAE,UAAU,gBAAgB;IAChE,MAAM,YAAY,CAAC;IACnB,KAAK,MAAM,SAAS,OAAQ;QACxB,MAAM,MAAM,eAAe,OAAO;QAClC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE;YACjB,SAAS,CAAC,IAAI,GAAG;gBACb,OAAO;gBACP;YACJ;QACJ;QACA,SAAS,CAAC,IAAI,CAAC,KAAK,IAAI;IAC5B;IACA,OAAO;AACX;AACO,SAAS,qBAAqB,SAAS;IAC1C,IAAI,MAAM,OAAO,iBAAiB;IAClC,IAAI;IACJ,KAAK,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI,OAAO,MAAM,CAAC,WAAY;QACrD,IAAI,QAAQ,KAAK;YACb,MAAM;YACN,oBAAoB;QACxB;IACJ;IACA,IAAI,CAAC,mBAAmB;QACpB,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;QACH,OAAO;QACP,OAAO;IACX;AACJ;AACA,SAAS,eAAe,KAAK,EAAE,OAAO;IAClC,OAAO,MAAM,GAAG,CAAC,CAAC,IAAM,KAAK,KAAK,CAAC,IAAI,UAAU,QAAQ;AAC7D"}},
    {"offset": {"line": 1287, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1292, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@allmaps/stdlib/dist/geometry.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { rewindGeometry } from '@placemarkio/geojson-rewind'; // TODO: consider implementing these functions in this module instead of using dependencies\n// Assert\nexport function isPoint(input) {\n    return (Array.isArray(input) &&\n        input.length === 2 &&\n        typeof input[0] === 'number' &&\n        typeof input[1] === 'number');\n}\nexport function isLineString(input) {\n    return Array.isArray(input) && input.every(isPoint);\n    // && !isClosed(input) // Possible addition if we want to check for closedness\n}\n// TODO: check if we keep Ring as unclosed.\n// This function is not exported because Ring should not be used externally, since it can not be distingised from LineSting\nfunction isRing(input) {\n    return (Array.isArray(input) && input.every(isPoint)\n    // && isClosed(input) === closed // Possible addition if we want to check for closedness, with closed an input parameter with default false\n    );\n}\nexport function isPolygon(input) {\n    return Array.isArray(input) && input.every(isRing);\n}\nexport function isMultiPoint(input) {\n    return Array.isArray(input) && input.every(isPoint);\n}\nexport function isMultiLineString(input) {\n    return Array.isArray(input) && input.every(isLineString);\n}\nexport function isMultiPolygon(input) {\n    return Array.isArray(input) && input.every(isPolygon);\n}\nexport function isGeometry(input) {\n    return (isPoint(input) ||\n        isLineString(input) ||\n        isPolygon(input) ||\n        isMultiPoint(input) ||\n        isMultiLineString(input) ||\n        isMultiPolygon(input));\n}\n// Conform\nexport function conformLineString(lineString) {\n    // Filter out repeated points\n    lineString = lineString.filter(function (point, i, originalLineString) {\n        return i === 0 || !isEqualPoint(point, originalLineString[i - 1]);\n    });\n    if (lineString.length < 2) {\n        throw new Error('LineString should contain at least 2 points');\n    }\n    return lineString;\n}\nexport function conformRing(ring) {\n    // Filter out repeated points\n    ring = ring.filter(function (point, i, originalRing) {\n        return i === 0 || !isEqualPoint(point, originalRing[i - 1]);\n    });\n    // Remove last point if input is closed ring\n    if (isClosed(ring)) {\n        ring.splice(-1);\n    }\n    if (ring.length < 3) {\n        throw new Error('Ring should contain at least 3 points');\n    }\n    return ring;\n}\nexport function conformPolygon(polygon) {\n    return polygon.map((ring) => {\n        return conformRing(ring);\n    });\n}\nexport function conformMultiLineString(multiLineString) {\n    return multiLineString.map((lineString) => conformLineString(lineString));\n}\nexport function conformMultiPolygon(multiPolygon) {\n    return multiPolygon.map((polygon) => conformPolygon(polygon));\n}\n// Convert to GeoJSON\nexport function convertPointToGeojsonPoint(point) {\n    return {\n        type: 'Point',\n        coordinates: point\n    };\n}\nexport function convertLineStringToGeojsonLineString(lineString) {\n    return {\n        type: 'LineString',\n        coordinates: lineString\n    };\n}\nexport function convertRingToGeojsonPolygon(ring, close = true) {\n    const geometry = {\n        type: 'Polygon',\n        coordinates: close ? [[...ring, ring[0]]] : [ring]\n    };\n    return rewindGeometry(geometry);\n}\nexport function convertPolygonToGeojsonPolygon(polygon, close = true) {\n    const geometry = {\n        type: 'Polygon',\n        coordinates: close\n            ? polygon.map((ring) => {\n                return [...ring, ring[0]];\n            })\n            : polygon\n    };\n    return rewindGeometry(geometry);\n}\nexport function convertMultiPointToGeojsonMultiPoint(multiPoint) {\n    return {\n        type: 'MultiPoint',\n        coordinates: multiPoint\n    };\n}\nexport function convertMultiLineStringToGeojsonMultiLineString(multiLineString) {\n    return {\n        type: 'MultiLineString',\n        coordinates: multiLineString\n    };\n}\nexport function convertMultiPolygonToGeojsonMultiPolygon(multiPolygon, close = true) {\n    const geometry = {\n        type: 'MultiPolygon',\n        coordinates: close\n            ? multiPolygon.map((polygon) => polygon.map((ring) => {\n                return [...ring, ring[0]];\n            }))\n            : multiPolygon\n    };\n    return rewindGeometry(geometry);\n}\nexport function convertGeometryToGeojsonGeometry(geometry) {\n    if (isPoint(geometry)) {\n        return convertPointToGeojsonPoint(geometry);\n    }\n    else if (isLineString(geometry)) {\n        return convertLineStringToGeojsonLineString(geometry);\n    }\n    else if (isPolygon(geometry)) {\n        return convertPolygonToGeojsonPolygon(geometry);\n    }\n    else if (isMultiPoint(geometry)) {\n        return convertMultiPointToGeojsonMultiPoint(geometry);\n    }\n    else if (isMultiLineString(geometry)) {\n        return convertMultiLineStringToGeojsonMultiLineString(geometry);\n    }\n    else if (isMultiPolygon(geometry)) {\n        return convertMultiPolygonToGeojsonMultiPolygon(geometry);\n    }\n    else {\n        throw new Error('Geometry type not supported');\n    }\n}\n// Check\nexport function isClosed(input) {\n    return (Array.isArray(input) &&\n        input.length >= 2 &&\n        isEqualPoint(input[0], input[input.length - 1]));\n}\nexport function isEqualPoint(point0, point1) {\n    if (point0 === point1)\n        return true;\n    if (point0 === null || point1 === null)\n        return false;\n    return point0[0] === point1[0] && point0[1] === point1[1];\n}\nexport function isEqualPointArray(pointArray0, pointArray1) {\n    if (pointArray0 === pointArray1)\n        return true;\n    if (!pointArray0 || !pointArray1)\n        return false;\n    if (pointArray0.length !== pointArray1.length)\n        return false;\n    for (let i = 0; i < pointArray0.length; ++i) {\n        if (isEqualPoint(pointArray0[i], pointArray1[i]))\n            return false;\n    }\n    return true;\n}\nexport function isEqualPointArrayArray(pointArrayArray0, pointArrayArray1) {\n    if (pointArrayArray0 === pointArrayArray1)\n        return true;\n    if (!pointArrayArray0 || !pointArrayArray1)\n        return false;\n    if (pointArrayArray0.length !== pointArrayArray1.length)\n        return false;\n    for (let i = 0; i < pointArrayArray0.length; ++i) {\n        if (isEqualPointArray(pointArrayArray0[i], pointArrayArray1[i]))\n            return false;\n    }\n    return true;\n}\n// Compute\nexport function pointToPixel(point, translate = [0, 0], size) {\n    return point.map((coordinate, index) => {\n        let result = Math.floor(coordinate + translate[index]);\n        if (size) {\n            result = Math.max(result, 0);\n            result = Math.min(result, size[index] - 1);\n        }\n        return result;\n    });\n}\nexport function pixelToIntArrayIndex(pixel, size, channels, flipY = false) {\n    const column = pixel[0];\n    const row = flipY ? size[1] - 1 - pixel[1] : pixel[1];\n    return (row * size[0] + column) * channels;\n}\nexport function flipX(point) {\n    return [-point[0], point[1]];\n}\nexport function flipY(point) {\n    return [point[0], -point[1]];\n}\nexport function midPoint(point0, point1) {\n    return [\n        (point1[0] - point0[0]) / 2 + point0[0],\n        (point1[1] - point0[1]) / 2 + point0[1]\n    ];\n}\nexport function mixNumbers(number0, number1, t) {\n    return number0 * t + number1 * (1 - t);\n}\nexport function mixPoints(point0, point1, t) {\n    return [\n        point0[0] * t + point1[0] * (1 - t),\n        point0[1] * t + point1[1] * (1 - t)\n    ];\n}\nexport function distance(from, to) {\n    if (isLineString(from) && from.length === 2) {\n        return distance(from[0], from[1]);\n    }\n    else if (isPoint(from) && isPoint(to)) {\n        return Math.sqrt((to[0] - from[0]) ** 2 + (to[1] - from[1]) ** 2);\n    }\n    else {\n        throw new Error('Input type not supported');\n    }\n}\nexport function degreesToRadians(degrees) {\n    return degrees * (Math.PI / 180);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1554, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1559, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@allmaps/stdlib/dist/geojson.js"],"sourcesContent":["import { isPoint, isLineString, isPolygon, isMultiPoint, isMultiLineString, isMultiPolygon, conformLineString, conformRing, conformPolygon, conformMultiLineString, conformMultiPolygon } from './geometry.js';\n// Assert\nexport function isGeojsonPoint(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        input.type === 'Point' &&\n        isPoint(input.coordinates));\n}\nexport function isGeojsonLineString(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        input.type === 'LineString' &&\n        isLineString(input.coordinates));\n}\nexport function isGeojsonPolygon(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        input.type === 'Polygon' &&\n        Array.isArray(input.coordinates) &&\n        isPolygon(input.coordinates));\n}\nexport function isGeojsonMultiPoint(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        input.type === 'MultiPoint' &&\n        isMultiPoint(input.coordinates));\n}\nexport function isGeojsonMultiLineString(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        input.type === 'MultiLineString' &&\n        isMultiLineString(input.coordinates));\n}\nexport function isGeojsonMultiPolygon(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        input.type === 'MultiPolygon' &&\n        Array.isArray(input.coordinates) &&\n        isMultiPolygon(input.coordinates));\n}\nexport function isGeojsonGeometry(obj) {\n    const isObject = typeof obj === 'object' && obj !== null;\n    const hasStringType = isObject && 'type' in obj && typeof obj.type === 'string';\n    const isValidType = hasStringType &&\n        (obj.type === 'Point' ||\n            obj.type === 'LineString' ||\n            obj.type === 'Polygon' ||\n            obj.type === 'MultiPoint' ||\n            obj.type === 'MultiLineString' ||\n            obj.type === 'MultiPolygon');\n    const hasCoordinatesArray = isObject && 'coordinates' in obj && Array.isArray(obj.coordinates);\n    return isValidType && hasCoordinatesArray;\n}\n// Convert to Geometry\nexport function convertGeojsonPointToPoint(geojsonPoint) {\n    return geojsonPoint.coordinates;\n}\nexport function convertGeojsonLineStringToLineString(geojsonLineString) {\n    return conformLineString(geojsonLineString.coordinates);\n}\nexport function convertGeojsonPolygonToRing(geojsonPolygon, close = false) {\n    let outerRing = geojsonPolygon.coordinates[0];\n    outerRing = conformRing(outerRing);\n    return close ? [...outerRing, outerRing[0]] : outerRing;\n}\nexport function convertGeojsonPolygonToPolygon(geojsonPolygon, close = false) {\n    let polygon = geojsonPolygon.coordinates;\n    polygon = conformPolygon(polygon);\n    return close ? polygon.map((ring) => [...ring, ring[0]]) : polygon;\n}\nexport function convertGeojsonMultiPointToMultiPoint(geojsonMultiPoint) {\n    return geojsonMultiPoint.coordinates;\n}\nexport function convertGeojsonMultiLineStringToMultiLineString(geojsonMultiLineString) {\n    return conformMultiLineString(geojsonMultiLineString.coordinates);\n}\nexport function convertGeojsonMultiPolygonToMultiPolygon(geojsonMultiPolygon, close = false) {\n    let multipolygon = geojsonMultiPolygon.coordinates;\n    multipolygon = conformMultiPolygon(multipolygon);\n    return close\n        ? multipolygon.map((polygon) => polygon.map((ring) => [...ring, ring[0]]))\n        : multipolygon;\n}\nexport function convertGeojsonGeometryToGeometry(geojsonGeometry) {\n    if (isGeojsonPoint(geojsonGeometry)) {\n        return convertGeojsonPointToPoint(geojsonGeometry);\n    }\n    else if (isGeojsonLineString(geojsonGeometry)) {\n        return convertGeojsonLineStringToLineString(geojsonGeometry);\n    }\n    else if (isGeojsonPolygon(geojsonGeometry)) {\n        return convertGeojsonPolygonToPolygon(geojsonGeometry);\n    }\n    else if (isGeojsonMultiPoint(geojsonGeometry)) {\n        return convertGeojsonMultiPointToMultiPoint(geojsonGeometry);\n    }\n    else if (isGeojsonMultiLineString(geojsonGeometry)) {\n        return convertGeojsonMultiLineStringToMultiLineString(geojsonGeometry);\n    }\n    else if (isGeojsonMultiPolygon(geojsonGeometry)) {\n        return convertGeojsonMultiPolygonToMultiPolygon(geojsonGeometry);\n    }\n    else {\n        throw new Error('Geometry type not supported');\n    }\n}\n// Expand\nexport function expandGeojsonMultiPointToGeojsonPointArray(geojsonMultiPoint) {\n    return geojsonMultiPoint.coordinates.map((point) => {\n        return {\n            type: 'Point',\n            coordinates: point\n        };\n    });\n}\nexport function expandGeojsonMultiLineStringToGeojsonLineStringArray(geojsonMultiLineString) {\n    return geojsonMultiLineString.coordinates.map((lineString) => {\n        return {\n            type: 'LineString',\n            coordinates: lineString\n        };\n    });\n}\nexport function expandGeojsonMultiPolygonToGeojsonPolygonArray(geojsonMultiPolygon) {\n    return geojsonMultiPolygon.coordinates.map((polygon) => {\n        return {\n            type: 'Polygon',\n            coordinates: polygon\n        };\n    });\n}\nexport function expandGeojsonMultiGeometryToGeojsonGeometryArray(geojsonMultiGeometry) {\n    if (isGeojsonMultiPoint(geojsonMultiGeometry)) {\n        return expandGeojsonMultiPointToGeojsonPointArray(geojsonMultiGeometry);\n    }\n    else if (isGeojsonMultiLineString(geojsonMultiGeometry)) {\n        return expandGeojsonMultiLineStringToGeojsonLineStringArray(geojsonMultiGeometry);\n    }\n    else if (isGeojsonMultiPolygon(geojsonMultiGeometry)) {\n        return expandGeojsonMultiPolygonToGeojsonPolygonArray(geojsonMultiGeometry);\n    }\n    else {\n        throw new Error('Geometry type not supported');\n    }\n}\n// Join\nexport function joinGeojsonPointArrayToGeojsonMultiPoint(geojsonPointArray) {\n    return {\n        type: 'MultiPoint',\n        coordinates: geojsonPointArray.map((geojsonPoint) => geojsonPoint.coordinates)\n    };\n}\nexport function joinGeojsonLineStringArrayToGeojsonMultiLineString(geojsonLineStringArray) {\n    return {\n        type: 'MultiLineString',\n        coordinates: geojsonLineStringArray.map((geojsonLineString) => geojsonLineString.coordinates)\n    };\n}\nexport function joinGeojsonPolygonArrayToGeojsonMultiPolygon(geojsonPolygonArray) {\n    return {\n        type: 'MultiPolygon',\n        coordinates: geojsonPolygonArray.map((geojsonPolygon) => geojsonPolygon.coordinates)\n    };\n}\nexport function joinGeojsonGeometryArrayToGeojsonMultiGeometry(geojsonGeometryArray) {\n    if (geojsonGeometryArray.every(isGeojsonPoint)) {\n        return joinGeojsonPointArrayToGeojsonMultiPoint(geojsonGeometryArray);\n    }\n    else if (geojsonGeometryArray.every(isGeojsonLineString)) {\n        return joinGeojsonLineStringArrayToGeojsonMultiLineString(geojsonGeometryArray);\n    }\n    else if (geojsonGeometryArray.every(isGeojsonPolygon)) {\n        return joinGeojsonPolygonArrayToGeojsonMultiPolygon(geojsonGeometryArray);\n    }\n    else {\n        throw new Error('Geometry type not supported');\n    }\n}\n// Convert to SVG\nexport function convertGeojsonToSvg(geometry) {\n    if (geometry.type === 'Point') {\n        return {\n            type: 'circle',\n            coordinates: geometry.coordinates\n        };\n    }\n    else if (geometry.type === 'LineString') {\n        return {\n            type: 'polyline',\n            coordinates: geometry.coordinates\n        };\n    }\n    else if (geometry.type === 'Polygon') {\n        return {\n            type: 'polygon',\n            coordinates: geometry.coordinates[0]\n        };\n    }\n    else {\n        throw new Error(`Unsupported GeoJSON geometry`); // MultiPolygons not supported in SVG\n    }\n}\n// Wrap\nexport function geometryToFeature(geometry, properties) {\n    return {\n        type: 'Feature',\n        properties: properties ? properties : {},\n        geometry: geometry\n    };\n}\nexport function featuresToFeatureCollection(features) {\n    if (!Array.isArray(features)) {\n        features = [features];\n    }\n    return {\n        type: 'FeatureCollection',\n        features: features\n    };\n}\nexport function geometriesToFeatureCollection(geometries, properties) {\n    return {\n        type: 'FeatureCollection',\n        features: geometries.map((geometry, i) => properties\n            ? geometryToFeature(geometry, properties[i])\n            : geometryToFeature(geometry))\n    };\n}\nexport function featureToGeometry(feature) {\n    return feature.geometry;\n}\nexport function featureCollectionToGeometries(featureCollection) {\n    return featureCollection.features.map(featureToGeometry);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1785, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1790, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@allmaps/stdlib/dist/bbox.js"],"sourcesContent":["import { isGeojsonGeometry, convertGeojsonGeometryToGeometry } from './geojson.js';\nimport { isPoint, isPolygon, distance } from './geometry.js';\n// Compute\nexport function computeMinMax(values) {\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n    for (const value of values) {\n        if (min === undefined) {\n            if (value >= value)\n                min = max = value;\n        }\n        else {\n            if (min > value)\n                min = value;\n            if (max < value)\n                max = value;\n        }\n    }\n    return [min, max];\n}\n// Note: bbox order is minX, minY, maxX, maxY\nexport function computeBbox(points) {\n    if (isPoint(points)) {\n        points = [points];\n    }\n    if (isPolygon(points)) {\n        points = points.flat();\n    }\n    if (isGeojsonGeometry(points)) {\n        return computeBbox(convertGeojsonGeometryToGeometry(points));\n    }\n    // TODO: do this without making two new arrays\n    const xs = [];\n    const ys = [];\n    for (const point of points) {\n        xs.push(point[0]);\n        ys.push(point[1]);\n    }\n    const [minX, maxX] = computeMinMax(xs);\n    const [minY, maxY] = computeMinMax(ys);\n    return [minX, minY, maxX, maxY];\n}\nexport function combineBboxes(bbox0, bbox1) {\n    return [\n        Math.min(bbox0[0], bbox1[0]),\n        Math.min(bbox0[1], bbox1[1]),\n        Math.max(bbox0[2], bbox1[2]),\n        Math.max(bbox0[3], bbox1[3])\n    ];\n}\nexport function isOverlapping(bbox0, bbox1) {\n    const isOverlappingInX = bbox0[2] >= bbox1[0] && bbox1[2] >= bbox0[0];\n    const isOverlappingInY = bbox0[3] >= bbox1[1] && bbox1[3] >= bbox0[1];\n    return isOverlappingInX && isOverlappingInY;\n}\nexport function pointInBbox(point, bbox) {\n    return isOverlapping([point[0], point[1], point[0], point[1]], bbox);\n}\n// Transform\n// Returns a rectangle with four points, starting from lower left and going anti-clockwise.\nexport function bboxToRectangle(bbox) {\n    return [\n        [bbox[0], bbox[1]],\n        [bbox[2], bbox[1]],\n        [bbox[2], bbox[3]],\n        [bbox[0], bbox[3]]\n    ];\n}\nexport function bboxToPolygon(bbox) {\n    return [bboxToRectangle(bbox)];\n}\nexport function bboxToLine(bbox) {\n    return [\n        [bbox[0], bbox[1]],\n        [bbox[2], bbox[3]]\n    ];\n}\nexport function bboxToPoint(bbox) {\n    return [bbox[0], bbox[1]];\n}\nexport function bboxToDiameter(bbox) {\n    return distance(bboxToLine(bbox));\n}\nexport function geometryToDiameter(geometry) {\n    return distance(bboxToLine(computeBbox(geometry)));\n}\nexport function bboxToCenter(bbox) {\n    return [(bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2];\n}\nexport function bboxToSize(bbox) {\n    return [bbox[2] - bbox[0], bbox[3] - bbox[1]];\n}\n// Approximate results, for rectangles coming from bboxes.\n// A more precise result would require a minimal-covering-rectangle algorithm\n// Or computing and comparing rectangle surfaces\nexport function rectangleToSize(rectangle) {\n    return [\n        0.5 *\n            (distance(rectangle[0], rectangle[1]) +\n                distance(rectangle[2], rectangle[3])),\n        0.5 *\n            (distance(rectangle[1], rectangle[2]) +\n                distance(rectangle[3], rectangle[0]))\n    ];\n}\n// Scales\nexport function sizesToScale(size0, size1, fit) {\n    if (!fit) {\n        return Math.sqrt((size0[0] * size0[1]) / (size1[0] * size1[1]));\n    }\n    else if (fit === 'contain') {\n        return size1[0] >= size1[1] ? size0[0] / size1[0] : size0[1] / size1[1];\n    }\n    else {\n        return size1[0] >= size1[1] ? size0[1] / size1[1] : size0[0] / size1[0];\n    }\n}\nexport function bboxesToScale(bbox0, bbox1) {\n    return sizesToScale(bboxToSize(bbox0), bboxToSize(bbox1));\n}\nexport function rectanglesToScale(rectangle0, rectangle1) {\n    return sizesToScale(rectangleToSize(rectangle0), rectangleToSize(rectangle1));\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1961, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1966, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@allmaps/stdlib/dist/cache.js"],"sourcesContent":["export function getPropertyFromCacheOrComputation(cache, key, computation, useCache = true) {\n    if (cache.has(key) && useCache) {\n        return cache.get(key);\n    }\n    else {\n        const result = computation();\n        cache.set(key, result);\n        return result;\n    }\n}\nexport function getPropertyFromDoubleCacheOrComputation(cache, key0, key1, computation, useCache = true) {\n    if (cache.get(key0)?.has(key1) && useCache) {\n        return cache.get(key0)?.get(key1);\n    }\n    else {\n        const result = computation();\n        if (!cache.get(key0)) {\n            cache.set(key0, new Map());\n        }\n        cache.get(key0)?.set(key1, result);\n        return result;\n    }\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,kCAAkC,KAAK,EAAE,GAAG,EAAE,WAAW,EAAE,WAAW,IAAI;IACtF,IAAI,MAAM,GAAG,CAAC,QAAQ,UAAU;QAC5B,OAAO,MAAM,GAAG,CAAC;IACrB,OACK;QACD,MAAM,SAAS;QACf,MAAM,GAAG,CAAC,KAAK;QACf,OAAO;IACX;AACJ;AACO,SAAS,wCAAwC,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,WAAW,EAAE,WAAW,IAAI;IACnG,IAAI,MAAM,GAAG,CAAC,OAAO,IAAI,SAAS,UAAU;QACxC,OAAO,MAAM,GAAG,CAAC,OAAO,IAAI;IAChC,OACK;QACD,MAAM,SAAS;QACf,IAAI,CAAC,MAAM,GAAG,CAAC,OAAO;YAClB,MAAM,GAAG,CAAC,MAAM,IAAI;QACxB;QACA,MAAM,GAAG,CAAC,OAAO,IAAI,MAAM;QAC3B,OAAO;IACX;AACJ"}},
    {"offset": {"line": 1991, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1996, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@allmaps/stdlib/dist/color.js"],"sourcesContent":["/**\n * Convert RBG to hex\n * @param {[number, number, number]} [r, g, b] - rgb, e.g. [0, 51, 255]\n * @returns {Color} hex string, e.g. '#0033ff'\n */\nexport function rgbToHex([r, g, b]) {\n    return ('#' +\n        [r, g, b]\n            .map((x) => {\n            const hex = x.toString(16);\n            return hex.length === 1 ? '0' + hex : hex;\n        })\n            .join(''));\n}\n/**\n * Convert hex to RGB\n * @param {string} hex - hex string, e.g. '#0033ff'\n * @returns {Color} RGB, e.g. [0, 51, 255]\n */\nexport function hexToRgb(hex) {\n    const bigint = parseInt(hex.replace(/^#/, ''), 16);\n    const r = (bigint >> 16) & 255;\n    const g = (bigint >> 8) & 255;\n    const b = bigint & 255;\n    return [r, g, b];\n}\n/**\n * Convert hex to fractional RGB\n * @param {string} hex - hex string, e.g. '#0033ff'\n * @returns {Color} Fractional RGB, e.g. [0, 0.2, 1]\n */\nexport function hexToFractionalRgb(hex) {\n    return hexToRgb(hex).map((c) => c / 255);\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;AACM,SAAS,SAAS,CAAC,GAAG,GAAG,EAAE;IAC9B,OAAQ,MACJ;QAAC;QAAG;QAAG;KAAE,CACJ,GAAG,CAAC,CAAC;QACN,MAAM,MAAM,EAAE,QAAQ,CAAC;QACvB,OAAO,IAAI,MAAM,KAAK,IAAI,MAAM,MAAM;IAC1C,GACK,IAAI,CAAC;AAClB;AAMO,SAAS,SAAS,GAAG;IACxB,MAAM,SAAS,SAAS,IAAI,OAAO,CAAC,MAAM,KAAK;IAC/C,MAAM,IAAI,AAAC,UAAU,KAAM;IAC3B,MAAM,IAAI,AAAC,UAAU,IAAK;IAC1B,MAAM,IAAI,SAAS;IACnB,OAAO;QAAC;QAAG;QAAG;KAAE;AACpB;AAMO,SAAS,mBAAmB,GAAG;IAClC,OAAO,SAAS,KAAK,GAAG,CAAC,CAAC,IAAM,IAAI;AACxC"}},
    {"offset": {"line": 2029, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2034, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@allmaps/stdlib/dist/main.js"],"sourcesContent":["export function equalArray(arr1, arr2) {\n    if (!arr1 || !arr2) {\n        return false;\n    }\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function equalSet(set1, set2) {\n    if (!set1 || !set2) {\n        return false;\n    }\n    if (set1.size !== set2.size) {\n        return false;\n    }\n    return [...set1].every((x) => set2.has(x));\n}\nexport function maxOfNumberOrUndefined(number1, number2) {\n    if (number1 !== undefined && number2 !== undefined) {\n        return Math.max(number1, number2);\n    }\n    else if (number1 !== undefined) {\n        return number1;\n    }\n    else if (number2 !== undefined) {\n        return number2;\n    }\n}\nexport function isValidHttpUrl(string) {\n    let url;\n    try {\n        url = new URL(string);\n    }\n    catch (_) {\n        return false;\n    }\n    return url.protocol === 'http:' || url.protocol === 'https:';\n}\n"],"names":[],"mappings":";;;;;;AAAO,SAAS,WAAW,IAAI,EAAE,IAAI;IACjC,IAAI,CAAC,QAAQ,CAAC,MAAM;QAChB,OAAO;IACX;IACA,IAAI,KAAK,MAAM,KAAK,KAAK,MAAM,EAAE;QAC7B,OAAO;IACX;IACA,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;QAClC,IAAI,IAAI,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,EAAE;YACrB,OAAO;QACX;IACJ;IACA,OAAO;AACX;AACO,SAAS,SAAS,IAAI,EAAE,IAAI;IAC/B,IAAI,CAAC,QAAQ,CAAC,MAAM;QAChB,OAAO;IACX;IACA,IAAI,KAAK,IAAI,KAAK,KAAK,IAAI,EAAE;QACzB,OAAO;IACX;IACA,OAAO;WAAI;KAAK,CAAC,KAAK,CAAC,CAAC,IAAM,KAAK,GAAG,CAAC;AAC3C;AACO,SAAS,uBAAuB,OAAO,EAAE,OAAO;IACnD,IAAI,YAAY,aAAa,YAAY,WAAW;QAChD,OAAO,KAAK,GAAG,CAAC,SAAS;IAC7B,OACK,IAAI,YAAY,WAAW;QAC5B,OAAO;IACX,OACK,IAAI,YAAY,WAAW;QAC5B,OAAO;IACX;AACJ;AACO,SAAS,eAAe,MAAM;IACjC,IAAI;IACJ,IAAI;QACA,MAAM,IAAI,IAAI;IAClB,EACA,OAAO,GAAG;QACN,OAAO;IACX;IACA,OAAO,IAAI,QAAQ,KAAK,WAAW,IAAI,QAAQ,KAAK;AACxD"}},
    {"offset": {"line": 2083, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2088, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@allmaps/stdlib/dist/masks.js"],"sourcesContent":["// TODO: the fullResourceMask is available directly in WarpedMap class!\n// This also means this function can be removed from stdlib.\nexport function getFullResourceMask(imageWidth, imageHeight) {\n    return [\n        [0, 0],\n        [imageWidth, 0],\n        [imageWidth, imageHeight],\n        [0, imageHeight]\n    ];\n}\n"],"names":[],"mappings":"AAAA,uEAAuE;AACvE,4DAA4D;;;;AACrD,SAAS,oBAAoB,UAAU,EAAE,WAAW;IACvD,OAAO;QACH;YAAC;YAAG;SAAE;QACN;YAAC;YAAY;SAAE;QACf;YAAC;YAAY;SAAY;QACzB;YAAC;YAAG;SAAY;KACnB;AACL"}},
    {"offset": {"line": 2113, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2118, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@allmaps/stdlib/dist/svg.js"],"sourcesContent":["import { parse } from 'svg-parser';\n// Assert\n// TODO!\n// Read from string\nexport function* stringToSvgGeometriesGenerator(svg) {\n    function* helper(node) {\n        if ('children' in node) {\n            for (const childNode of node.children) {\n                if (typeof childNode !== 'string') {\n                    yield* helper(childNode);\n                }\n            }\n        }\n        yield node;\n    }\n    const parsedSvg = parse(svg);\n    for (const node of helper(parsedSvg)) {\n        if ('tagName' in node) {\n            if (node.tagName !== 'svg' && node.tagName !== 'g') {\n                const geometry = getNodeSvgGeometry(node);\n                if (geometry) {\n                    yield geometry;\n                }\n            }\n        }\n    }\n}\nfunction getNodeSvgGeometry(node) {\n    const tag = node?.tagName?.toLowerCase();\n    if (tag === 'circle') {\n        return {\n            type: 'circle',\n            coordinates: [\n                getNodeNumberProperty(node, 'cx'),\n                getNodeNumberProperty(node, 'cy')\n            ]\n        };\n    }\n    else if (tag === 'line') {\n        return {\n            type: 'line',\n            coordinates: [\n                [getNodeNumberProperty(node, 'x1'), getNodeNumberProperty(node, 'y1')],\n                [getNodeNumberProperty(node, 'x2'), getNodeNumberProperty(node, 'y2')]\n            ]\n        };\n    }\n    else if (tag === 'polyline') {\n        return {\n            type: 'polyline',\n            coordinates: getNodePoints(node)\n        };\n    }\n    else if (tag === 'polygon') {\n        return {\n            type: 'polygon',\n            coordinates: getNodePoints(node)\n        };\n    }\n    else if (tag === 'rect') {\n        return {\n            type: 'rect',\n            coordinates: [\n                [getNodeNumberProperty(node, 'x'), getNodeNumberProperty(node, 'y')],\n                [\n                    getNodeNumberProperty(node, 'x') +\n                        getNodeNumberProperty(node, 'width'),\n                    getNodeNumberProperty(node, 'y')\n                ],\n                [\n                    getNodeNumberProperty(node, 'x') +\n                        getNodeNumberProperty(node, 'width'),\n                    getNodeNumberProperty(node, 'y') +\n                        getNodeNumberProperty(node, 'height')\n                ],\n                [\n                    getNodeNumberProperty(node, 'x'),\n                    getNodeNumberProperty(node, 'y') +\n                        getNodeNumberProperty(node, 'height')\n                ],\n                [getNodeNumberProperty(node, 'x'), getNodeNumberProperty(node, 'y')]\n            ]\n        };\n    }\n    else {\n        throw new Error(`Unsupported SVG element: ${tag}`);\n    }\n}\nfunction getNodeNumberProperty(node, prop) {\n    const value = node?.properties?.[prop];\n    return Number(value) || 0;\n}\nfunction getNodePoints(node) {\n    const points = node?.properties?.points;\n    if (points) {\n        return String(points)\n            .trim()\n            .split(/\\s+/)\n            .map((coordStr) => {\n            const coord = coordStr.split(',').map((numberStr) => Number(numberStr));\n            return [coord[0], coord[1]];\n        });\n    }\n    return [];\n}\nfunction pointsToString(coordinates) {\n    return coordinates.map((coordinate) => coordinate.join(',')).join(' ');\n}\n// Convert to String\nexport function svgGeometriesToSvgString(geometries) {\n    return `<svg xmlns=\"http://www.w3.org/2000/svg\">\n  ${geometries.map(svgGeometryToString).join('\\n')}\n</svg>`;\n}\nfunction svgGeometryToString(geometry) {\n    if (geometry.type === 'circle') {\n        return elementToString('circle', {\n            ...geometry.attributes,\n            cx: geometry.coordinates[0],\n            cy: geometry.coordinates[1]\n        });\n    }\n    else if (geometry.type === 'line') {\n        return elementToString('line', {\n            ...geometry.attributes,\n            x1: geometry.coordinates[0][0],\n            y1: geometry.coordinates[0][1],\n            x2: geometry.coordinates[1][0],\n            y2: geometry.coordinates[1][1]\n        });\n    }\n    else if (geometry.type === 'polyline') {\n        return elementToString('polyline', {\n            ...geometry.attributes,\n            points: pointsToString(geometry.coordinates)\n        });\n    }\n    else if (geometry.type === 'polygon') {\n        return elementToString('polygon', {\n            ...geometry.attributes,\n            points: pointsToString(geometry.coordinates)\n        });\n    }\n    else if (geometry.type === 'rect') {\n        return elementToString('rect', {\n            ...geometry.attributes,\n            x: geometry.coordinates[0][0],\n            y: geometry.coordinates[0][1],\n            width: geometry.coordinates[1][0] - geometry.coordinates[0][0],\n            height: geometry.coordinates[2][1] - geometry.coordinates[0][1]\n        });\n    }\n    else {\n        throw new Error('Unknown SVG element');\n    }\n}\nfunction elementToString(tag, attributes) {\n    const attributeStrings = Object.entries(attributes).map(([key, value]) => `${key}=\"${value}\"`);\n    return `<${tag} ${attributeStrings.join(' ')} />`;\n}\nexport function mapToResourceMaskSvgPolygon(map) {\n    return {\n        type: 'polygon',\n        attributes: {\n            'data-image-id': encodeURIComponent(map.resource.id)\n        },\n        coordinates: map.resourceMask\n    };\n}\n// Convert to geojson\nexport function convertSvgToGeojson(geometry) {\n    if (geometry.type === 'circle') {\n        return {\n            type: 'Point',\n            coordinates: geometry.coordinates\n        };\n    }\n    else if (geometry.type === 'line') {\n        return {\n            type: 'LineString',\n            coordinates: geometry.coordinates\n        };\n    }\n    else if (geometry.type === 'polyline') {\n        return {\n            type: 'LineString',\n            coordinates: geometry.coordinates\n        };\n    }\n    else if (geometry.type === 'rect') {\n        return {\n            type: 'Polygon',\n            coordinates: [geometry.coordinates]\n        };\n    }\n    else if (geometry.type === 'polygon') {\n        return {\n            type: 'Polygon',\n            coordinates: [geometry.coordinates]\n        };\n    }\n    else {\n        throw new Error(`Unsupported SVG geometry`);\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2323, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2328, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@allmaps/stdlib/dist/projection.js"],"sourcesContent":["import { degreesToRadians } from './geometry.js';\n// From: https://gis.stackexchange.com/questions/156035/calculating-mercator-coordinates-from-lat-lon\nexport function lonLatToWebMecator([lon, lat]) {\n    const rMajor = 6378137.0;\n    const x = rMajor * degreesToRadians(lon);\n    const scale = x / lon;\n    const y = (180.0 / Math.PI) *\n        Math.log(Math.tan(Math.PI / 4.0 + (lat * (Math.PI / 180.0)) / 2.0)) *\n        scale;\n    return [x, y];\n}\n// From: https://gist.github.com/mudpuddle/6115083\nexport function webMercatorToLonLat([x, y]) {\n    const rMajor = 6378137.0;\n    const shift = Math.PI * rMajor;\n    const lon = (x / shift) * 180.0;\n    let lat = (y / shift) * 180.0;\n    lat =\n        (180 / Math.PI) *\n            (2 * Math.atan(Math.exp((lat * Math.PI) / 180.0)) - Math.PI / 2.0);\n    return [lon, lat];\n}\n"],"names":[],"mappings":";;;;;;;AAEO,SAAS,mBAAmB,CAAC,KAAK,IAAI;IACzC,MAAM,SAAS;IACf,MAAM,IAAI,SAAS,CAAA,GAAA,uJAAA,CAAA,mBAAgB,AAAD,EAAE;IACpC,MAAM,QAAQ,IAAI;IAClB,MAAM,IAAI,AAAC,QAAQ,KAAK,EAAE,GACtB,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,KAAK,EAAE,GAAG,MAAM,AAAC,MAAM,CAAC,KAAK,EAAE,GAAG,KAAK,IAAK,QAC9D;IACJ,OAAO;QAAC;QAAG;KAAE;AACjB;AAEO,SAAS,oBAAoB,CAAC,GAAG,EAAE;IACtC,MAAM,SAAS;IACf,MAAM,QAAQ,KAAK,EAAE,GAAG;IACxB,MAAM,MAAM,AAAC,IAAI,QAAS;IAC1B,IAAI,MAAM,AAAC,IAAI,QAAS;IACxB,MACI,AAAC,MAAM,KAAK,EAAE,GACV,CAAC,IAAI,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,AAAC,MAAM,KAAK,EAAE,GAAI,UAAU,KAAK,EAAE,GAAG,GAAG;IACzE,OAAO;QAAC;QAAK;KAAI;AACrB"}},
    {"offset": {"line": 2356, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2361, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 2374, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2399, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@placemarkio/geojson-rewind/lib/index.ts"],"sourcesContent":["import {\n  Feature as IFeature,\n  Geometry,\n  FeatureCollection,\n  Position,\n} from 'geojson';\n\ntype Feature = IFeature<Geometry | null>;\n\n/**\n * Winding order. By default, this uses the RFC7946 order,\n * which is what is in the GeoJSON standard.\n *\n * You can also choose to wind in the d3 order.\n */\nexport type Winding = 'RFC7946' | 'd3';\n\nexport function rewindGeometry(geometry: Geometry, outer = false): Geometry {\n  switch (geometry.type) {\n    case 'Polygon': {\n      if (!geometry.coordinates) return geometry;\n      return {\n        ...geometry,\n        coordinates: rewindRings(geometry.coordinates, outer),\n      };\n    }\n    case 'MultiPolygon': {\n      if (!geometry.coordinates) return geometry;\n      return {\n        ...geometry,\n        coordinates: geometry.coordinates.map((polygon) =>\n          rewindRings(polygon, outer)\n        ),\n      };\n    }\n    case 'GeometryCollection': {\n      return {\n        ...geometry,\n        geometries: geometry.geometries.map((geometry) => {\n          return rewindGeometry(geometry, outer);\n        }),\n      };\n    }\n    default: {\n      return geometry;\n    }\n  }\n}\n\nfunction rewindRings(rings: Position[][], outer: boolean): Position[][] {\n  if (rings.length === 0) return rings;\n\n  const rewound: Position[][] = [];\n\n  for (let i = 0; i < rings.length; i++) {\n    rewound.push(rewindRing(rings[i], i === 0 ? outer : !outer));\n  }\n\n  return rewound;\n}\n\n/**\n * Compute the area of a ring to decide whether to wind it\n * clockwise or not.\n */\nfunction rewindRing(ring: Position[], dir: boolean): Position[] {\n  let area = 0;\n  let err = 0;\n  for (let i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n    const k = (ring[i][0] - ring[j][0]) * (ring[j][1] + ring[i][1]);\n    const m = area + k;\n    err += Math.abs(area) >= Math.abs(k) ? area - m + k : k - m + area;\n    area = m;\n  }\n  if (area + err >= 0 !== !!dir) return ring.slice().reverse();\n  return ring;\n}\n\n/**\n * # Wind the rings of polygons and multipolygons.\n *\n * This creates a copy of the input.\n *\n * - outer as false is the default, which is the GeoJSON RFC way.\n * - outer as true is for d3-geo.\n */\nexport function rewindFeature(\n  feature: Feature,\n  winding: Winding = 'RFC7946'\n): Feature {\n  const geometry = feature.geometry;\n  if (!geometry) return feature;\n  const geometryRewound = rewindGeometry(geometry, winding === 'd3');\n  if (geometryRewound === geometry) {\n    return feature;\n  }\n\n  return {\n    ...feature,\n    geometry: geometryRewound,\n  };\n}\n\nexport function rewindFeatureCollection(\n  featureCollection: FeatureCollection,\n  outer: Winding = 'RFC7946'\n) {\n  return {\n    ...featureCollection,\n    features: featureCollection.features.map((feature) =>\n      rewindFeature(feature, outer)\n    ),\n  };\n}\n"],"names":[],"mappings":";;;;;SAiBgB,eAAe,QAAkB,EAAE,QAAQ,KAAK;IAC9D,OAAQ,SAAS,IAAI;QACnB,KAAK;YAAW;gBACd,IAAI,CAAC,SAAS,WAAW,EAAE,OAAO;gBAClC,OAAO;oBACL,GAAG,QAAQ;oBACX,aAAa,YAAY,SAAS,WAAW,EAAE;;YAElD;QACD,KAAK;YAAgB;gBACnB,IAAI,CAAC,SAAS,WAAW,EAAE,OAAO;gBAClC,OAAO;oBACL,GAAG,QAAQ;oBACX,aAAa,SAAS,WAAW,CAAC,GAAG,CAAC,CAAC,UACrC,YAAY,SAAS;;YAG1B;QACD,KAAK;YAAsB;gBACzB,OAAO;oBACL,GAAG,QAAQ;oBACX,YAAY,SAAS,UAAU,CAAC,GAAG,CAAC,CAAC;wBACnC,OAAO,eAAe,UAAU;oBAClC;;YAEH;QACD;YAAS;gBACP,OAAO;YACR;IACF;AACH;AAEA,SAAS,YAAY,KAAmB,EAAE,KAAc;IACtD,IAAI,MAAM,MAAM,KAAK,GAAG,OAAO;IAE/B,MAAM,UAAwB,EAAE;IAEhC,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,IAAK;QACrC,QAAQ,IAAI,CAAC,WAAW,KAAK,CAAC,EAAE,EAAE,MAAM,IAAI,QAAQ,CAAC;IACtD;IAED,OAAO;AACT;AAEA;;;CAGG,GACH,SAAS,WAAW,IAAgB,EAAE,GAAY;IAChD,IAAI,OAAO;IACX,IAAI,MAAM;IACV,IAAK,IAAI,IAAI,GAAG,MAAM,KAAK,MAAM,EAAE,IAAI,MAAM,GAAG,IAAI,KAAK,IAAI,IAAK;QAChE,MAAM,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,EAAE,IAAA,CAAK,IAAI,CAAC,EAAE,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE,CAAC,EAAE;QAC9D,MAAM,IAAI,OAAO;QACjB,OAAO,KAAK,GAAG,CAAC,SAAS,KAAK,GAAG,CAAC,KAAK,OAAO,IAAI,IAAI,IAAI,IAAI;QAC9D,OAAO;IACR;IACD,IAAI,OAAO,OAAO,MAAM,CAAC,CAAC,KAAK,OAAO,KAAK,KAAK,GAAG,OAAO;IAC1D,OAAO;AACT;AAEA;;;;;;;CAOG,YACa,cACd,OAAgB,EAChB,UAAmB,SAAS;IAE5B,MAAM,WAAW,QAAQ,QAAQ;IACjC,IAAI,CAAC,UAAU,OAAO;IACtB,MAAM,kBAAkB,eAAe,UAAU,YAAY;IAC7D,IAAI,oBAAoB,UAAU;QAChC,OAAO;IACR;IAED,OAAO;QACL,GAAG,OAAO;QACV,UAAU;;AAEd;SAEgB,wBACd,iBAAoC,EACpC,QAAiB,SAAS;IAE1B,OAAO;QACL,GAAG,iBAAiB;QACpB,UAAU,kBAAkB,QAAQ,CAAC,GAAG,CAAC,CAAC,UACxC,cAAc,SAAS;;AAG7B"}},
    {"offset": {"line": 2487, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2492, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/svg-parser/node_modules/locate-character/dist/locate-character.es.js","/turbopack/[project]/node_modules/svg-parser/src/index.js"],"sourcesContent":["function getLocator(source, options) {\n    if (options === void 0) { options = {}; }\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n        var end = start + line.length + 1;\n        var range = { start: start, end: end, line: i };\n        start = end;\n        return range;\n    });\n    var i = 0;\n    function rangeContains(range, index) {\n        return range.start <= index && index < range.end;\n    }\n    function getLocation(range, index) {\n        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n    }\n    function locate(search, startIndex) {\n        if (typeof search === 'string') {\n            search = source.indexOf(search, startIndex || 0);\n        }\n        var range = lineRanges[i];\n        var d = search >= range.end ? 1 : -1;\n        while (range) {\n            if (rangeContains(range, search))\n                return getLocation(range, search);\n            i += d;\n            range = lineRanges[i];\n        }\n    }\n    ;\n    return locate;\n}\nfunction locate(source, search, options) {\n    if (typeof options === 'number') {\n        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n    return getLocator(source, options)(search, options && options.startIndex);\n}\n\nexport { getLocator, locate };","import { locate } from 'locate-character';\n\nconst validNameCharacters = /[a-zA-Z0-9:_-]/;\nconst whitespace = /[\\s\\t\\r\\n]/;\nconst quotemark = /['\"]/;\n\nfunction repeat(str, i) {\n\tlet result = '';\n\twhile (i--) result += str;\n\treturn result;\n}\n\nexport function parse(source) {\n\tlet header = '';\n\tlet stack = [];\n\n\tlet state = metadata;\n\tlet currentElement = null;\n\tlet root = null;\n\n\tfunction error(message) {\n\t\tconst { line, column } = locate(source, i);\n\t\tconst before = source.slice(0, i);\n\t\tconst beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n\t\tconst after = source.slice(i);\n\t\tconst afterLine = /.*(\\n|$)/.exec(after)[0];\n\n\t\tconst snippet = `${beforeLine}${afterLine}\\n${repeat(' ', beforeLine.length)}^`;\n\n\t\tthrow new Error(\n\t\t\t`${message} (${line}:${column}). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues – thanks!\\n\\n${snippet}`\n\t\t);\n\t}\n\n\tfunction metadata() {\n\t\twhile ((i < source.length && source[i] !== '<') || !validNameCharacters.test(source[i + 1])) {\n\t\t\theader += source[i++];\n\t\t}\n\n\t\treturn neutral();\n\t}\n\n\tfunction neutral() {\n\t\tlet text = '';\n\t\twhile (i < source.length && source[i] !== '<') text += source[i++];\n\n\t\tif (/\\S/.test(text)) {\n\t\t\tcurrentElement.children.push({ type: 'text', value: text });\n\t\t}\n\n\t\tif (source[i] === '<') {\n\t\t\treturn tag;\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction tag() {\n\t\tconst char = source[i];\n\n\t\tif (char === '?') return neutral; // <?xml...\n\n\t\tif (char === '!') {\n\t\t\tif (source.slice(i + 1, i + 3) === '--') return comment;\n\t\t\tif (source.slice(i + 1, i + 8) === '[CDATA[') return cdata;\n\t\t\tif (/doctype/i.test(source.slice(i + 1, i + 8))) return neutral;\n\t\t}\n\n\t\tif (char === '/') return closingTag;\n\n\t\tconst tagName = getName();\n\n\t\tconst element = {\n\t\t\ttype: 'element',\n\t\t\ttagName,\n\t\t\tproperties: {},\n\t\t\tchildren: []\n\t\t};\n\n\t\tif (currentElement) {\n\t\t\tcurrentElement.children.push(element);\n\t\t} else {\n\t\t\troot = element;\n\t\t}\n\n\t\tlet attribute;\n\t\twhile (i < source.length && (attribute = getAttribute())) {\n\t\t\telement.properties[attribute.name] = attribute.value;\n\t\t}\n\n\t\tlet selfClosing = false;\n\n\t\tif (source[i] === '/') {\n\t\t\ti += 1;\n\t\t\tselfClosing = true;\n\t\t}\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tif (!selfClosing) {\n\t\t\tcurrentElement = element;\n\t\t\tstack.push(element);\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction comment() {\n\t\tconst index = source.indexOf('-->', i);\n\t\tif (!~index) error('expected -->');\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction cdata() {\n\t\tconst index = source.indexOf(']]>', i);\n\t\tif (!~index) error('expected ]]>');\n\n\t\tcurrentElement.children.push(source.slice(i + 7, index));\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction closingTag() {\n\t\tconst tagName = getName();\n\n\t\tif (!tagName) error('Expected tag name');\n\n\t\tif (tagName !== currentElement.tagName) {\n\t\t\terror(`Expected closing tag </${tagName}> to match opening tag <${currentElement.tagName}>`);\n\t\t}\n\n\t\tallowSpaces();\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tstack.pop();\n\t\tcurrentElement = stack[stack.length - 1];\n\n\t\treturn neutral;\n\t}\n\n\tfunction getName() {\n\t\tlet name = '';\n\t\twhile (i < source.length && validNameCharacters.test(source[i])) name += source[i++];\n\n\t\treturn name;\n\t}\n\n\tfunction getAttribute() {\n\t\tif (!whitespace.test(source[i])) return null;\n\t\tallowSpaces();\n\n\t\tconst name = getName();\n\t\tif (!name) return null;\n\n\t\tlet value = true;\n\n\t\tallowSpaces();\n\t\tif (source[i] === '=') {\n\t\t\ti += 1;\n\t\t\tallowSpaces();\n\n\t\t\tvalue = getAttributeValue();\n\t\t\tif (!isNaN(value) && value.trim() !== '') value = +value; // TODO whitelist numeric attributes?\n\t\t}\n\n\t\treturn { name, value };\n\t}\n\n\tfunction getAttributeValue() {\n\t\treturn quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n\t}\n\n\tfunction getUnquotedAttributeValue() {\n\t\tlet value = '';\n\t\tdo {\n\t\t\tconst char = source[i];\n\t\t\tif (char === ' ' || char === '>' || char === '/') {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvalue += char;\n\t\t\ti += 1;\n\t\t} while (i < source.length);\n\n\t\treturn value;\n\t}\n\n\tfunction getQuotedAttributeValue() {\n\t\tconst quotemark = source[i++];\n\n\t\tlet value = '';\n\t\tlet escaped = false;\n\n\t\twhile (i < source.length) {\n\t\t\tconst char = source[i++];\n\t\t\tif (char === quotemark && !escaped) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (char === '\\\\' && !escaped) {\n\t\t\t\tescaped = true;\n\t\t\t}\n\n\t\t\tvalue += escaped ? `\\\\${char}` : char;\n\t\t\tescaped = false;\n\t\t}\n\t}\n\n\tfunction allowSpaces() {\n\t\twhile (i < source.length && whitespace.test(source[i])) i += 1;\n\t}\n\n\tlet i = metadata.length;\n\twhile (i < source.length) {\n\t\tif (!state) error('Unexpected character');\n\t\tstate = state();\n\t\ti += 1;\n\t}\n\n\tif (state !== neutral) {\n\t\terror('Unexpected end of input');\n\t}\n\n\tif (root.tagName === 'svg') root.metadata = header;\n\treturn {\n\t\ttype: 'root',\n\t\tchildren: [root]\n\t};\n}\n"],"names":["const","let"],"mappings":";;;AAAA,SAAS,WAAW,MAAM,EAAE,OAAO;IAC/B,IAAI,YAAY,KAAK,GAAG;QAAE,UAAU,CAAA;IAAG;IACvC,IAAI,aAAa,QAAQ,UAAU,IAAI;IACvC,IAAI,eAAe,QAAQ,YAAY,IAAI;IAC3C,IAAI,gBAAgB,OAAO,KAAK,CAAC;IACjC,IAAI,QAAQ;IACZ,IAAI,aAAa,cAAc,GAAG,CAAC,SAAU,IAAI,EAAE,CAAC;QAChD,IAAI,MAAM,QAAQ,KAAK,MAAM,GAAG;QAChC,IAAI,QAAQ;YAAE,OAAO;YAAO,KAAK;YAAK,MAAM;QAAC;QAC7C,QAAQ;QACR,OAAO;IACf;IACI,IAAI,IAAI;IACR,SAAS,cAAc,KAAK,EAAE,KAAK;QAC/B,OAAO,MAAM,KAAK,IAAI,SAAS,QAAQ,MAAM,GAAG;IACxD;IACI,SAAS,YAAY,KAAK,EAAE,KAAK;QAC7B,OAAO;YAAE,MAAM,aAAa,MAAM,IAAI;YAAE,QAAQ,eAAe,QAAQ,MAAM,KAAK;YAAE,WAAW;QAAK;IAC5G;IACI,SAAS,OAAO,MAAM,EAAE,UAAU;QAC9B,IAAI,OAAO,WAAW,UAAU;YAC5B,SAAS,OAAO,OAAO,CAAC,QAAQ,cAAc;QAC1D;QACQ,IAAI,QAAQ,UAAU,CAAC,EAAE;QACzB,IAAI,IAAI,UAAU,MAAM,GAAG,GAAG,IAAI,CAAC;QACnC,MAAO,MAAO;YACV,IAAI,cAAc,OAAO,SACrB,OAAO,YAAY,OAAO;YAC9B,KAAK;YACL,QAAQ,UAAU,CAAC,EAAE;QACjC;IACA;IAEI,OAAO;AACX;AACA,SAAS,OAAO,MAAM,EAAE,MAAM,EAAE,OAAO;IACnC,IAAI,OAAO,YAAY,UAAU;QAC7B,MAAM,IAAI,MAAM;IACxB;IACI,OAAO,WAAW,QAAQ,SAAS,QAAQ,WAAW,QAAQ,UAAU;AAC5E;ACtCAA,IAAM,sBAAsB;AAC5BA,IAAM,aAAa;AACnBA,IAAM,YAAY;AAElB,SAAS,OAAO,GAAG,EAAE,CAAC;IACrBC,IAAI,SAAS;IACb,MAAO,IAAG;QAAE,UAAU;IAAG;IACzB,OAAO;AACR;AAEA,SAAgB,MAAM,MAAM;IAC3BA,IAAI,SAAS;IACbA,IAAI,QAAQ,EAAE;IAEdA,IAAI,QAAQ;IACZA,IAAI,iBAAiB;IACrBA,IAAI,OAAO;IAEX,SAAS,MAAM,OAAO;QACvB,IAAA,MAA2B,OAAO,QAAQ;QAAhC,IAAA,OAAA,IAAA,IAAA;QAAM,IAAA,SAAA,IAAA,MAAA;QACdD,IAAM,SAAS,OAAO,KAAK,CAAC,GAAG;QAC/BA,IAAM,aAAa,YAAY,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,CAAC,OAAO;QAC9DA,IAAM,QAAQ,OAAO,KAAK,CAAC;QAC3BA,IAAM,YAAY,WAAW,IAAI,CAAC,MAAM,CAAC,EAAE;QAE3CA,IAAM,UAAU,KAAG,aAAa,YAAS,OAAK,OAAO,KAAK,WAAW,MAAM,IAAC;QAE5E,MAAM,IAAI,MACN,UAAO,OAAK,OAAI,MAAI,SAAM,wJAAsJ;IAEtL;IAEC,SAAS;QACR,MAAO,AAAC,IAAI,OAAO,MAAM,IAAI,MAAM,CAAC,EAAE,KAAK,OAAQ,CAAC,oBAAoB,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,EAAG;YAC5F,UAAU,MAAM,CAAC,IAAI;QACxB;QAEE,OAAO;IACT;IAEC,SAAS;QACRC,IAAI,OAAO;QACX,MAAO,IAAI,OAAO,MAAM,IAAI,MAAM,CAAC,EAAE,KAAK,IAAG;YAAE,QAAQ,MAAM,CAAC,IAAI;QAAA;QAElE,IAAI,KAAK,IAAI,CAAC,OAAO;YACpB,eAAe,QAAQ,CAAC,IAAI,CAAC;gBAAE,MAAM;gBAAQ,OAAO;YAAI;QAC3D;QAEE,IAAI,MAAM,CAAC,EAAE,KAAK,KAAK;YACtB,OAAO;QACV;QAEE,OAAO;IACT;IAEC,SAAS;QACRD,IAAM,OAAO,MAAM,CAAC,EAAE;QAEtB,IAAI,SAAS,KAAG;YAAE,OAAO;QAAO,EAAC,WAAA;QAEjC,IAAI,SAAS,KAAK;YACjB,IAAI,OAAO,KAAK,CAAC,IAAI,GAAG,IAAI,OAAO,MAAI;gBAAE,OAAO;YAAO;YACvD,IAAI,OAAO,KAAK,CAAC,IAAI,GAAG,IAAI,OAAO,WAAS;gBAAE,OAAO;YAAK;YAC1D,IAAI,WAAW,IAAI,CAAC,OAAO,KAAK,CAAC,IAAI,GAAG,IAAI,KAAG;gBAAE,OAAO;YAAO;QAClE;QAEE,IAAI,SAAS,KAAG;YAAE,OAAO;QAAU;QAEnCA,IAAM,UAAU;QAEhBA,IAAM,UAAU;YACf,MAAM;YACT,SAAG;YACA,YAAY,CAAA;YACZ,UAAU,EAAE;QACf;QAEE,IAAI,gBAAgB;YACnB,eAAe,QAAQ,CAAC,IAAI,CAAC;QAChC,OAAS;YACN,OAAO;QACV;QAEEC,IAAI;QACJ,MAAO,IAAI,OAAO,MAAM,IAAA,CAAK,YAAY,cAAc,EAAG;YACzD,QAAQ,UAAU,CAAC,UAAU,IAAI,CAAC,GAAG,UAAU,KAAK;QACvD;QAEEA,IAAI,cAAc;QAElB,IAAI,MAAM,CAAC,EAAE,KAAK,KAAK;YACtB,KAAK;YACL,cAAc;QACjB;QAEE,IAAI,MAAM,CAAC,EAAE,KAAK,KAAK;YACtB,MAAM;QACT;QAEE,IAAI,CAAC,aAAa;YACjB,iBAAiB;YACjB,MAAM,IAAI,CAAC;QACd;QAEE,OAAO;IACT;IAEC,SAAS;QACRD,IAAM,QAAQ,OAAO,OAAO,CAAC,OAAO;QACpC,IAAI,CAAC,CAAC,OAAK;YAAE,MAAM;QAAe;QAElC,IAAI,QAAQ;QACZ,OAAO;IACT;IAEC,SAAS;QACRA,IAAM,QAAQ,OAAO,OAAO,CAAC,OAAO;QACpC,IAAI,CAAC,CAAC,OAAK;YAAE,MAAM;QAAe;QAElC,eAAe,QAAQ,CAAC,IAAI,CAAC,OAAO,KAAK,CAAC,IAAI,GAAG;QAEjD,IAAI,QAAQ;QACZ,OAAO;IACT;IAEC,SAAS;QACRA,IAAM,UAAU;QAEhB,IAAI,CAAC,SAAO;YAAE,MAAM;QAAoB;QAExC,IAAI,YAAY,eAAe,OAAO,EAAE;YACvC,MAAK,4BAA2B,UAAO,6BAA2B,eAAe,OAAA,GAAO;QAC3F;QAEE;QAEA,IAAI,MAAM,CAAC,EAAE,KAAK,KAAK;YACtB,MAAM;QACT;QAEE,MAAM,GAAG;QACT,iBAAiB,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE;QAExC,OAAO;IACT;IAEC,SAAS;QACRC,IAAI,OAAO;QACX,MAAO,IAAI,OAAO,MAAM,IAAI,oBAAoB,IAAI,CAAC,MAAM,CAAC,EAAE,EAAC;YAAE,QAAQ,MAAM,CAAC,IAAI;QAAA;QAEpF,OAAO;IACT;IAEC,SAAS;QACR,IAAI,CAAC,WAAW,IAAI,CAAC,MAAM,CAAC,EAAE,GAAC;YAAE,OAAO;QAAI;QAC5C;QAEAD,IAAM,OAAO;QACb,IAAI,CAAC,MAAI;YAAE,OAAO;QAAI;QAEtBC,IAAI,QAAQ;QAEZ;QACA,IAAI,MAAM,CAAC,EAAE,KAAK,KAAK;YACtB,KAAK;YACL;YAEA,QAAQ;YACR,IAAI,CAAC,MAAM,UAAU,MAAM,IAAI,OAAO,IAAE;gBAAE,QAAQ,CAAC;YAAK,EAAC,qCAAA;QAC5D;QAEE,OAAO;YAAA,MAAE;YAAI,OAAE;QAAK;IACtB;IAEC,SAAS;QACR,OAAO,UAAU,IAAI,CAAC,MAAM,CAAC,EAAE,IAAI,4BAA4B;IACjE;IAEC,SAAS;QACRA,IAAI,QAAQ;QACZ,GAAG;YACFD,IAAM,OAAO,MAAM,CAAC,EAAE;YACtB,IAAI,SAAS,OAAO,SAAS,OAAO,SAAS,KAAK;gBACjD,OAAO;YACX;YAEG,SAAS;YACT,KAAK;QACR,QAAW,IAAI,OAAO,MAAM,CAAE;QAE5B,OAAO;IACT;IAEC,SAAS;QACRA,IAAM,YAAY,MAAM,CAAC,IAAI;QAE7BC,IAAI,QAAQ;QACZA,IAAI,UAAU;QAEd,MAAO,IAAI,OAAO,MAAM,CAAE;YACzBD,IAAM,OAAO,MAAM,CAAC,IAAI;YACxB,IAAI,SAAS,aAAa,CAAC,SAAS;gBACnC,OAAO;YACX;YAEG,IAAI,SAAS,QAAQ,CAAC,SAAS;gBAC9B,UAAU;YACd;YAEG,SAAS,UAAO,OAAQ,OAAS;YACjC,UAAU;QACb;IACA;IAEC,SAAS;QACR,MAAO,IAAI,OAAO,MAAM,IAAI,WAAW,IAAI,CAAC,MAAM,CAAC,EAAE,EAAC;YAAE,KAAK;QAAC;IAChE;IAECC,IAAI,IAAI,SAAS,MAAM;IACvB,MAAO,IAAI,OAAO,MAAM,CAAE;QACzB,IAAI,CAAC,OAAK;YAAE,MAAM;QAAuB;QACzC,QAAQ;QACR,KAAK;IACP;IAEC,IAAI,UAAU,SAAS;QACtB,MAAM;IACR;IAEC,IAAI,KAAK,OAAO,KAAK,OAAK;QAAE,KAAK,QAAQ,GAAG;IAAM;IAClD,OAAO;QACN,MAAM;QACN,UAAU;YAAC;SAAK;IAClB;AACA"}},
    {"offset": {"line": 2765, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2770, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@turf/helpers/dist/es/index.js"],"sourcesContent":["/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3148, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3153, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@turf/invariant/dist/es/index.js"],"sourcesContent":["import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3269, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3274, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@turf/bearing/dist/es/index.js"],"sourcesContent":["import { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nexport default function bearing(start, end, options) {\n    if (options === void 0) { options = {}; }\n    // Reverse calculation\n    if (options.final === true) {\n        return calculateFinalBearing(start, end);\n    }\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n    var lon1 = degreesToRadians(coordinates1[0]);\n    var lon2 = degreesToRadians(coordinates2[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n    return radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n"],"names":[],"mappings":";;;;;;;;AA0Be,SAAS,QAAQ,KAAK,EAAE,GAAG,EAAE,OAAO;IAC/C,IAAI,YAAY,KAAK,GAAG;QAAE,UAAU,CAAC;IAAG;IACxC,sBAAsB;IACtB,IAAI,QAAQ,KAAK,KAAK,MAAM;QACxB,OAAO,sBAAsB,OAAO;IACxC;IACA,IAAI,eAAe,CAAA,GAAA,0JAAA,CAAA,WAAQ,AAAD,EAAE;IAC5B,IAAI,eAAe,CAAA,GAAA,0JAAA,CAAA,WAAQ,AAAD,EAAE;IAC5B,IAAI,OAAO,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE,YAAY,CAAC,EAAE;IAC3C,IAAI,OAAO,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE,YAAY,CAAC,EAAE;IAC3C,IAAI,OAAO,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE,YAAY,CAAC,EAAE;IAC3C,IAAI,OAAO,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE,YAAY,CAAC,EAAE;IAC3C,IAAI,IAAI,KAAK,GAAG,CAAC,OAAO,QAAQ,KAAK,GAAG,CAAC;IACzC,IAAI,IAAI,KAAK,GAAG,CAAC,QAAQ,KAAK,GAAG,CAAC,QAC9B,KAAK,GAAG,CAAC,QAAQ,KAAK,GAAG,CAAC,QAAQ,KAAK,GAAG,CAAC,OAAO;IACtD,OAAO,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE,KAAK,KAAK,CAAC,GAAG;AAC1C;AACA;;;;;;;CAOC,GACD,SAAS,sBAAsB,KAAK,EAAE,GAAG;IACrC,mBAAmB;IACnB,IAAI,OAAO,QAAQ,KAAK;IACxB,OAAO,CAAC,OAAO,GAAG,IAAI;IACtB,OAAO;AACX"}},
    {"offset": {"line": 3313, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3318, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@turf/destination/dist/es/index.js"],"sourcesContent":["// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nimport { degreesToRadians, lengthToRadians, point, radiansToDegrees, } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nexport default function destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearingRad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 +\n        Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n    return point([lng, lat], options.properties);\n}\n"],"names":[],"mappings":"AAAA,iDAAiD;AACjD,qDAAqD;;;;;;;;;AA6BtC,SAAS,YAAY,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,OAAO;IAClE,IAAI,YAAY,KAAK,GAAG;QAAE,UAAU,CAAC;IAAG;IACxC,eAAe;IACf,IAAI,eAAe,CAAA,GAAA,0JAAA,CAAA,WAAQ,AAAD,EAAE;IAC5B,IAAI,aAAa,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE,YAAY,CAAC,EAAE;IACjD,IAAI,YAAY,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE,YAAY,CAAC,EAAE;IAChD,IAAI,aAAa,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE;IAClC,IAAI,UAAU,CAAA,GAAA,wJAAA,CAAA,kBAAe,AAAD,EAAE,UAAU,QAAQ,KAAK;IACrD,OAAO;IACP,IAAI,YAAY,KAAK,IAAI,CAAC,KAAK,GAAG,CAAC,aAAa,KAAK,GAAG,CAAC,WACrD,KAAK,GAAG,CAAC,aAAa,KAAK,GAAG,CAAC,WAAW,KAAK,GAAG,CAAC;IACvD,IAAI,aAAa,aACb,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,cAAc,KAAK,GAAG,CAAC,WAAW,KAAK,GAAG,CAAC,YAAY,KAAK,GAAG,CAAC,WAAW,KAAK,GAAG,CAAC,aAAa,KAAK,GAAG,CAAC;IAClI,IAAI,MAAM,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE;IAC3B,IAAI,MAAM,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE;IAC3B,OAAO,CAAA,GAAA,wJAAA,CAAA,QAAK,AAAD,EAAE;QAAC;QAAK;KAAI,EAAE,QAAQ,UAAU;AAC/C"}},
    {"offset": {"line": 3348, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3353, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@turf/distance/dist/es/index.js"],"sourcesContent":["import { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians, } from \"@turf/helpers\";\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord | Point} from origin point or coordinate\n * @param {Coord | Point} to destination point or coordinate\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexport default distance;\n"],"names":[],"mappings":";;;;;;;;AAEA,gDAAgD;AAChD,oDAAoD;AACpD;;;;;;;;;;;;;;;;;;;;;CAqBC,GACD,SAAS,SAAS,IAAI,EAAE,EAAE,EAAE,OAAO;IAC/B,IAAI,YAAY,KAAK,GAAG;QAAE,UAAU,CAAC;IAAG;IACxC,IAAI,eAAe,CAAA,GAAA,0JAAA,CAAA,WAAQ,AAAD,EAAE;IAC5B,IAAI,eAAe,CAAA,GAAA,0JAAA,CAAA,WAAQ,AAAD,EAAE;IAC5B,IAAI,OAAO,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE,YAAY,CAAC,EAAE,GAAG,YAAY,CAAC,EAAE;IAC7D,IAAI,OAAO,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE,YAAY,CAAC,EAAE,GAAG,YAAY,CAAC,EAAE;IAC7D,IAAI,OAAO,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE,YAAY,CAAC,EAAE;IAC3C,IAAI,OAAO,CAAA,GAAA,wJAAA,CAAA,mBAAgB,AAAD,EAAE,YAAY,CAAC,EAAE;IAC3C,IAAI,IAAI,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,OAAO,IAAI,KACjC,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,OAAO,IAAI,KAAK,KAAK,GAAG,CAAC,QAAQ,KAAK,GAAG,CAAC;IAChE,OAAO,CAAA,GAAA,wJAAA,CAAA,kBAAe,AAAD,EAAE,IAAI,KAAK,KAAK,CAAC,KAAK,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,KAAK,QAAQ,KAAK;AACxF;uCACe"}},
    {"offset": {"line": 3398, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3403, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/@turf/midpoint/dist/es/index.js"],"sourcesContent":["import bearing from '@turf/bearing';\nimport destination from '@turf/destination';\nimport distance from '@turf/distance';\n\n/**\n * Takes two {@link Point|points} and returns a point midway between them.\n * The midpoint is calculated geodesically, meaning the curvature of the earth is taken into account.\n *\n * @name midpoint\n * @param {Coord} point1 first point\n * @param {Coord} point2 second point\n * @returns {Feature<Point>} a point midway between `pt1` and `pt2`\n * @example\n * var point1 = turf.point([144.834823, -37.771257]);\n * var point2 = turf.point([145.14244, -37.830937]);\n *\n * var midpoint = turf.midpoint(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2, midpoint];\n * midpoint.properties['marker-color'] = '#f00';\n */\nfunction midpoint(point1, point2) {\n  var dist = distance(point1, point2);\n  var heading = bearing(point1, point2);\n  var midpoint = destination(point1, dist / 2, heading);\n\n  return midpoint;\n}\n\nexport default midpoint;\n"],"names":[],"mappings":";;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;CAiBC,GACD,SAAS,SAAS,MAAM,EAAE,MAAM;IAC9B,IAAI,OAAO,CAAA,GAAA,yJAAA,CAAA,UAAQ,AAAD,EAAE,QAAQ;IAC5B,IAAI,UAAU,CAAA,GAAA,wJAAA,CAAA,UAAO,AAAD,EAAE,QAAQ;IAC9B,IAAI,WAAW,CAAA,GAAA,4JAAA,CAAA,UAAW,AAAD,EAAE,QAAQ,OAAO,GAAG;IAE7C,OAAO;AACT;uCAEe"}},
    {"offset": {"line": 3437, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3442, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/wkt-parser/parser.js"],"sourcesContent":["export default parseString;\n\nvar NEUTRAL = 1;\nvar KEYWORD = 2;\nvar NUMBER = 3;\nvar QUOTED = 4;\nvar AFTERQUOTE = 5;\nvar ENDED = -1;\nvar whitespace = /\\s/;\nvar latin = /[A-Za-z]/;\nvar keyword = /[A-Za-z84_]/;\nvar endThings = /[,\\]]/;\nvar digets = /[\\d\\.E\\-\\+]/;\n// const ignoredChar = /[\\s_\\-\\/\\(\\)]/g;\nfunction Parser(text) {\n  if (typeof text !== 'string') {\n    throw new Error('not a string');\n  }\n  this.text = text.trim();\n  this.level = 0;\n  this.place = 0;\n  this.root = null;\n  this.stack = [];\n  this.currentObject = null;\n  this.state = NEUTRAL;\n}\nParser.prototype.readCharicter = function() {\n  var char = this.text[this.place++];\n  if (this.state !== QUOTED) {\n    while (whitespace.test(char)) {\n      if (this.place >= this.text.length) {\n        return;\n      }\n      char = this.text[this.place++];\n    }\n  }\n  switch (this.state) {\n    case NEUTRAL:\n      return this.neutral(char);\n    case KEYWORD:\n      return this.keyword(char)\n    case QUOTED:\n      return this.quoted(char);\n    case AFTERQUOTE:\n      return this.afterquote(char);\n    case NUMBER:\n      return this.number(char);\n    case ENDED:\n      return;\n  }\n};\nParser.prototype.afterquote = function(char) {\n  if (char === '\"') {\n    this.word += '\"';\n    this.state = QUOTED;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = this.word.trim();\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in afterquote yet, index ' + this.place);\n};\nParser.prototype.afterItem = function(char) {\n  if (char === ',') {\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n    }\n    this.word = null;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (char === ']') {\n    this.level--;\n    if (this.word !== null) {\n      this.currentObject.push(this.word);\n      this.word = null;\n    }\n    this.state = NEUTRAL;\n    this.currentObject = this.stack.pop();\n    if (!this.currentObject) {\n      this.state = ENDED;\n    }\n\n    return;\n  }\n};\nParser.prototype.number = function(char) {\n  if (digets.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.word = parseFloat(this.word);\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in number yet, index ' + this.place);\n};\nParser.prototype.quoted = function(char) {\n  if (char === '\"') {\n    this.state = AFTERQUOTE;\n    return;\n  }\n  this.word += char;\n  return;\n};\nParser.prototype.keyword = function(char) {\n  if (keyword.test(char)) {\n    this.word += char;\n    return;\n  }\n  if (char === '[') {\n    var newObjects = [];\n    newObjects.push(this.word);\n    this.level++;\n    if (this.root === null) {\n      this.root = newObjects;\n    } else {\n      this.currentObject.push(newObjects);\n    }\n    this.stack.push(this.currentObject);\n    this.currentObject = newObjects;\n    this.state = NEUTRAL;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in keyword yet, index ' + this.place);\n};\nParser.prototype.neutral = function(char) {\n  if (latin.test(char)) {\n    this.word = char;\n    this.state = KEYWORD;\n    return;\n  }\n  if (char === '\"') {\n    this.word = '';\n    this.state = QUOTED;\n    return;\n  }\n  if (digets.test(char)) {\n    this.word = char;\n    this.state = NUMBER;\n    return;\n  }\n  if (endThings.test(char)) {\n    this.afterItem(char);\n    return;\n  }\n  throw new Error('havn\\'t handled \"' +char + '\" in neutral yet, index ' + this.place);\n};\nParser.prototype.output = function() {\n  while (this.place < this.text.length) {\n    this.readCharicter();\n  }\n  if (this.state === ENDED) {\n    return this.root;\n  }\n  throw new Error('unable to parse string \"' +this.text + '\". State is ' + this.state);\n};\n\nfunction parseString(txt) {\n  var parser = new Parser(txt);\n  return parser.output();\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3611, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3616, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/wkt-parser/process.js"],"sourcesContent":["\n\nfunction mapit(obj, key, value) {\n  if (Array.isArray(key)) {\n    value.unshift(key);\n    key = null;\n  }\n  var thing = key ? {} : obj;\n\n  var out = value.reduce(function(newObj, item) {\n    sExpr(item, newObj);\n    return newObj\n  }, thing);\n  if (key) {\n    obj[key] = out;\n  }\n}\n\nexport function sExpr(v, obj) {\n  if (!Array.isArray(v)) {\n    obj[v] = true;\n    return;\n  }\n  var key = v.shift();\n  if (key === 'PARAMETER') {\n    key = v.shift();\n  }\n  if (v.length === 1) {\n    if (Array.isArray(v[0])) {\n      obj[key] = {};\n      sExpr(v[0], obj[key]);\n      return;\n    }\n    obj[key] = v[0];\n    return;\n  }\n  if (!v.length) {\n    obj[key] = true;\n    return;\n  }\n  if (key === 'TOWGS84') {\n    obj[key] = v;\n    return;\n  }\n  if (key === 'AXIS') {\n    if (!(key in obj)) {\n      obj[key] = [];\n    }\n    obj[key].push(v);\n    return;\n  }\n  if (!Array.isArray(key)) {\n    obj[key] = {};\n  }\n\n  var i;\n  switch (key) {\n    case 'UNIT':\n    case 'PRIMEM':\n    case 'VERT_DATUM':\n      obj[key] = {\n        name: v[0].toLowerCase(),\n        convert: v[1]\n      };\n      if (v.length === 3) {\n        sExpr(v[2], obj[key]);\n      }\n      return;\n    case 'SPHEROID':\n    case 'ELLIPSOID':\n      obj[key] = {\n        name: v[0],\n        a: v[1],\n        rf: v[2]\n      };\n      if (v.length === 4) {\n        sExpr(v[3], obj[key]);\n      }\n      return;\n    case 'PROJECTEDCRS':\n    case 'PROJCRS':\n    case 'GEOGCS':\n    case 'GEOCCS':\n    case 'PROJCS':\n    case 'LOCAL_CS':\n    case 'GEODCRS':\n    case 'GEODETICCRS':\n    case 'GEODETICDATUM':\n    case 'EDATUM':\n    case 'ENGINEERINGDATUM':\n    case 'VERT_CS':\n    case 'VERTCRS':\n    case 'VERTICALCRS':\n    case 'COMPD_CS':\n    case 'COMPOUNDCRS':\n    case 'ENGINEERINGCRS':\n    case 'ENGCRS':\n    case 'FITTED_CS':\n    case 'LOCAL_DATUM':\n    case 'DATUM':\n      v[0] = ['name', v[0]];\n      mapit(obj, key, v);\n      return;\n    default:\n      i = -1;\n      while (++i < v.length) {\n        if (!Array.isArray(v[i])) {\n          return sExpr(v, obj[key]);\n        }\n      }\n      return mapit(obj, key, v);\n  }\n}\n"],"names":[],"mappings":";;;AAEA,SAAS,MAAM,GAAG,EAAE,GAAG,EAAE,KAAK;IAC5B,IAAI,MAAM,OAAO,CAAC,MAAM;QACtB,MAAM,OAAO,CAAC;QACd,MAAM;IACR;IACA,IAAI,QAAQ,MAAM,CAAC,IAAI;IAEvB,IAAI,MAAM,MAAM,MAAM,CAAC,SAAS,MAAM,EAAE,IAAI;QAC1C,MAAM,MAAM;QACZ,OAAO;IACT,GAAG;IACH,IAAI,KAAK;QACP,GAAG,CAAC,IAAI,GAAG;IACb;AACF;AAEO,SAAS,MAAM,CAAC,EAAE,GAAG;IAC1B,IAAI,CAAC,MAAM,OAAO,CAAC,IAAI;QACrB,GAAG,CAAC,EAAE,GAAG;QACT;IACF;IACA,IAAI,MAAM,EAAE,KAAK;IACjB,IAAI,QAAQ,aAAa;QACvB,MAAM,EAAE,KAAK;IACf;IACA,IAAI,EAAE,MAAM,KAAK,GAAG;QAClB,IAAI,MAAM,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG;YACvB,GAAG,CAAC,IAAI,GAAG,CAAC;YACZ,MAAM,CAAC,CAAC,EAAE,EAAE,GAAG,CAAC,IAAI;YACpB;QACF;QACA,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,EAAE;QACf;IACF;IACA,IAAI,CAAC,EAAE,MAAM,EAAE;QACb,GAAG,CAAC,IAAI,GAAG;QACX;IACF;IACA,IAAI,QAAQ,WAAW;QACrB,GAAG,CAAC,IAAI,GAAG;QACX;IACF;IACA,IAAI,QAAQ,QAAQ;QAClB,IAAI,CAAC,CAAC,OAAO,GAAG,GAAG;YACjB,GAAG,CAAC,IAAI,GAAG,EAAE;QACf;QACA,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC;QACd;IACF;IACA,IAAI,CAAC,MAAM,OAAO,CAAC,MAAM;QACvB,GAAG,CAAC,IAAI,GAAG,CAAC;IACd;IAEA,IAAI;IACJ,OAAQ;QACN,KAAK;QACL,KAAK;QACL,KAAK;YACH,GAAG,CAAC,IAAI,GAAG;gBACT,MAAM,CAAC,CAAC,EAAE,CAAC,WAAW;gBACtB,SAAS,CAAC,CAAC,EAAE;YACf;YACA,IAAI,EAAE,MAAM,KAAK,GAAG;gBAClB,MAAM,CAAC,CAAC,EAAE,EAAE,GAAG,CAAC,IAAI;YACtB;YACA;QACF,KAAK;QACL,KAAK;YACH,GAAG,CAAC,IAAI,GAAG;gBACT,MAAM,CAAC,CAAC,EAAE;gBACV,GAAG,CAAC,CAAC,EAAE;gBACP,IAAI,CAAC,CAAC,EAAE;YACV;YACA,IAAI,EAAE,MAAM,KAAK,GAAG;gBAClB,MAAM,CAAC,CAAC,EAAE,EAAE,GAAG,CAAC,IAAI;YACtB;YACA;QACF,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACH,CAAC,CAAC,EAAE,GAAG;gBAAC;gBAAQ,CAAC,CAAC,EAAE;aAAC;YACrB,MAAM,KAAK,KAAK;YAChB;QACF;YACE,IAAI,CAAC;YACL,MAAO,EAAE,IAAI,EAAE,MAAM,CAAE;gBACrB,IAAI,CAAC,MAAM,OAAO,CAAC,CAAC,CAAC,EAAE,GAAG;oBACxB,OAAO,MAAM,GAAG,GAAG,CAAC,IAAI;gBAC1B;YACF;YACA,OAAO,MAAM,KAAK,KAAK;IAC3B;AACF"}},
    {"offset": {"line": 3730, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3735, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/wkt-parser/index.js"],"sourcesContent":["var D2R = 0.01745329251994329577;\nimport parser from './parser';\nimport {sExpr} from './process';\n\n\n\nfunction rename(obj, params) {\n  var outName = params[0];\n  var inName = params[1];\n  if (!(outName in obj) && (inName in obj)) {\n    obj[outName] = obj[inName];\n    if (params.length === 3) {\n      obj[outName] = params[2](obj[outName]);\n    }\n  }\n}\n\nfunction d2r(input) {\n  return input * D2R;\n}\n\nfunction cleanWKT(wkt) {\n  if (wkt.type === 'GEOGCS') {\n    wkt.projName = 'longlat';\n  } else if (wkt.type === 'LOCAL_CS') {\n    wkt.projName = 'identity';\n    wkt.local = true;\n  } else {\n    if (typeof wkt.PROJECTION === 'object') {\n      wkt.projName = Object.keys(wkt.PROJECTION)[0];\n    } else {\n      wkt.projName = wkt.PROJECTION;\n    }\n  }\n  if (wkt.AXIS) {\n    var axisOrder = '';\n    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {\n      var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];\n      if (axis[0].indexOf('north') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north')) {\n        axisOrder += 'n';\n      } else if (axis[0].indexOf('south') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south')) {\n        axisOrder += 's';\n      } else if (axis[0].indexOf('east') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east')) {\n        axisOrder += 'e';\n      } else if (axis[0].indexOf('west') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west')) {\n        axisOrder += 'w';\n      }\n    }\n    if (axisOrder.length === 2) {\n      axisOrder += 'u';\n    }\n    if (axisOrder.length === 3) {\n      wkt.axis = axisOrder;\n    }\n  }\n  if (wkt.UNIT) {\n    wkt.units = wkt.UNIT.name.toLowerCase();\n    if (wkt.units === 'metre') {\n      wkt.units = 'meter';\n    }\n    if (wkt.UNIT.convert) {\n      if (wkt.type === 'GEOGCS') {\n        if (wkt.DATUM && wkt.DATUM.SPHEROID) {\n          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;\n        }\n      } else {\n        wkt.to_meter = wkt.UNIT.convert;\n      }\n    }\n  }\n  var geogcs = wkt.GEOGCS;\n  if (wkt.type === 'GEOGCS') {\n    geogcs = wkt;\n  }\n  if (geogcs) {\n    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){\n    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;\n    //}\n    if (geogcs.DATUM) {\n      wkt.datumCode = geogcs.DATUM.name.toLowerCase();\n    } else {\n      wkt.datumCode = geogcs.name.toLowerCase();\n    }\n    if (wkt.datumCode.slice(0, 2) === 'd_') {\n      wkt.datumCode = wkt.datumCode.slice(2);\n    }\n    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {\n      wkt.datumCode = 'nzgd49';\n    }\n    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {\n      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {\n        wkt.sphere = true;\n      }\n      wkt.datumCode = 'wgs84';\n    }\n    if (wkt.datumCode.slice(-6) === '_ferro') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 6);\n    }\n    if (wkt.datumCode.slice(-8) === '_jakarta') {\n      wkt.datumCode = wkt.datumCode.slice(0, - 8);\n    }\n    if (~wkt.datumCode.indexOf('belge')) {\n      wkt.datumCode = 'rnb72';\n    }\n    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {\n      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\\_18/, 'clrk');\n      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {\n        wkt.ellps = 'intl';\n      }\n\n      wkt.a = geogcs.DATUM.SPHEROID.a;\n      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);\n    }\n\n    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {\n      wkt.datum_params = geogcs.DATUM.TOWGS84;\n    }\n    if (~wkt.datumCode.indexOf('osgb_1936')) {\n      wkt.datumCode = 'osgb36';\n    }\n    if (~wkt.datumCode.indexOf('osni_1952')) {\n      wkt.datumCode = 'osni52';\n    }\n    if (~wkt.datumCode.indexOf('tm65')\n      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {\n      wkt.datumCode = 'ire65';\n    }\n    if (wkt.datumCode === 'ch1903+') {\n      wkt.datumCode = 'ch1903';\n    }\n    if (~wkt.datumCode.indexOf('israel')) {\n      wkt.datumCode = 'isr93';\n    }\n  }\n  if (wkt.b && !isFinite(wkt.b)) {\n    wkt.b = wkt.a;\n  }\n\n  function toMeter(input) {\n    var ratio = wkt.to_meter || 1;\n    return input * ratio;\n  }\n  var renamer = function(a) {\n    return rename(wkt, a);\n  };\n  var list = [\n    ['standard_parallel_1', 'Standard_Parallel_1'],\n    ['standard_parallel_1', 'Latitude of 1st standard parallel'],\n    ['standard_parallel_2', 'Standard_Parallel_2'],\n    ['standard_parallel_2', 'Latitude of 2nd standard parallel'],\n    ['false_easting', 'False_Easting'],\n    ['false_easting', 'False easting'],\n    ['false-easting', 'Easting at false origin'],\n    ['false_northing', 'False_Northing'],\n    ['false_northing', 'False northing'],\n    ['false_northing', 'Northing at false origin'],\n    ['central_meridian', 'Central_Meridian'],\n    ['central_meridian', 'Longitude of natural origin'],\n    ['central_meridian', 'Longitude of false origin'],\n    ['latitude_of_origin', 'Latitude_Of_Origin'],\n    ['latitude_of_origin', 'Central_Parallel'],\n    ['latitude_of_origin', 'Latitude of natural origin'],\n    ['latitude_of_origin', 'Latitude of false origin'],\n    ['scale_factor', 'Scale_Factor'],\n    ['k0', 'scale_factor'],\n    ['latitude_of_center', 'Latitude_Of_Center'],\n    ['latitude_of_center', 'Latitude_of_center'],\n    ['lat0', 'latitude_of_center', d2r],\n    ['longitude_of_center', 'Longitude_Of_Center'],\n    ['longitude_of_center', 'Longitude_of_center'],\n    ['longc', 'longitude_of_center', d2r],\n    ['x0', 'false_easting', toMeter],\n    ['y0', 'false_northing', toMeter],\n    ['long0', 'central_meridian', d2r],\n    ['lat0', 'latitude_of_origin', d2r],\n    ['lat0', 'standard_parallel_1', d2r],\n    ['lat1', 'standard_parallel_1', d2r],\n    ['lat2', 'standard_parallel_2', d2r],\n    ['azimuth', 'Azimuth'],\n    ['alpha', 'azimuth', d2r],\n    ['srsCode', 'name']\n  ];\n  list.forEach(renamer);\n  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {\n    wkt.long0 = wkt.longc;\n  }\n  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {\n    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);\n    wkt.lat_ts = wkt.lat1;\n  } else if (!wkt.lat_ts && wkt.lat0 && wkt.projName === 'Polar_Stereographic') {\n    wkt.lat_ts = wkt.lat0;\n    wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90);\n  }\n}\nexport default function(wkt) {\n  var lisp = parser(wkt);\n  var type = lisp.shift();\n  var name = lisp.shift();\n  lisp.unshift(['name', name]);\n  lisp.unshift(['type', type]);\n  var obj = {};\n  sExpr(lisp, obj);\n  cleanWKT(obj);\n  return obj;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4061, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4066, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/mgrs/mgrs.js"],"sourcesContent":["\n\n\n/**\n * UTM zones are grouped, and assigned to one of a group of 6\n * sets.\n *\n * {int} @private\n */\nvar NUM_100K_SETS = 6;\n\n/**\n * The column letters (for easting) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';\n\n/**\n * The row letters (for northing) of the lower left value, per\n * set.\n *\n * {string} @private\n */\nvar SET_ORIGIN_ROW_LETTERS = 'AFAFAF';\n\nvar A = 65; // A\nvar I = 73; // I\nvar O = 79; // O\nvar V = 86; // V\nvar Z = 90; // Z\nexport default {\n  forward: forward,\n  inverse: inverse,\n  toPoint: toPoint\n};\n/**\n * Conversion of lat/lon to MGRS.\n *\n * @param {object} ll Object literal with lat and lon properties on a\n *     WGS84 ellipsoid.\n * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for\n *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.\n * @return {string} the MGRS string for the given location and accuracy.\n */\nexport function forward(ll, accuracy) {\n  accuracy = accuracy || 5; // default accuracy 1m\n  return encode(LLtoUTM({\n    lat: ll[1],\n    lon: ll[0]\n  }), accuracy);\n};\n\n/**\n * Conversion of MGRS to lat/lon.\n *\n * @param {string} mgrs MGRS string.\n * @return {array} An array with left (longitude), bottom (latitude), right\n *     (longitude) and top (latitude) values in WGS84, representing the\n *     bounding box for the provided MGRS reference.\n */\nexport function inverse(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];\n  }\n  return [bbox.left, bbox.bottom, bbox.right, bbox.top];\n};\n\nexport function toPoint(mgrs) {\n  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));\n  if (bbox.lat && bbox.lon) {\n    return [bbox.lon, bbox.lat];\n  }\n  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];\n};\n/**\n * Conversion from degrees to radians.\n *\n * @private\n * @param {number} deg the angle in degrees.\n * @return {number} the angle in radians.\n */\nfunction degToRad(deg) {\n  return (deg * (Math.PI / 180.0));\n}\n\n/**\n * Conversion from radians to degrees.\n *\n * @private\n * @param {number} rad the angle in radians.\n * @return {number} the angle in degrees.\n */\nfunction radToDeg(rad) {\n  return (180.0 * (rad / Math.PI));\n}\n\n/**\n * Converts a set of Longitude and Latitude co-ordinates to UTM\n * using the WGS84 ellipsoid.\n *\n * @private\n * @param {object} ll Object literal with lat and lon properties\n *     representing the WGS84 coordinate to be converted.\n * @return {object} Object literal containing the UTM value with easting,\n *     northing, zoneNumber and zoneLetter properties, and an optional\n *     accuracy property in digits. Returns null if the conversion failed.\n */\nfunction LLtoUTM(ll) {\n  var Lat = ll.lat;\n  var Long = ll.lon;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var k0 = 0.9996;\n  var LongOrigin;\n  var eccPrimeSquared;\n  var N, T, C, A, M;\n  var LatRad = degToRad(Lat);\n  var LongRad = degToRad(Long);\n  var LongOriginRad;\n  var ZoneNumber;\n  // (int)\n  ZoneNumber = Math.floor((Long + 180) / 6) + 1;\n\n  //Make sure the longitude 180.00 is in Zone 60\n  if (Long === 180) {\n    ZoneNumber = 60;\n  }\n\n  // Special zone for Norway\n  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {\n    ZoneNumber = 32;\n  }\n\n  // Special zones for Svalbard\n  if (Lat >= 72.0 && Lat < 84.0) {\n    if (Long >= 0.0 && Long < 9.0) {\n      ZoneNumber = 31;\n    }\n    else if (Long >= 9.0 && Long < 21.0) {\n      ZoneNumber = 33;\n    }\n    else if (Long >= 21.0 && Long < 33.0) {\n      ZoneNumber = 35;\n    }\n    else if (Long >= 33.0 && Long < 42.0) {\n      ZoneNumber = 37;\n    }\n  }\n\n  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin\n  // in middle of\n  // zone\n  LongOriginRad = degToRad(LongOrigin);\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));\n  T = Math.tan(LatRad) * Math.tan(LatRad);\n  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);\n  A = Math.cos(LatRad) * (LongRad - LongOriginRad);\n\n  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));\n\n  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);\n\n  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));\n  if (Lat < 0.0) {\n    UTMNorthing += 10000000.0; //10000000 meter offset for\n    // southern hemisphere\n  }\n\n  return {\n    northing: Math.round(UTMNorthing),\n    easting: Math.round(UTMEasting),\n    zoneNumber: ZoneNumber,\n    zoneLetter: getLetterDesignator(Lat)\n  };\n}\n\n/**\n * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience\n * class where the Zone can be specified as a single string eg.\"60N\" which\n * is then broken down into the ZoneNumber and ZoneLetter.\n *\n * @private\n * @param {object} utm An object literal with northing, easting, zoneNumber\n *     and zoneLetter properties. If an optional accuracy property is\n *     provided (in meters), a bounding box will be returned instead of\n *     latitude and longitude.\n * @return {object} An object literal containing either lat and lon values\n *     (if no accuracy was provided), or top, right, bottom and left values\n *     for the bounding box calculated according to the provided accuracy.\n *     Returns null if the conversion failed.\n */\nfunction UTMtoLL(utm) {\n\n  var UTMNorthing = utm.northing;\n  var UTMEasting = utm.easting;\n  var zoneLetter = utm.zoneLetter;\n  var zoneNumber = utm.zoneNumber;\n  // check the ZoneNummber is valid\n  if (zoneNumber < 0 || zoneNumber > 60) {\n    return null;\n  }\n\n  var k0 = 0.9996;\n  var a = 6378137.0; //ellip.radius;\n  var eccSquared = 0.00669438; //ellip.eccsq;\n  var eccPrimeSquared;\n  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));\n  var N1, T1, C1, R1, D, M;\n  var LongOrigin;\n  var mu, phi1Rad;\n\n  // remove 500,000 meter offset for longitude\n  var x = UTMEasting - 500000.0;\n  var y = UTMNorthing;\n\n  // We must know somehow if we are in the Northern or Southern\n  // hemisphere, this is the only time we use the letter So even\n  // if the Zone letter isn't exactly correct it should indicate\n  // the hemisphere correctly\n  if (zoneLetter < 'N') {\n    y -= 10000000.0; // remove 10,000,000 meter offset used\n    // for southern hemisphere\n  }\n\n  // There are 60 zones with zone 1 being at West -180 to -174\n  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin\n  // in middle of\n  // zone\n\n  eccPrimeSquared = (eccSquared) / (1 - eccSquared);\n\n  M = y / k0;\n  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));\n\n  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);\n  // double phi1 = ProjMath.radToDeg(phi1Rad);\n\n  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));\n  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);\n  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);\n  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);\n  D = x / (N1 * k0);\n\n  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);\n  lat = radToDeg(lat);\n\n  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);\n  lon = LongOrigin + radToDeg(lon);\n\n  var result;\n  if (utm.accuracy) {\n    var topRight = UTMtoLL({\n      northing: utm.northing + utm.accuracy,\n      easting: utm.easting + utm.accuracy,\n      zoneLetter: utm.zoneLetter,\n      zoneNumber: utm.zoneNumber\n    });\n    result = {\n      top: topRight.lat,\n      right: topRight.lon,\n      bottom: lat,\n      left: lon\n    };\n  }\n  else {\n    result = {\n      lat: lat,\n      lon: lon\n    };\n  }\n  return result;\n}\n\n/**\n * Calculates the MGRS letter designator for the given latitude.\n *\n * @private\n * @param {number} lat The latitude in WGS84 to get the letter designator\n *     for.\n * @return {char} The letter designator.\n */\nfunction getLetterDesignator(lat) {\n  //This is here as an error flag to show that the Latitude is\n  //outside MGRS limits\n  var LetterDesignator = 'Z';\n\n  if ((84 >= lat) && (lat >= 72)) {\n    LetterDesignator = 'X';\n  }\n  else if ((72 > lat) && (lat >= 64)) {\n    LetterDesignator = 'W';\n  }\n  else if ((64 > lat) && (lat >= 56)) {\n    LetterDesignator = 'V';\n  }\n  else if ((56 > lat) && (lat >= 48)) {\n    LetterDesignator = 'U';\n  }\n  else if ((48 > lat) && (lat >= 40)) {\n    LetterDesignator = 'T';\n  }\n  else if ((40 > lat) && (lat >= 32)) {\n    LetterDesignator = 'S';\n  }\n  else if ((32 > lat) && (lat >= 24)) {\n    LetterDesignator = 'R';\n  }\n  else if ((24 > lat) && (lat >= 16)) {\n    LetterDesignator = 'Q';\n  }\n  else if ((16 > lat) && (lat >= 8)) {\n    LetterDesignator = 'P';\n  }\n  else if ((8 > lat) && (lat >= 0)) {\n    LetterDesignator = 'N';\n  }\n  else if ((0 > lat) && (lat >= -8)) {\n    LetterDesignator = 'M';\n  }\n  else if ((-8 > lat) && (lat >= -16)) {\n    LetterDesignator = 'L';\n  }\n  else if ((-16 > lat) && (lat >= -24)) {\n    LetterDesignator = 'K';\n  }\n  else if ((-24 > lat) && (lat >= -32)) {\n    LetterDesignator = 'J';\n  }\n  else if ((-32 > lat) && (lat >= -40)) {\n    LetterDesignator = 'H';\n  }\n  else if ((-40 > lat) && (lat >= -48)) {\n    LetterDesignator = 'G';\n  }\n  else if ((-48 > lat) && (lat >= -56)) {\n    LetterDesignator = 'F';\n  }\n  else if ((-56 > lat) && (lat >= -64)) {\n    LetterDesignator = 'E';\n  }\n  else if ((-64 > lat) && (lat >= -72)) {\n    LetterDesignator = 'D';\n  }\n  else if ((-72 > lat) && (lat >= -80)) {\n    LetterDesignator = 'C';\n  }\n  return LetterDesignator;\n}\n\n/**\n * Encodes a UTM location as MGRS string.\n *\n * @private\n * @param {object} utm An object literal with easting, northing,\n *     zoneLetter, zoneNumber\n * @param {number} accuracy Accuracy in digits (1-5).\n * @return {string} MGRS string for the given UTM location.\n */\nfunction encode(utm, accuracy) {\n  // prepend with leading zeroes\n  var seasting = \"00000\" + utm.easting,\n    snorthing = \"00000\" + utm.northing;\n\n  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);\n}\n\n/**\n * Get the two letter 100k designator for a given UTM easting,\n * northing and zone number value.\n *\n * @private\n * @param {number} easting\n * @param {number} northing\n * @param {number} zoneNumber\n * @return the two letter 100k designator for the given UTM location.\n */\nfunction get100kID(easting, northing, zoneNumber) {\n  var setParm = get100kSetForZone(zoneNumber);\n  var setColumn = Math.floor(easting / 100000);\n  var setRow = Math.floor(northing / 100000) % 20;\n  return getLetter100kID(setColumn, setRow, setParm);\n}\n\n/**\n * Given a UTM zone number, figure out the MGRS 100K set it is in.\n *\n * @private\n * @param {number} i An UTM zone number.\n * @return {number} the 100k set the UTM zone is in.\n */\nfunction get100kSetForZone(i) {\n  var setParm = i % NUM_100K_SETS;\n  if (setParm === 0) {\n    setParm = NUM_100K_SETS;\n  }\n\n  return setParm;\n}\n\n/**\n * Get the two-letter MGRS 100k designator given information\n * translated from the UTM northing, easting and zone number.\n *\n * @private\n * @param {number} column the column index as it relates to the MGRS\n *        100k set spreadsheet, created from the UTM easting.\n *        Values are 1-8.\n * @param {number} row the row index as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM northing value. Values\n *        are from 0-19.\n * @param {number} parm the set block, as it relates to the MGRS 100k set\n *        spreadsheet, created from the UTM zone. Values are from\n *        1-60.\n * @return two letter MGRS 100k code.\n */\nfunction getLetter100kID(column, row, parm) {\n  // colOrigin and rowOrigin are the letters at the origin of the set\n  var index = parm - 1;\n  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);\n  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);\n\n  // colInt and rowInt are the letters to build to return\n  var colInt = colOrigin + column - 1;\n  var rowInt = rowOrigin + row;\n  var rollover = false;\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n    rollover = true;\n  }\n\n  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {\n    colInt++;\n  }\n\n  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {\n    colInt++;\n\n    if (colInt === I) {\n      colInt++;\n    }\n  }\n\n  if (colInt > Z) {\n    colInt = colInt - Z + A - 1;\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n    rollover = true;\n  }\n  else {\n    rollover = false;\n  }\n\n  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {\n    rowInt++;\n  }\n\n  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {\n    rowInt++;\n\n    if (rowInt === I) {\n      rowInt++;\n    }\n  }\n\n  if (rowInt > V) {\n    rowInt = rowInt - V + A - 1;\n  }\n\n  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);\n  return twoLetter;\n}\n\n/**\n * Decode the UTM parameters from a MGRS string.\n *\n * @private\n * @param {string} mgrsString an UPPERCASE coordinate string is expected.\n * @return {object} An object literal with easting, northing, zoneLetter,\n *     zoneNumber and accuracy (in meters) properties.\n */\nfunction decode(mgrsString) {\n\n  if (mgrsString && mgrsString.length === 0) {\n    throw (\"MGRSPoint coverting from nothing\");\n  }\n\n  var length = mgrsString.length;\n\n  var hunK = null;\n  var sb = \"\";\n  var testChar;\n  var i = 0;\n\n  // get Zone number\n  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {\n    if (i >= 2) {\n      throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n    }\n    sb += testChar;\n    i++;\n  }\n\n  var zoneNumber = parseInt(sb, 10);\n\n  if (i === 0 || i + 3 > length) {\n    // A good MGRS string has to be 4-5 digits long,\n    // ##AAA/#AAA at least.\n    throw (\"MGRSPoint bad conversion from: \" + mgrsString);\n  }\n\n  var zoneLetter = mgrsString.charAt(i++);\n\n  // Should we check the zone letter here? Why not.\n  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {\n    throw (\"MGRSPoint zone letter \" + zoneLetter + \" not handled: \" + mgrsString);\n  }\n\n  hunK = mgrsString.substring(i, i += 2);\n\n  var set = get100kSetForZone(zoneNumber);\n\n  var east100k = getEastingFromChar(hunK.charAt(0), set);\n  var north100k = getNorthingFromChar(hunK.charAt(1), set);\n\n  // We have a bug where the northing may be 2000000 too low.\n  // How\n  // do we know when to roll over?\n\n  while (north100k < getMinNorthing(zoneLetter)) {\n    north100k += 2000000;\n  }\n\n  // calculate the char index for easting/northing separator\n  var remainder = length - i;\n\n  if (remainder % 2 !== 0) {\n    throw (\"MGRSPoint has to have an even number \\nof digits after the zone letter and two 100km letters - front \\nhalf for easting meters, second half for \\nnorthing meters\" + mgrsString);\n  }\n\n  var sep = remainder / 2;\n\n  var sepEasting = 0.0;\n  var sepNorthing = 0.0;\n  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;\n  if (sep > 0) {\n    accuracyBonus = 100000.0 / Math.pow(10, sep);\n    sepEastingString = mgrsString.substring(i, i + sep);\n    sepEasting = parseFloat(sepEastingString) * accuracyBonus;\n    sepNorthingString = mgrsString.substring(i + sep);\n    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;\n  }\n\n  easting = sepEasting + east100k;\n  northing = sepNorthing + north100k;\n\n  return {\n    easting: easting,\n    northing: northing,\n    zoneLetter: zoneLetter,\n    zoneNumber: zoneNumber,\n    accuracy: accuracyBonus\n  };\n}\n\n/**\n * Given the first letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the easting value that\n * should be added to the other, secondary easting value.\n *\n * @private\n * @param {char} e The first letter from a two-letter MGRS 100´k zone.\n * @param {number} set The MGRS table set for the zone number.\n * @return {number} The easting value for the given letter and set.\n */\nfunction getEastingFromChar(e, set) {\n  // colOrigin is the letter at the origin of the set for the\n  // column\n  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);\n  var eastingValue = 100000.0;\n  var rewindMarker = false;\n\n  while (curCol !== e.charCodeAt(0)) {\n    curCol++;\n    if (curCol === I) {\n      curCol++;\n    }\n    if (curCol === O) {\n      curCol++;\n    }\n    if (curCol > Z) {\n      if (rewindMarker) {\n        throw (\"Bad character: \" + e);\n      }\n      curCol = A;\n      rewindMarker = true;\n    }\n    eastingValue += 100000.0;\n  }\n\n  return eastingValue;\n}\n\n/**\n * Given the second letter from a two-letter MGRS 100k zone, and given the\n * MGRS table set for the zone number, figure out the northing value that\n * should be added to the other, secondary northing value. You have to\n * remember that Northings are determined from the equator, and the vertical\n * cycle of letters mean a 2000000 additional northing meters. This happens\n * approx. every 18 degrees of latitude. This method does *NOT* count any\n * additional northings. You have to figure out how many 2000000 meters need\n * to be added for the zone letter of the MGRS coordinate.\n *\n * @private\n * @param {char} n Second letter of the MGRS 100k zone\n * @param {number} set The MGRS table set number, which is dependent on the\n *     UTM zone number.\n * @return {number} The northing value for the given letter and set.\n */\nfunction getNorthingFromChar(n, set) {\n\n  if (n > 'V') {\n    throw (\"MGRSPoint given invalid Northing \" + n);\n  }\n\n  // rowOrigin is the letter at the origin of the set for the\n  // column\n  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);\n  var northingValue = 0.0;\n  var rewindMarker = false;\n\n  while (curRow !== n.charCodeAt(0)) {\n    curRow++;\n    if (curRow === I) {\n      curRow++;\n    }\n    if (curRow === O) {\n      curRow++;\n    }\n    // fixing a bug making whole application hang in this loop\n    // when 'n' is a wrong character\n    if (curRow > V) {\n      if (rewindMarker) { // making sure that this loop ends\n        throw (\"Bad character: \" + n);\n      }\n      curRow = A;\n      rewindMarker = true;\n    }\n    northingValue += 100000.0;\n  }\n\n  return northingValue;\n}\n\n/**\n * The function getMinNorthing returns the minimum northing value of a MGRS\n * zone.\n *\n * Ported from Geotrans' c Lattitude_Band_Value structure table.\n *\n * @private\n * @param {char} zoneLetter The MGRS zone to get the min northing for.\n * @return {number}\n */\nfunction getMinNorthing(zoneLetter) {\n  var northing;\n  switch (zoneLetter) {\n  case 'C':\n    northing = 1100000.0;\n    break;\n  case 'D':\n    northing = 2000000.0;\n    break;\n  case 'E':\n    northing = 2800000.0;\n    break;\n  case 'F':\n    northing = 3700000.0;\n    break;\n  case 'G':\n    northing = 4600000.0;\n    break;\n  case 'H':\n    northing = 5500000.0;\n    break;\n  case 'J':\n    northing = 6400000.0;\n    break;\n  case 'K':\n    northing = 7300000.0;\n    break;\n  case 'L':\n    northing = 8200000.0;\n    break;\n  case 'M':\n    northing = 9100000.0;\n    break;\n  case 'N':\n    northing = 0.0;\n    break;\n  case 'P':\n    northing = 800000.0;\n    break;\n  case 'Q':\n    northing = 1700000.0;\n    break;\n  case 'R':\n    northing = 2600000.0;\n    break;\n  case 'S':\n    northing = 3500000.0;\n    break;\n  case 'T':\n    northing = 4400000.0;\n    break;\n  case 'U':\n    northing = 5300000.0;\n    break;\n  case 'V':\n    northing = 6200000.0;\n    break;\n  case 'W':\n    northing = 7000000.0;\n    break;\n  case 'X':\n    northing = 7900000.0;\n    break;\n  default:\n    northing = -1.0;\n  }\n  if (northing >= 0.0) {\n    return northing;\n  }\n  else {\n    throw (\"Invalid zone letter: \" + zoneLetter);\n  }\n\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4695, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}