(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@allmaps_transform_dist_bundled_index_es_a8e89d.js", {

"[project]/node_modules/@allmaps/transform/dist/bundled/index.es.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "GcpTransformer": ()=>As,
    "Helmert": ()=>Me,
    "Polynomial": ()=>Jt,
    "Projective": ()=>Vs,
    "RBF": ()=>Os,
    "Straight": ()=>zs,
    "Transformation": ()=>jt,
    "computeDistortionFromPartialDerivatives": ()=>xs,
    "supportedDistortionMeasures": ()=>Xs
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/geojson.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$svg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/svg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$midpoint$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/midpoint/dist/es/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/es/index.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
function ue(i) {
    if (i.__esModule) return i;
    var t = i.default;
    if (typeof t == "function") {
        var s = function e() {
            return this instanceof e ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
        };
        s.prototype = t.prototype;
    } else s = {};
    return Object.defineProperty(s, "__esModule", {
        value: !0
    }), Object.keys(i).forEach(function(e) {
        var r = Object.getOwnPropertyDescriptor(i, e);
        Object.defineProperty(s, e, r.get ? r : {
            enumerable: !0,
            get: function() {
                return i[e];
            }
        });
    }), s;
}
var T = {};
const $e = Object.prototype.toString;
function yt(i) {
    const t = $e.call(i);
    return t.endsWith("Array]") && !t.includes("Big");
}
const Le = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    isAnyArray: yt
}, Symbol.toStringTag, {
    value: "Module"
})), ze = /* @__PURE__ */ ue(Le);
function Ve(i) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!yt(i)) throw new TypeError("input must be an array");
    if (i.length === 0) throw new TypeError("input must not be empty");
    var s = t.fromIndex, e = s === void 0 ? 0 : s, r = t.toIndex, o = r === void 0 ? i.length : r;
    if (e < 0 || e >= i.length || !Number.isInteger(e)) throw new Error("fromIndex must be a positive integer smaller than length");
    if (o <= e || o > i.length || !Number.isInteger(o)) throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
    for(var n = i[e], h = e + 1; h < o; h++)i[h] > n && (n = i[h]);
    return n;
}
function Oe(i) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!yt(i)) throw new TypeError("input must be an array");
    if (i.length === 0) throw new TypeError("input must not be empty");
    var s = t.fromIndex, e = s === void 0 ? 0 : s, r = t.toIndex, o = r === void 0 ? i.length : r;
    if (e < 0 || e >= i.length || !Number.isInteger(e)) throw new Error("fromIndex must be a positive integer smaller than length");
    if (o <= e || o > i.length || !Number.isInteger(o)) throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
    for(var n = i[e], h = e + 1; h < o; h++)i[h] < n && (n = i[h]);
    return n;
}
function We(i) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (yt(i)) {
        if (i.length === 0) throw new TypeError("input must not be empty");
    } else throw new TypeError("input must be an array");
    var s;
    if (t.output !== void 0) {
        if (!yt(t.output)) throw new TypeError("output option must be an array if specified");
        s = t.output;
    } else s = new Array(i.length);
    var e = Oe(i), r = Ve(i);
    if (e === r) throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");
    var o = t.min, n = o === void 0 ? t.autoMinMax ? e : 0 : o, h = t.max, l = h === void 0 ? t.autoMinMax ? r : 1 : h;
    if (n >= l) throw new RangeError("min option must be smaller than max option");
    for(var a = (l - n) / (r - e), c = 0; c < i.length; c++)s[c] = (i[c] - e) * a + n;
    return s;
}
const Ue = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: We
}, Symbol.toStringTag, {
    value: "Module"
})), Ye = /* @__PURE__ */ ue(Ue);
Object.defineProperty(T, "__esModule", {
    value: !0
});
var U = ze, se = Ye;
const Rt = " ".repeat(2), fe = " ".repeat(4);
function _e() {
    return ce(this);
}
function ce(i, t = {}) {
    const { maxRows: s = 15, maxColumns: e = 10, maxNumSize: r = 8, padMinus: o = "auto" } = t;
    return `${i.constructor.name} {
${Rt}[
${fe}${Xe(i, s, e, r, o)}
${Rt}]
${Rt}rows: ${i.rows}
${Rt}columns: ${i.columns}
}`;
}
function Xe(i, t, s, e, r) {
    const { rows: o, columns: n } = i, h = Math.min(o, t), l = Math.min(n, s), a = [];
    if (r === "auto") {
        r = !1;
        t: for(let c = 0; c < h; c++)for(let u = 0; u < l; u++)if (i.get(c, u) < 0) {
            r = !0;
            break t;
        }
    }
    for(let c = 0; c < h; c++){
        let u = [];
        for(let g = 0; g < l; g++)u.push(Qe(i.get(c, g), e, r));
        a.push(`${u.join(" ")}`);
    }
    return l !== n && (a[a.length - 1] += ` ... ${n - s} more columns`), h !== o && a.push(`... ${o - t} more rows`), a.join(`
${fe}`);
}
function Qe(i, t, s) {
    return (i >= 0 && s ? ` ${re(i, t - 1)}` : re(i, t)).padEnd(t);
}
function re(i, t) {
    let s = i.toString();
    if (s.length <= t) return s;
    let e = i.toFixed(t);
    if (e.length > t && (e = i.toFixed(Math.max(0, t - (e.length - t)))), e.length <= t && !e.startsWith("0.000") && !e.startsWith("-0.000")) return e;
    let r = i.toExponential(t);
    return r.length > t && (r = i.toExponential(Math.max(0, t - (r.length - t)))), r.slice(0);
}
function Je(i, t) {
    i.prototype.add = function(e) {
        return typeof e == "number" ? this.addS(e) : this.addM(e);
    }, i.prototype.addS = function(e) {
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) + e);
        return this;
    }, i.prototype.addM = function(e) {
        if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError("Matrices dimensions must be equal");
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) + e.get(r, o));
        return this;
    }, i.add = function(e, r) {
        return new t(e).add(r);
    }, i.prototype.sub = function(e) {
        return typeof e == "number" ? this.subS(e) : this.subM(e);
    }, i.prototype.subS = function(e) {
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) - e);
        return this;
    }, i.prototype.subM = function(e) {
        if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError("Matrices dimensions must be equal");
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) - e.get(r, o));
        return this;
    }, i.sub = function(e, r) {
        return new t(e).sub(r);
    }, i.prototype.subtract = i.prototype.sub, i.prototype.subtractS = i.prototype.subS, i.prototype.subtractM = i.prototype.subM, i.subtract = i.sub, i.prototype.mul = function(e) {
        return typeof e == "number" ? this.mulS(e) : this.mulM(e);
    }, i.prototype.mulS = function(e) {
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) * e);
        return this;
    }, i.prototype.mulM = function(e) {
        if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError("Matrices dimensions must be equal");
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) * e.get(r, o));
        return this;
    }, i.mul = function(e, r) {
        return new t(e).mul(r);
    }, i.prototype.multiply = i.prototype.mul, i.prototype.multiplyS = i.prototype.mulS, i.prototype.multiplyM = i.prototype.mulM, i.multiply = i.mul, i.prototype.div = function(e) {
        return typeof e == "number" ? this.divS(e) : this.divM(e);
    }, i.prototype.divS = function(e) {
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) / e);
        return this;
    }, i.prototype.divM = function(e) {
        if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError("Matrices dimensions must be equal");
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) / e.get(r, o));
        return this;
    }, i.div = function(e, r) {
        return new t(e).div(r);
    }, i.prototype.divide = i.prototype.div, i.prototype.divideS = i.prototype.divS, i.prototype.divideM = i.prototype.divM, i.divide = i.div, i.prototype.mod = function(e) {
        return typeof e == "number" ? this.modS(e) : this.modM(e);
    }, i.prototype.modS = function(e) {
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) % e);
        return this;
    }, i.prototype.modM = function(e) {
        if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError("Matrices dimensions must be equal");
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) % e.get(r, o));
        return this;
    }, i.mod = function(e, r) {
        return new t(e).mod(r);
    }, i.prototype.modulus = i.prototype.mod, i.prototype.modulusS = i.prototype.modS, i.prototype.modulusM = i.prototype.modM, i.modulus = i.mod, i.prototype.and = function(e) {
        return typeof e == "number" ? this.andS(e) : this.andM(e);
    }, i.prototype.andS = function(e) {
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) & e);
        return this;
    }, i.prototype.andM = function(e) {
        if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError("Matrices dimensions must be equal");
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) & e.get(r, o));
        return this;
    }, i.and = function(e, r) {
        return new t(e).and(r);
    }, i.prototype.or = function(e) {
        return typeof e == "number" ? this.orS(e) : this.orM(e);
    }, i.prototype.orS = function(e) {
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) | e);
        return this;
    }, i.prototype.orM = function(e) {
        if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError("Matrices dimensions must be equal");
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) | e.get(r, o));
        return this;
    }, i.or = function(e, r) {
        return new t(e).or(r);
    }, i.prototype.xor = function(e) {
        return typeof e == "number" ? this.xorS(e) : this.xorM(e);
    }, i.prototype.xorS = function(e) {
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) ^ e);
        return this;
    }, i.prototype.xorM = function(e) {
        if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError("Matrices dimensions must be equal");
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) ^ e.get(r, o));
        return this;
    }, i.xor = function(e, r) {
        return new t(e).xor(r);
    }, i.prototype.leftShift = function(e) {
        return typeof e == "number" ? this.leftShiftS(e) : this.leftShiftM(e);
    }, i.prototype.leftShiftS = function(e) {
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) << e);
        return this;
    }, i.prototype.leftShiftM = function(e) {
        if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError("Matrices dimensions must be equal");
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) << e.get(r, o));
        return this;
    }, i.leftShift = function(e, r) {
        return new t(e).leftShift(r);
    }, i.prototype.signPropagatingRightShift = function(e) {
        return typeof e == "number" ? this.signPropagatingRightShiftS(e) : this.signPropagatingRightShiftM(e);
    }, i.prototype.signPropagatingRightShiftS = function(e) {
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) >> e);
        return this;
    }, i.prototype.signPropagatingRightShiftM = function(e) {
        if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError("Matrices dimensions must be equal");
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) >> e.get(r, o));
        return this;
    }, i.signPropagatingRightShift = function(e, r) {
        return new t(e).signPropagatingRightShift(r);
    }, i.prototype.rightShift = function(e) {
        return typeof e == "number" ? this.rightShiftS(e) : this.rightShiftM(e);
    }, i.prototype.rightShiftS = function(e) {
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) >>> e);
        return this;
    }, i.prototype.rightShiftM = function(e) {
        if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError("Matrices dimensions must be equal");
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, this.get(r, o) >>> e.get(r, o));
        return this;
    }, i.rightShift = function(e, r) {
        return new t(e).rightShift(r);
    }, i.prototype.zeroFillRightShift = i.prototype.rightShift, i.prototype.zeroFillRightShiftS = i.prototype.rightShiftS, i.prototype.zeroFillRightShiftM = i.prototype.rightShiftM, i.zeroFillRightShift = i.rightShift, i.prototype.not = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, ~this.get(e, r));
        return this;
    }, i.not = function(e) {
        return new t(e).not();
    }, i.prototype.abs = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.abs(this.get(e, r)));
        return this;
    }, i.abs = function(e) {
        return new t(e).abs();
    }, i.prototype.acos = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.acos(this.get(e, r)));
        return this;
    }, i.acos = function(e) {
        return new t(e).acos();
    }, i.prototype.acosh = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.acosh(this.get(e, r)));
        return this;
    }, i.acosh = function(e) {
        return new t(e).acosh();
    }, i.prototype.asin = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.asin(this.get(e, r)));
        return this;
    }, i.asin = function(e) {
        return new t(e).asin();
    }, i.prototype.asinh = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.asinh(this.get(e, r)));
        return this;
    }, i.asinh = function(e) {
        return new t(e).asinh();
    }, i.prototype.atan = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.atan(this.get(e, r)));
        return this;
    }, i.atan = function(e) {
        return new t(e).atan();
    }, i.prototype.atanh = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.atanh(this.get(e, r)));
        return this;
    }, i.atanh = function(e) {
        return new t(e).atanh();
    }, i.prototype.cbrt = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.cbrt(this.get(e, r)));
        return this;
    }, i.cbrt = function(e) {
        return new t(e).cbrt();
    }, i.prototype.ceil = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.ceil(this.get(e, r)));
        return this;
    }, i.ceil = function(e) {
        return new t(e).ceil();
    }, i.prototype.clz32 = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.clz32(this.get(e, r)));
        return this;
    }, i.clz32 = function(e) {
        return new t(e).clz32();
    }, i.prototype.cos = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.cos(this.get(e, r)));
        return this;
    }, i.cos = function(e) {
        return new t(e).cos();
    }, i.prototype.cosh = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.cosh(this.get(e, r)));
        return this;
    }, i.cosh = function(e) {
        return new t(e).cosh();
    }, i.prototype.exp = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.exp(this.get(e, r)));
        return this;
    }, i.exp = function(e) {
        return new t(e).exp();
    }, i.prototype.expm1 = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.expm1(this.get(e, r)));
        return this;
    }, i.expm1 = function(e) {
        return new t(e).expm1();
    }, i.prototype.floor = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.floor(this.get(e, r)));
        return this;
    }, i.floor = function(e) {
        return new t(e).floor();
    }, i.prototype.fround = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.fround(this.get(e, r)));
        return this;
    }, i.fround = function(e) {
        return new t(e).fround();
    }, i.prototype.log = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.log(this.get(e, r)));
        return this;
    }, i.log = function(e) {
        return new t(e).log();
    }, i.prototype.log1p = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.log1p(this.get(e, r)));
        return this;
    }, i.log1p = function(e) {
        return new t(e).log1p();
    }, i.prototype.log10 = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.log10(this.get(e, r)));
        return this;
    }, i.log10 = function(e) {
        return new t(e).log10();
    }, i.prototype.log2 = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.log2(this.get(e, r)));
        return this;
    }, i.log2 = function(e) {
        return new t(e).log2();
    }, i.prototype.round = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.round(this.get(e, r)));
        return this;
    }, i.round = function(e) {
        return new t(e).round();
    }, i.prototype.sign = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.sign(this.get(e, r)));
        return this;
    }, i.sign = function(e) {
        return new t(e).sign();
    }, i.prototype.sin = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.sin(this.get(e, r)));
        return this;
    }, i.sin = function(e) {
        return new t(e).sin();
    }, i.prototype.sinh = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.sinh(this.get(e, r)));
        return this;
    }, i.sinh = function(e) {
        return new t(e).sinh();
    }, i.prototype.sqrt = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.sqrt(this.get(e, r)));
        return this;
    }, i.sqrt = function(e) {
        return new t(e).sqrt();
    }, i.prototype.tan = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.tan(this.get(e, r)));
        return this;
    }, i.tan = function(e) {
        return new t(e).tan();
    }, i.prototype.tanh = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.tanh(this.get(e, r)));
        return this;
    }, i.tanh = function(e) {
        return new t(e).tanh();
    }, i.prototype.trunc = function() {
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.set(e, r, Math.trunc(this.get(e, r)));
        return this;
    }, i.trunc = function(e) {
        return new t(e).trunc();
    }, i.pow = function(e, r) {
        return new t(e).pow(r);
    }, i.prototype.pow = function(e) {
        return typeof e == "number" ? this.powS(e) : this.powM(e);
    }, i.prototype.powS = function(e) {
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, Math.pow(this.get(r, o), e));
        return this;
    }, i.prototype.powM = function(e) {
        if (e = t.checkMatrix(e), this.rows !== e.rows || this.columns !== e.columns) throw new RangeError("Matrices dimensions must be equal");
        for(let r = 0; r < this.rows; r++)for(let o = 0; o < this.columns; o++)this.set(r, o, Math.pow(this.get(r, o), e.get(r, o)));
        return this;
    };
}
function Q(i, t, s) {
    let e = s ? i.rows : i.rows - 1;
    if (t < 0 || t > e) throw new RangeError("Row index out of range");
}
function J(i, t, s) {
    let e = s ? i.columns : i.columns - 1;
    if (t < 0 || t > e) throw new RangeError("Column index out of range");
}
function wt(i, t) {
    if (t.to1DArray && (t = t.to1DArray()), t.length !== i.columns) throw new RangeError("vector size must be the same as the number of columns");
    return t;
}
function pt(i, t) {
    if (t.to1DArray && (t = t.to1DArray()), t.length !== i.rows) throw new RangeError("vector size must be the same as the number of rows");
    return t;
}
function Ht(i, t) {
    if (!U.isAnyArray(t)) throw new TypeError("row indices must be an array");
    for(let s = 0; s < t.length; s++)if (t[s] < 0 || t[s] >= i.rows) throw new RangeError("row indices are out of range");
}
function te(i, t) {
    if (!U.isAnyArray(t)) throw new TypeError("column indices must be an array");
    for(let s = 0; s < t.length; s++)if (t[s] < 0 || t[s] >= i.columns) throw new RangeError("column indices are out of range");
}
function Kt(i, t, s, e, r) {
    if (arguments.length !== 5) throw new RangeError("expected 4 arguments");
    if (Ct("startRow", t), Ct("endRow", s), Ct("startColumn", e), Ct("endColumn", r), t > s || e > r || t < 0 || t >= i.rows || s < 0 || s >= i.rows || e < 0 || e >= i.columns || r < 0 || r >= i.columns) throw new RangeError("Submatrix indices are out of range");
}
function Ut(i, t = 0) {
    let s = [];
    for(let e = 0; e < i; e++)s.push(t);
    return s;
}
function Ct(i, t) {
    if (typeof t != "number") throw new TypeError(`${i} must be a number`);
}
function gt(i) {
    if (i.isEmpty()) throw new Error("Empty matrix has no elements to index");
}
function Ke(i) {
    let t = Ut(i.rows);
    for(let s = 0; s < i.rows; ++s)for(let e = 0; e < i.columns; ++e)t[s] += i.get(s, e);
    return t;
}
function Ze(i) {
    let t = Ut(i.columns);
    for(let s = 0; s < i.rows; ++s)for(let e = 0; e < i.columns; ++e)t[e] += i.get(s, e);
    return t;
}
function Ae(i) {
    let t = 0;
    for(let s = 0; s < i.rows; s++)for(let e = 0; e < i.columns; e++)t += i.get(s, e);
    return t;
}
function xe(i) {
    let t = Ut(i.rows, 1);
    for(let s = 0; s < i.rows; ++s)for(let e = 0; e < i.columns; ++e)t[s] *= i.get(s, e);
    return t;
}
function He(i) {
    let t = Ut(i.columns, 1);
    for(let s = 0; s < i.rows; ++s)for(let e = 0; e < i.columns; ++e)t[e] *= i.get(s, e);
    return t;
}
function ts(i) {
    let t = 1;
    for(let s = 0; s < i.rows; s++)for(let e = 0; e < i.columns; e++)t *= i.get(s, e);
    return t;
}
function es(i, t, s) {
    const e = i.rows, r = i.columns, o = [];
    for(let n = 0; n < e; n++){
        let h = 0, l = 0, a = 0;
        for(let c = 0; c < r; c++)a = i.get(n, c) - s[n], h += a, l += a * a;
        t ? o.push((l - h * h / r) / (r - 1)) : o.push((l - h * h / r) / r);
    }
    return o;
}
function ss(i, t, s) {
    const e = i.rows, r = i.columns, o = [];
    for(let n = 0; n < r; n++){
        let h = 0, l = 0, a = 0;
        for(let c = 0; c < e; c++)a = i.get(c, n) - s[n], h += a, l += a * a;
        t ? o.push((l - h * h / e) / (e - 1)) : o.push((l - h * h / e) / e);
    }
    return o;
}
function rs(i, t, s) {
    const e = i.rows, r = i.columns, o = e * r;
    let n = 0, h = 0, l = 0;
    for(let a = 0; a < e; a++)for(let c = 0; c < r; c++)l = i.get(a, c) - s, n += l, h += l * l;
    return t ? (h - n * n / o) / (o - 1) : (h - n * n / o) / o;
}
function os(i, t) {
    for(let s = 0; s < i.rows; s++)for(let e = 0; e < i.columns; e++)i.set(s, e, i.get(s, e) - t[s]);
}
function is(i, t) {
    for(let s = 0; s < i.rows; s++)for(let e = 0; e < i.columns; e++)i.set(s, e, i.get(s, e) - t[e]);
}
function ns(i, t) {
    for(let s = 0; s < i.rows; s++)for(let e = 0; e < i.columns; e++)i.set(s, e, i.get(s, e) - t);
}
function hs(i) {
    const t = [];
    for(let s = 0; s < i.rows; s++){
        let e = 0;
        for(let r = 0; r < i.columns; r++)e += Math.pow(i.get(s, r), 2) / (i.columns - 1);
        t.push(Math.sqrt(e));
    }
    return t;
}
function ls(i, t) {
    for(let s = 0; s < i.rows; s++)for(let e = 0; e < i.columns; e++)i.set(s, e, i.get(s, e) / t[s]);
}
function as(i) {
    const t = [];
    for(let s = 0; s < i.columns; s++){
        let e = 0;
        for(let r = 0; r < i.rows; r++)e += Math.pow(i.get(r, s), 2) / (i.rows - 1);
        t.push(Math.sqrt(e));
    }
    return t;
}
function us(i, t) {
    for(let s = 0; s < i.rows; s++)for(let e = 0; e < i.columns; e++)i.set(s, e, i.get(s, e) / t[e]);
}
function fs(i) {
    const t = i.size - 1;
    let s = 0;
    for(let e = 0; e < i.columns; e++)for(let r = 0; r < i.rows; r++)s += Math.pow(i.get(r, e), 2) / t;
    return Math.sqrt(s);
}
function cs(i, t) {
    for(let s = 0; s < i.rows; s++)for(let e = 0; e < i.columns; e++)i.set(s, e, i.get(s, e) / t);
}
class I {
    static from1DArray(t, s, e) {
        if (t * s !== e.length) throw new RangeError("data length does not match given dimensions");
        let o = new P(t, s);
        for(let n = 0; n < t; n++)for(let h = 0; h < s; h++)o.set(n, h, e[n * s + h]);
        return o;
    }
    static rowVector(t) {
        let s = new P(1, t.length);
        for(let e = 0; e < t.length; e++)s.set(0, e, t[e]);
        return s;
    }
    static columnVector(t) {
        let s = new P(t.length, 1);
        for(let e = 0; e < t.length; e++)s.set(e, 0, t[e]);
        return s;
    }
    static zeros(t, s) {
        return new P(t, s);
    }
    static ones(t, s) {
        return new P(t, s).fill(1);
    }
    static rand(t, s, e = {}) {
        if (typeof e != "object") throw new TypeError("options must be an object");
        const { random: r = Math.random } = e;
        let o = new P(t, s);
        for(let n = 0; n < t; n++)for(let h = 0; h < s; h++)o.set(n, h, r());
        return o;
    }
    static randInt(t, s, e = {}) {
        if (typeof e != "object") throw new TypeError("options must be an object");
        const { min: r = 0, max: o = 1e3, random: n = Math.random } = e;
        if (!Number.isInteger(r)) throw new TypeError("min must be an integer");
        if (!Number.isInteger(o)) throw new TypeError("max must be an integer");
        if (r >= o) throw new RangeError("min must be smaller than max");
        let h = o - r, l = new P(t, s);
        for(let a = 0; a < t; a++)for(let c = 0; c < s; c++){
            let u = r + Math.round(n() * h);
            l.set(a, c, u);
        }
        return l;
    }
    static eye(t, s, e) {
        s === void 0 && (s = t), e === void 0 && (e = 1);
        let r = Math.min(t, s), o = this.zeros(t, s);
        for(let n = 0; n < r; n++)o.set(n, n, e);
        return o;
    }
    static diag(t, s, e) {
        let r = t.length;
        s === void 0 && (s = r), e === void 0 && (e = s);
        let o = Math.min(r, s, e), n = this.zeros(s, e);
        for(let h = 0; h < o; h++)n.set(h, h, t[h]);
        return n;
    }
    static min(t, s) {
        t = this.checkMatrix(t), s = this.checkMatrix(s);
        let e = t.rows, r = t.columns, o = new P(e, r);
        for(let n = 0; n < e; n++)for(let h = 0; h < r; h++)o.set(n, h, Math.min(t.get(n, h), s.get(n, h)));
        return o;
    }
    static max(t, s) {
        t = this.checkMatrix(t), s = this.checkMatrix(s);
        let e = t.rows, r = t.columns, o = new this(e, r);
        for(let n = 0; n < e; n++)for(let h = 0; h < r; h++)o.set(n, h, Math.max(t.get(n, h), s.get(n, h)));
        return o;
    }
    static checkMatrix(t) {
        return I.isMatrix(t) ? t : new P(t);
    }
    static isMatrix(t) {
        return t != null && t.klass === "Matrix";
    }
    get size() {
        return this.rows * this.columns;
    }
    apply(t) {
        if (typeof t != "function") throw new TypeError("callback must be a function");
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < this.columns; e++)t.call(this, s, e);
        return this;
    }
    to1DArray() {
        let t = [];
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < this.columns; e++)t.push(this.get(s, e));
        return t;
    }
    to2DArray() {
        let t = [];
        for(let s = 0; s < this.rows; s++){
            t.push([]);
            for(let e = 0; e < this.columns; e++)t[s].push(this.get(s, e));
        }
        return t;
    }
    toJSON() {
        return this.to2DArray();
    }
    isRowVector() {
        return this.rows === 1;
    }
    isColumnVector() {
        return this.columns === 1;
    }
    isVector() {
        return this.rows === 1 || this.columns === 1;
    }
    isSquare() {
        return this.rows === this.columns;
    }
    isEmpty() {
        return this.rows === 0 || this.columns === 0;
    }
    isSymmetric() {
        if (this.isSquare()) {
            for(let t = 0; t < this.rows; t++)for(let s = 0; s <= t; s++)if (this.get(t, s) !== this.get(s, t)) return !1;
            return !0;
        }
        return !1;
    }
    isDistance() {
        if (!this.isSymmetric()) return !1;
        for(let t = 0; t < this.rows; t++)if (this.get(t, t) !== 0) return !1;
        return !0;
    }
    isEchelonForm() {
        let t = 0, s = 0, e = -1, r = !0, o = !1;
        for(; t < this.rows && r;){
            for(s = 0, o = !1; s < this.columns && o === !1;)this.get(t, s) === 0 ? s++ : this.get(t, s) === 1 && s > e ? (o = !0, e = s) : (r = !1, o = !0);
            t++;
        }
        return r;
    }
    isReducedEchelonForm() {
        let t = 0, s = 0, e = -1, r = !0, o = !1;
        for(; t < this.rows && r;){
            for(s = 0, o = !1; s < this.columns && o === !1;)this.get(t, s) === 0 ? s++ : this.get(t, s) === 1 && s > e ? (o = !0, e = s) : (r = !1, o = !0);
            for(let n = s + 1; n < this.rows; n++)this.get(t, n) !== 0 && (r = !1);
            t++;
        }
        return r;
    }
    echelonForm() {
        let t = this.clone(), s = 0, e = 0;
        for(; s < t.rows && e < t.columns;){
            let r = s;
            for(let o = s; o < t.rows; o++)t.get(o, e) > t.get(r, e) && (r = o);
            if (t.get(r, e) === 0) e++;
            else {
                t.swapRows(s, r);
                let o = t.get(s, e);
                for(let n = e; n < t.columns; n++)t.set(s, n, t.get(s, n) / o);
                for(let n = s + 1; n < t.rows; n++){
                    let h = t.get(n, e) / t.get(s, e);
                    t.set(n, e, 0);
                    for(let l = e + 1; l < t.columns; l++)t.set(n, l, t.get(n, l) - t.get(s, l) * h);
                }
                s++, e++;
            }
        }
        return t;
    }
    reducedEchelonForm() {
        let t = this.echelonForm(), s = t.columns, e = t.rows, r = e - 1;
        for(; r >= 0;)if (t.maxRow(r) === 0) r--;
        else {
            let o = 0, n = !1;
            for(; o < e && n === !1;)t.get(r, o) === 1 ? n = !0 : o++;
            for(let h = 0; h < r; h++){
                let l = t.get(h, o);
                for(let a = o; a < s; a++){
                    let c = t.get(h, a) - l * t.get(r, a);
                    t.set(h, a, c);
                }
            }
            r--;
        }
        return t;
    }
    set() {
        throw new Error("set method is unimplemented");
    }
    get() {
        throw new Error("get method is unimplemented");
    }
    repeat(t = {}) {
        if (typeof t != "object") throw new TypeError("options must be an object");
        const { rows: s = 1, columns: e = 1 } = t;
        if (!Number.isInteger(s) || s <= 0) throw new TypeError("rows must be a positive integer");
        if (!Number.isInteger(e) || e <= 0) throw new TypeError("columns must be a positive integer");
        let r = new P(this.rows * s, this.columns * e);
        for(let o = 0; o < s; o++)for(let n = 0; n < e; n++)r.setSubMatrix(this, this.rows * o, this.columns * n);
        return r;
    }
    fill(t) {
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < this.columns; e++)this.set(s, e, t);
        return this;
    }
    neg() {
        return this.mulS(-1);
    }
    getRow(t) {
        Q(this, t);
        let s = [];
        for(let e = 0; e < this.columns; e++)s.push(this.get(t, e));
        return s;
    }
    getRowVector(t) {
        return P.rowVector(this.getRow(t));
    }
    setRow(t, s) {
        Q(this, t), s = wt(this, s);
        for(let e = 0; e < this.columns; e++)this.set(t, e, s[e]);
        return this;
    }
    swapRows(t, s) {
        Q(this, t), Q(this, s);
        for(let e = 0; e < this.columns; e++){
            let r = this.get(t, e);
            this.set(t, e, this.get(s, e)), this.set(s, e, r);
        }
        return this;
    }
    getColumn(t) {
        J(this, t);
        let s = [];
        for(let e = 0; e < this.rows; e++)s.push(this.get(e, t));
        return s;
    }
    getColumnVector(t) {
        return P.columnVector(this.getColumn(t));
    }
    setColumn(t, s) {
        J(this, t), s = pt(this, s);
        for(let e = 0; e < this.rows; e++)this.set(e, t, s[e]);
        return this;
    }
    swapColumns(t, s) {
        J(this, t), J(this, s);
        for(let e = 0; e < this.rows; e++){
            let r = this.get(e, t);
            this.set(e, t, this.get(e, s)), this.set(e, s, r);
        }
        return this;
    }
    addRowVector(t) {
        t = wt(this, t);
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < this.columns; e++)this.set(s, e, this.get(s, e) + t[e]);
        return this;
    }
    subRowVector(t) {
        t = wt(this, t);
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < this.columns; e++)this.set(s, e, this.get(s, e) - t[e]);
        return this;
    }
    mulRowVector(t) {
        t = wt(this, t);
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < this.columns; e++)this.set(s, e, this.get(s, e) * t[e]);
        return this;
    }
    divRowVector(t) {
        t = wt(this, t);
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < this.columns; e++)this.set(s, e, this.get(s, e) / t[e]);
        return this;
    }
    addColumnVector(t) {
        t = pt(this, t);
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < this.columns; e++)this.set(s, e, this.get(s, e) + t[s]);
        return this;
    }
    subColumnVector(t) {
        t = pt(this, t);
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < this.columns; e++)this.set(s, e, this.get(s, e) - t[s]);
        return this;
    }
    mulColumnVector(t) {
        t = pt(this, t);
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < this.columns; e++)this.set(s, e, this.get(s, e) * t[s]);
        return this;
    }
    divColumnVector(t) {
        t = pt(this, t);
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < this.columns; e++)this.set(s, e, this.get(s, e) / t[s]);
        return this;
    }
    mulRow(t, s) {
        Q(this, t);
        for(let e = 0; e < this.columns; e++)this.set(t, e, this.get(t, e) * s);
        return this;
    }
    mulColumn(t, s) {
        J(this, t);
        for(let e = 0; e < this.rows; e++)this.set(e, t, this.get(e, t) * s);
        return this;
    }
    max(t) {
        if (this.isEmpty()) return NaN;
        switch(t){
            case "row":
                {
                    const s = new Array(this.rows).fill(Number.NEGATIVE_INFINITY);
                    for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.get(e, r) > s[e] && (s[e] = this.get(e, r));
                    return s;
                }
            case "column":
                {
                    const s = new Array(this.columns).fill(Number.NEGATIVE_INFINITY);
                    for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.get(e, r) > s[r] && (s[r] = this.get(e, r));
                    return s;
                }
            case void 0:
                {
                    let s = this.get(0, 0);
                    for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.get(e, r) > s && (s = this.get(e, r));
                    return s;
                }
            default:
                throw new Error(`invalid option: ${t}`);
        }
    }
    maxIndex() {
        gt(this);
        let t = this.get(0, 0), s = [
            0,
            0
        ];
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.get(e, r) > t && (t = this.get(e, r), s[0] = e, s[1] = r);
        return s;
    }
    min(t) {
        if (this.isEmpty()) return NaN;
        switch(t){
            case "row":
                {
                    const s = new Array(this.rows).fill(Number.POSITIVE_INFINITY);
                    for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.get(e, r) < s[e] && (s[e] = this.get(e, r));
                    return s;
                }
            case "column":
                {
                    const s = new Array(this.columns).fill(Number.POSITIVE_INFINITY);
                    for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.get(e, r) < s[r] && (s[r] = this.get(e, r));
                    return s;
                }
            case void 0:
                {
                    let s = this.get(0, 0);
                    for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.get(e, r) < s && (s = this.get(e, r));
                    return s;
                }
            default:
                throw new Error(`invalid option: ${t}`);
        }
    }
    minIndex() {
        gt(this);
        let t = this.get(0, 0), s = [
            0,
            0
        ];
        for(let e = 0; e < this.rows; e++)for(let r = 0; r < this.columns; r++)this.get(e, r) < t && (t = this.get(e, r), s[0] = e, s[1] = r);
        return s;
    }
    maxRow(t) {
        if (Q(this, t), this.isEmpty()) return NaN;
        let s = this.get(t, 0);
        for(let e = 1; e < this.columns; e++)this.get(t, e) > s && (s = this.get(t, e));
        return s;
    }
    maxRowIndex(t) {
        Q(this, t), gt(this);
        let s = this.get(t, 0), e = [
            t,
            0
        ];
        for(let r = 1; r < this.columns; r++)this.get(t, r) > s && (s = this.get(t, r), e[1] = r);
        return e;
    }
    minRow(t) {
        if (Q(this, t), this.isEmpty()) return NaN;
        let s = this.get(t, 0);
        for(let e = 1; e < this.columns; e++)this.get(t, e) < s && (s = this.get(t, e));
        return s;
    }
    minRowIndex(t) {
        Q(this, t), gt(this);
        let s = this.get(t, 0), e = [
            t,
            0
        ];
        for(let r = 1; r < this.columns; r++)this.get(t, r) < s && (s = this.get(t, r), e[1] = r);
        return e;
    }
    maxColumn(t) {
        if (J(this, t), this.isEmpty()) return NaN;
        let s = this.get(0, t);
        for(let e = 1; e < this.rows; e++)this.get(e, t) > s && (s = this.get(e, t));
        return s;
    }
    maxColumnIndex(t) {
        J(this, t), gt(this);
        let s = this.get(0, t), e = [
            0,
            t
        ];
        for(let r = 1; r < this.rows; r++)this.get(r, t) > s && (s = this.get(r, t), e[0] = r);
        return e;
    }
    minColumn(t) {
        if (J(this, t), this.isEmpty()) return NaN;
        let s = this.get(0, t);
        for(let e = 1; e < this.rows; e++)this.get(e, t) < s && (s = this.get(e, t));
        return s;
    }
    minColumnIndex(t) {
        J(this, t), gt(this);
        let s = this.get(0, t), e = [
            0,
            t
        ];
        for(let r = 1; r < this.rows; r++)this.get(r, t) < s && (s = this.get(r, t), e[0] = r);
        return e;
    }
    diag() {
        let t = Math.min(this.rows, this.columns), s = [];
        for(let e = 0; e < t; e++)s.push(this.get(e, e));
        return s;
    }
    norm(t = "frobenius") {
        switch(t){
            case "max":
                return this.max();
            case "frobenius":
                return Math.sqrt(this.dot(this));
            default:
                throw new RangeError(`unknown norm type: ${t}`);
        }
    }
    cumulativeSum() {
        let t = 0;
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < this.columns; e++)t += this.get(s, e), this.set(s, e, t);
        return this;
    }
    dot(t) {
        I.isMatrix(t) && (t = t.to1DArray());
        let s = this.to1DArray();
        if (s.length !== t.length) throw new RangeError("vectors do not have the same size");
        let e = 0;
        for(let r = 0; r < s.length; r++)e += s[r] * t[r];
        return e;
    }
    mmul(t) {
        t = P.checkMatrix(t);
        let s = this.rows, e = this.columns, r = t.columns, o = new P(s, r), n = new Float64Array(e);
        for(let h = 0; h < r; h++){
            for(let l = 0; l < e; l++)n[l] = t.get(l, h);
            for(let l = 0; l < s; l++){
                let a = 0;
                for(let c = 0; c < e; c++)a += this.get(l, c) * n[c];
                o.set(l, h, a);
            }
        }
        return o;
    }
    strassen2x2(t) {
        t = P.checkMatrix(t);
        let s = new P(2, 2);
        const e = this.get(0, 0), r = t.get(0, 0), o = this.get(0, 1), n = t.get(0, 1), h = this.get(1, 0), l = t.get(1, 0), a = this.get(1, 1), c = t.get(1, 1), u = (e + a) * (r + c), g = (h + a) * r, y = e * (n - c), w = a * (l - r), p = (e + o) * c, v = (h - e) * (r + n), f = (o - a) * (l + c), M = u + w - p + f, k = y + p, F = g + w, G = u - g + y + v;
        return s.set(0, 0, M), s.set(0, 1, k), s.set(1, 0, F), s.set(1, 1, G), s;
    }
    strassen3x3(t) {
        t = P.checkMatrix(t);
        let s = new P(3, 3);
        const e = this.get(0, 0), r = this.get(0, 1), o = this.get(0, 2), n = this.get(1, 0), h = this.get(1, 1), l = this.get(1, 2), a = this.get(2, 0), c = this.get(2, 1), u = this.get(2, 2), g = t.get(0, 0), y = t.get(0, 1), w = t.get(0, 2), p = t.get(1, 0), v = t.get(1, 1), f = t.get(1, 2), M = t.get(2, 0), k = t.get(2, 1), F = t.get(2, 2), G = (e + r + o - n - h - c - u) * v, B = (e - n) * (-y + v), b = h * (-g + y + p - v - f - M + F), S = (-e + n + h) * (g - y + v), C = (n + h) * (-g + y), m = e * g, d = (-e + a + c) * (g - w + f), E = (-e + a) * (w - f), j = (a + c) * (-g + w), $ = (e + r + o - h - l - a - c) * f, R = c * (-g + w + p - v - f - M + k), N = (-o + c + u) * (v + M - k), L = (o - u) * (v - k), O = o * M, Z = (c + u) * (-M + k), z = (-o + h + l) * (f + M - F), A = (o - l) * (f - F), x = (h + l) * (-M + F), D = r * p, W = l * k, Y = n * w, _ = a * y, V = u * F, Ee = m + O + D, ke = G + S + C + m + N + O + Z, be = m + d + j + $ + O + z + x, Se = B + b + S + m + O + z + A, Fe = B + S + C + m + W, Ge = O + z + A + x + Y, Ie = m + d + E + R + N + L + O, Te = N + L + O + Z + _, De = m + d + E + j + V;
        return s.set(0, 0, Ee), s.set(0, 1, ke), s.set(0, 2, be), s.set(1, 0, Se), s.set(1, 1, Fe), s.set(1, 2, Ge), s.set(2, 0, Ie), s.set(2, 1, Te), s.set(2, 2, De), s;
    }
    mmulStrassen(t) {
        t = P.checkMatrix(t);
        let s = this.clone(), e = s.rows, r = s.columns, o = t.rows, n = t.columns;
        r !== o && console.warn(`Multiplying ${e} x ${r} and ${o} x ${n} matrix: dimensions do not match.`);
        function h(u, g, y) {
            let w = u.rows, p = u.columns;
            if (w === g && p === y) return u;
            {
                let v = I.zeros(g, y);
                return v = v.setSubMatrix(u, 0, 0), v;
            }
        }
        let l = Math.max(e, o), a = Math.max(r, n);
        s = h(s, l, a), t = h(t, l, a);
        function c(u, g, y, w) {
            if (y <= 512 || w <= 512) return u.mmul(g);
            y % 2 === 1 && w % 2 === 1 ? (u = h(u, y + 1, w + 1), g = h(g, y + 1, w + 1)) : y % 2 === 1 ? (u = h(u, y + 1, w), g = h(g, y + 1, w)) : w % 2 === 1 && (u = h(u, y, w + 1), g = h(g, y, w + 1));
            let p = parseInt(u.rows / 2, 10), v = parseInt(u.columns / 2, 10), f = u.subMatrix(0, p - 1, 0, v - 1), M = g.subMatrix(0, p - 1, 0, v - 1), k = u.subMatrix(0, p - 1, v, u.columns - 1), F = g.subMatrix(0, p - 1, v, g.columns - 1), G = u.subMatrix(p, u.rows - 1, 0, v - 1), B = g.subMatrix(p, g.rows - 1, 0, v - 1), b = u.subMatrix(p, u.rows - 1, v, u.columns - 1), S = g.subMatrix(p, g.rows - 1, v, g.columns - 1), C = c(I.add(f, b), I.add(M, S), p, v), m = c(I.add(G, b), M, p, v), d = c(f, I.sub(F, S), p, v), E = c(b, I.sub(B, M), p, v), j = c(I.add(f, k), S, p, v), $ = c(I.sub(G, f), I.add(M, F), p, v), R = c(I.sub(k, b), I.add(B, S), p, v), N = I.add(C, E);
            N.sub(j), N.add(R);
            let L = I.add(d, j), O = I.add(m, E), Z = I.sub(C, m);
            Z.add(d), Z.add($);
            let z = I.zeros(2 * N.rows, 2 * N.columns);
            return z = z.setSubMatrix(N, 0, 0), z = z.setSubMatrix(L, N.rows, 0), z = z.setSubMatrix(O, 0, N.columns), z = z.setSubMatrix(Z, N.rows, N.columns), z.subMatrix(0, y - 1, 0, w - 1);
        }
        return c(s, t, l, a);
    }
    scaleRows(t = {}) {
        if (typeof t != "object") throw new TypeError("options must be an object");
        const { min: s = 0, max: e = 1 } = t;
        if (!Number.isFinite(s)) throw new TypeError("min must be a number");
        if (!Number.isFinite(e)) throw new TypeError("max must be a number");
        if (s >= e) throw new RangeError("min must be smaller than max");
        let r = new P(this.rows, this.columns);
        for(let o = 0; o < this.rows; o++){
            const n = this.getRow(o);
            n.length > 0 && se(n, {
                min: s,
                max: e,
                output: n
            }), r.setRow(o, n);
        }
        return r;
    }
    scaleColumns(t = {}) {
        if (typeof t != "object") throw new TypeError("options must be an object");
        const { min: s = 0, max: e = 1 } = t;
        if (!Number.isFinite(s)) throw new TypeError("min must be a number");
        if (!Number.isFinite(e)) throw new TypeError("max must be a number");
        if (s >= e) throw new RangeError("min must be smaller than max");
        let r = new P(this.rows, this.columns);
        for(let o = 0; o < this.columns; o++){
            const n = this.getColumn(o);
            n.length && se(n, {
                min: s,
                max: e,
                output: n
            }), r.setColumn(o, n);
        }
        return r;
    }
    flipRows() {
        const t = Math.ceil(this.columns / 2);
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < t; e++){
            let r = this.get(s, e), o = this.get(s, this.columns - 1 - e);
            this.set(s, e, o), this.set(s, this.columns - 1 - e, r);
        }
        return this;
    }
    flipColumns() {
        const t = Math.ceil(this.rows / 2);
        for(let s = 0; s < this.columns; s++)for(let e = 0; e < t; e++){
            let r = this.get(e, s), o = this.get(this.rows - 1 - e, s);
            this.set(e, s, o), this.set(this.rows - 1 - e, s, r);
        }
        return this;
    }
    kroneckerProduct(t) {
        t = P.checkMatrix(t);
        let s = this.rows, e = this.columns, r = t.rows, o = t.columns, n = new P(s * r, e * o);
        for(let h = 0; h < s; h++)for(let l = 0; l < e; l++)for(let a = 0; a < r; a++)for(let c = 0; c < o; c++)n.set(r * h + a, o * l + c, this.get(h, l) * t.get(a, c));
        return n;
    }
    kroneckerSum(t) {
        if (t = P.checkMatrix(t), !this.isSquare() || !t.isSquare()) throw new Error("Kronecker Sum needs two Square Matrices");
        let s = this.rows, e = t.rows, r = this.kroneckerProduct(P.eye(e, e)), o = P.eye(s, s).kroneckerProduct(t);
        return r.add(o);
    }
    transpose() {
        let t = new P(this.columns, this.rows);
        for(let s = 0; s < this.rows; s++)for(let e = 0; e < this.columns; e++)t.set(e, s, this.get(s, e));
        return t;
    }
    sortRows(t = oe) {
        for(let s = 0; s < this.rows; s++)this.setRow(s, this.getRow(s).sort(t));
        return this;
    }
    sortColumns(t = oe) {
        for(let s = 0; s < this.columns; s++)this.setColumn(s, this.getColumn(s).sort(t));
        return this;
    }
    subMatrix(t, s, e, r) {
        Kt(this, t, s, e, r);
        let o = new P(s - t + 1, r - e + 1);
        for(let n = t; n <= s; n++)for(let h = e; h <= r; h++)o.set(n - t, h - e, this.get(n, h));
        return o;
    }
    subMatrixRow(t, s, e) {
        if (s === void 0 && (s = 0), e === void 0 && (e = this.columns - 1), s > e || s < 0 || s >= this.columns || e < 0 || e >= this.columns) throw new RangeError("Argument out of range");
        let r = new P(t.length, e - s + 1);
        for(let o = 0; o < t.length; o++)for(let n = s; n <= e; n++){
            if (t[o] < 0 || t[o] >= this.rows) throw new RangeError(`Row index out of range: ${t[o]}`);
            r.set(o, n - s, this.get(t[o], n));
        }
        return r;
    }
    subMatrixColumn(t, s, e) {
        if (s === void 0 && (s = 0), e === void 0 && (e = this.rows - 1), s > e || s < 0 || s >= this.rows || e < 0 || e >= this.rows) throw new RangeError("Argument out of range");
        let r = new P(e - s + 1, t.length);
        for(let o = 0; o < t.length; o++)for(let n = s; n <= e; n++){
            if (t[o] < 0 || t[o] >= this.columns) throw new RangeError(`Column index out of range: ${t[o]}`);
            r.set(n - s, o, this.get(n, t[o]));
        }
        return r;
    }
    setSubMatrix(t, s, e) {
        if (t = P.checkMatrix(t), t.isEmpty()) return this;
        let r = s + t.rows - 1, o = e + t.columns - 1;
        Kt(this, s, r, e, o);
        for(let n = 0; n < t.rows; n++)for(let h = 0; h < t.columns; h++)this.set(s + n, e + h, t.get(n, h));
        return this;
    }
    selection(t, s) {
        Ht(this, t), te(this, s);
        let e = new P(t.length, s.length);
        for(let r = 0; r < t.length; r++){
            let o = t[r];
            for(let n = 0; n < s.length; n++){
                let h = s[n];
                e.set(r, n, this.get(o, h));
            }
        }
        return e;
    }
    trace() {
        let t = Math.min(this.rows, this.columns), s = 0;
        for(let e = 0; e < t; e++)s += this.get(e, e);
        return s;
    }
    clone() {
        return this.constructor.copy(this, new P(this.rows, this.columns));
    }
    /**
   * @template {AbstractMatrix} M
   * @param {AbstractMatrix} from
   * @param {M} to
   * @return {M}
   */ static copy(t, s) {
        for (const [e, r, o] of t.entries())s.set(e, r, o);
        return s;
    }
    sum(t) {
        switch(t){
            case "row":
                return Ke(this);
            case "column":
                return Ze(this);
            case void 0:
                return Ae(this);
            default:
                throw new Error(`invalid option: ${t}`);
        }
    }
    product(t) {
        switch(t){
            case "row":
                return xe(this);
            case "column":
                return He(this);
            case void 0:
                return ts(this);
            default:
                throw new Error(`invalid option: ${t}`);
        }
    }
    mean(t) {
        const s = this.sum(t);
        switch(t){
            case "row":
                {
                    for(let e = 0; e < this.rows; e++)s[e] /= this.columns;
                    return s;
                }
            case "column":
                {
                    for(let e = 0; e < this.columns; e++)s[e] /= this.rows;
                    return s;
                }
            case void 0:
                return s / this.size;
            default:
                throw new Error(`invalid option: ${t}`);
        }
    }
    variance(t, s = {}) {
        if (typeof t == "object" && (s = t, t = void 0), typeof s != "object") throw new TypeError("options must be an object");
        const { unbiased: e = !0, mean: r = this.mean(t) } = s;
        if (typeof e != "boolean") throw new TypeError("unbiased must be a boolean");
        switch(t){
            case "row":
                {
                    if (!U.isAnyArray(r)) throw new TypeError("mean must be an array");
                    return es(this, e, r);
                }
            case "column":
                {
                    if (!U.isAnyArray(r)) throw new TypeError("mean must be an array");
                    return ss(this, e, r);
                }
            case void 0:
                {
                    if (typeof r != "number") throw new TypeError("mean must be a number");
                    return rs(this, e, r);
                }
            default:
                throw new Error(`invalid option: ${t}`);
        }
    }
    standardDeviation(t, s) {
        typeof t == "object" && (s = t, t = void 0);
        const e = this.variance(t, s);
        if (t === void 0) return Math.sqrt(e);
        for(let r = 0; r < e.length; r++)e[r] = Math.sqrt(e[r]);
        return e;
    }
    center(t, s = {}) {
        if (typeof t == "object" && (s = t, t = void 0), typeof s != "object") throw new TypeError("options must be an object");
        const { center: e = this.mean(t) } = s;
        switch(t){
            case "row":
                {
                    if (!U.isAnyArray(e)) throw new TypeError("center must be an array");
                    return os(this, e), this;
                }
            case "column":
                {
                    if (!U.isAnyArray(e)) throw new TypeError("center must be an array");
                    return is(this, e), this;
                }
            case void 0:
                {
                    if (typeof e != "number") throw new TypeError("center must be a number");
                    return ns(this, e), this;
                }
            default:
                throw new Error(`invalid option: ${t}`);
        }
    }
    scale(t, s = {}) {
        if (typeof t == "object" && (s = t, t = void 0), typeof s != "object") throw new TypeError("options must be an object");
        let e = s.scale;
        switch(t){
            case "row":
                {
                    if (e === void 0) e = hs(this);
                    else if (!U.isAnyArray(e)) throw new TypeError("scale must be an array");
                    return ls(this, e), this;
                }
            case "column":
                {
                    if (e === void 0) e = as(this);
                    else if (!U.isAnyArray(e)) throw new TypeError("scale must be an array");
                    return us(this, e), this;
                }
            case void 0:
                {
                    if (e === void 0) e = fs(this);
                    else if (typeof e != "number") throw new TypeError("scale must be a number");
                    return cs(this, e), this;
                }
            default:
                throw new Error(`invalid option: ${t}`);
        }
    }
    toString(t) {
        return ce(this, t);
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    /**
   * iterator from left to right, from top to bottom
   * yield [row, column, value]
   * @returns {Generator<[number, number, number], void, *>}
   */ *entries() {
        for(let t = 0; t < this.rows; t++)for(let s = 0; s < this.columns; s++)yield [
            t,
            s,
            this.get(t, s)
        ];
    }
    /**
   * iterator from left to right, from top to bottom
   * yield value
   * @returns {Generator<number, void, *>}
   */ *values() {
        for(let t = 0; t < this.rows; t++)for(let s = 0; s < this.columns; s++)yield this.get(t, s);
    }
}
I.prototype.klass = "Matrix";
typeof Symbol < "u" && (I.prototype[Symbol.for("nodejs.util.inspect.custom")] = _e);
function oe(i, t) {
    return i - t;
}
function ms(i) {
    return i.every((t)=>typeof t == "number");
}
I.random = I.rand;
I.randomInt = I.randInt;
I.diagonal = I.diag;
I.prototype.diagonal = I.prototype.diag;
I.identity = I.eye;
I.prototype.negate = I.prototype.neg;
I.prototype.tensorProduct = I.prototype.kroneckerProduct;
let P = class Zt extends I {
    /**
   * @type {Float64Array[]}
   */ data;
    /**
   * Init an empty matrix
   * @param {number} nRows
   * @param {number} nColumns
   */ #t(t, s) {
        if (this.data = [], Number.isInteger(s) && s >= 0) for(let e = 0; e < t; e++)this.data.push(new Float64Array(s));
        else throw new TypeError("nColumns must be a positive integer");
        this.rows = t, this.columns = s;
    }
    constructor(t, s){
        if (super(), Zt.isMatrix(t)) this.#t(t.rows, t.columns), Zt.copy(t, this);
        else if (Number.isInteger(t) && t >= 0) this.#t(t, s);
        else if (U.isAnyArray(t)) {
            const e = t;
            if (t = e.length, s = t ? e[0].length : 0, typeof s != "number") throw new TypeError("Data must be a 2D array with at least one element");
            this.data = [];
            for(let r = 0; r < t; r++){
                if (e[r].length !== s) throw new RangeError("Inconsistent array dimensions");
                if (!ms(e[r])) throw new TypeError("Input data contains non-numeric values");
                this.data.push(Float64Array.from(e[r]));
            }
            this.rows = t, this.columns = s;
        } else throw new TypeError("First argument must be a positive number or an array");
    }
    set(t, s, e) {
        return this.data[t][s] = e, this;
    }
    get(t, s) {
        return this.data[t][s];
    }
    removeRow(t) {
        return Q(this, t), this.data.splice(t, 1), this.rows -= 1, this;
    }
    addRow(t, s) {
        return s === void 0 && (s = t, t = this.rows), Q(this, t, !0), s = Float64Array.from(wt(this, s)), this.data.splice(t, 0, s), this.rows += 1, this;
    }
    removeColumn(t) {
        J(this, t);
        for(let s = 0; s < this.rows; s++){
            const e = new Float64Array(this.columns - 1);
            for(let r = 0; r < t; r++)e[r] = this.data[s][r];
            for(let r = t + 1; r < this.columns; r++)e[r - 1] = this.data[s][r];
            this.data[s] = e;
        }
        return this.columns -= 1, this;
    }
    addColumn(t, s) {
        typeof s > "u" && (s = t, t = this.columns), J(this, t, !0), s = pt(this, s);
        for(let e = 0; e < this.rows; e++){
            const r = new Float64Array(this.columns + 1);
            let o = 0;
            for(; o < t; o++)r[o] = this.data[e][o];
            for(r[o++] = s[e]; o < this.columns + 1; o++)r[o] = this.data[e][o - 1];
            this.data[e] = r;
        }
        return this.columns += 1, this;
    }
};
Je(I, P);
class mt extends I {
    /** @type {Matrix} */ #t;
    get size() {
        return this.#t.size;
    }
    get rows() {
        return this.#t.rows;
    }
    get columns() {
        return this.#t.columns;
    }
    get diagonalSize() {
        return this.rows;
    }
    /**
   * not the same as matrix.isSymmetric()
   * Here is to check if it's instanceof SymmetricMatrix without bundling issues
   *
   * @param value
   * @returns {boolean}
   */ static isSymmetricMatrix(t) {
        return P.isMatrix(t) && t.klassType === "SymmetricMatrix";
    }
    /**
   * @param diagonalSize
   * @return {SymmetricMatrix}
   */ static zeros(t) {
        return new this(t);
    }
    /**
   * @param diagonalSize
   * @return {SymmetricMatrix}
   */ static ones(t) {
        return new this(t).fill(1);
    }
    /**
   * @param {number | AbstractMatrix | ArrayLike<ArrayLike<number>>} diagonalSize
   * @return {this}
   */ constructor(t){
        if (super(), P.isMatrix(t)) {
            if (!t.isSymmetric()) throw new TypeError("not symmetric data");
            this.#t = P.copy(t, new P(t.rows, t.rows));
        } else if (Number.isInteger(t) && t >= 0) this.#t = new P(t, t);
        else if (this.#t = new P(t), !this.isSymmetric()) throw new TypeError("not symmetric data");
    }
    clone() {
        const t = new mt(this.diagonalSize);
        for (const [s, e, r] of this.upperRightEntries())t.set(s, e, r);
        return t;
    }
    toMatrix() {
        return new P(this);
    }
    get(t, s) {
        return this.#t.get(t, s);
    }
    set(t, s, e) {
        return this.#t.set(t, s, e), this.#t.set(s, t, e), this;
    }
    removeCross(t) {
        return this.#t.removeRow(t), this.#t.removeColumn(t), this;
    }
    addCross(t, s) {
        s === void 0 && (s = t, t = this.diagonalSize);
        const e = s.slice();
        return e.splice(t, 1), this.#t.addRow(t, e), this.#t.addColumn(t, s), this;
    }
    /**
   * @param {Mask[]} mask
   */ applyMask(t) {
        if (t.length !== this.diagonalSize) throw new RangeError("Mask size do not match with matrix size");
        const s = [];
        for (const [e, r] of t.entries())r || s.push(e);
        s.reverse();
        for (const e of s)this.removeCross(e);
        return this;
    }
    /**
   * Compact format upper-right corner of matrix
   * iterate from left to right, from top to bottom.
   *
   * ```
   *   A B C D
   * A 1 2 3 4
   * B 2 5 6 7
   * C 3 6 8 9
   * D 4 7 9 10
   * ```
   *
   * will return compact 1D array `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
   *
   * length is S(i=0, n=sideSize) => 10 for a 4 sideSized matrix
   *
   * @returns {number[]}
   */ toCompact() {
        const { diagonalSize: t } = this, s = new Array(t * (t + 1) / 2);
        for(let e = 0, r = 0, o = 0; o < s.length; o++)s[o] = this.get(r, e), ++e >= t && (e = ++r);
        return s;
    }
    /**
   * @param {number[]} compact
   * @return {SymmetricMatrix}
   */ static fromCompact(t) {
        const s = t.length, e = (Math.sqrt(8 * s + 1) - 1) / 2;
        if (!Number.isInteger(e)) throw new TypeError(`This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(t)}`);
        const r = new mt(e);
        for(let o = 0, n = 0, h = 0; h < s; h++)r.set(o, n, t[h]), ++o >= e && (o = ++n);
        return r;
    }
    /**
   * half iterator upper-right-corner from left to right, from top to bottom
   * yield [row, column, value]
   *
   * @returns {Generator<[number, number, number], void, *>}
   */ *upperRightEntries() {
        for(let t = 0, s = 0; t < this.diagonalSize; void 0){
            const e = this.get(t, s);
            yield [
                t,
                s,
                e
            ], ++s >= this.diagonalSize && (s = ++t);
        }
    }
    /**
   * half iterator upper-right-corner from left to right, from top to bottom
   * yield value
   *
   * @returns {Generator<[number, number, number], void, *>}
   */ *upperRightValues() {
        for(let t = 0, s = 0; t < this.diagonalSize; void 0)yield this.get(t, s), ++s >= this.diagonalSize && (s = ++t);
    }
}
mt.prototype.klassType = "SymmetricMatrix";
class Yt extends mt {
    /**
   * not the same as matrix.isSymmetric()
   * Here is to check if it's instanceof SymmetricMatrix without bundling issues
   *
   * @param value
   * @returns {boolean}
   */ static isDistanceMatrix(t) {
        return mt.isSymmetricMatrix(t) && t.klassSubType === "DistanceMatrix";
    }
    constructor(t){
        if (super(t), !this.isDistance()) throw new TypeError("Provided arguments do no produce a distance matrix");
    }
    set(t, s, e) {
        return t === s && (e = 0), super.set(t, s, e);
    }
    addCross(t, s) {
        return s === void 0 && (s = t, t = this.diagonalSize), s = s.slice(), s[t] = 0, super.addCross(t, s);
    }
    toSymmetricMatrix() {
        return new mt(this);
    }
    clone() {
        const t = new Yt(this.diagonalSize);
        for (const [s, e, r] of this.upperRightEntries())s !== e && t.set(s, e, r);
        return t;
    }
    /**
   * Compact format upper-right corner of matrix
   * no diagonal (only zeros)
   * iterable from left to right, from top to bottom.
   *
   * ```
   *   A B C D
   * A 0 1 2 3
   * B 1 0 4 5
   * C 2 4 0 6
   * D 3 5 6 0
   * ```
   *
   * will return compact 1D array `[1, 2, 3, 4, 5, 6]`
   *
   * length is S(i=0, n=sideSize-1) => 6 for a 4 side sized matrix
   *
   * @returns {number[]}
   */ toCompact() {
        const { diagonalSize: t } = this, s = (t - 1) * t / 2, e = new Array(s);
        for(let r = 1, o = 0, n = 0; n < e.length; n++)e[n] = this.get(o, r), ++r >= t && (r = ++o + 1);
        return e;
    }
    /**
   * @param {number[]} compact
   */ static fromCompact(t) {
        const s = t.length, e = (Math.sqrt(8 * s + 1) + 1) / 2;
        if (!Number.isInteger(e)) throw new TypeError(`This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(t)}`);
        const r = new this(e);
        for(let o = 1, n = 0, h = 0; h < s; h++)r.set(o, n, t[h]), ++o >= e && (o = ++n + 1);
        return r;
    }
}
Yt.prototype.klassSubType = "DistanceMatrix";
class tt extends I {
    constructor(t, s, e){
        super(), this.matrix = t, this.rows = s, this.columns = e;
    }
}
class gs extends tt {
    constructor(t, s){
        J(t, s), super(t, t.rows, 1), this.column = s;
    }
    set(t, s, e) {
        return this.matrix.set(t, this.column, e), this;
    }
    get(t) {
        return this.matrix.get(t, this.column);
    }
}
class ws extends tt {
    constructor(t, s){
        te(t, s), super(t, t.rows, s.length), this.columnIndices = s;
    }
    set(t, s, e) {
        return this.matrix.set(t, this.columnIndices[s], e), this;
    }
    get(t, s) {
        return this.matrix.get(t, this.columnIndices[s]);
    }
}
class ps extends tt {
    constructor(t){
        super(t, t.rows, t.columns);
    }
    set(t, s, e) {
        return this.matrix.set(t, this.columns - s - 1, e), this;
    }
    get(t, s) {
        return this.matrix.get(t, this.columns - s - 1);
    }
}
class ds extends tt {
    constructor(t){
        super(t, t.rows, t.columns);
    }
    set(t, s, e) {
        return this.matrix.set(this.rows - t - 1, s, e), this;
    }
    get(t, s) {
        return this.matrix.get(this.rows - t - 1, s);
    }
}
class ys extends tt {
    constructor(t, s){
        Q(t, s), super(t, 1, t.columns), this.row = s;
    }
    set(t, s, e) {
        return this.matrix.set(this.row, s, e), this;
    }
    get(t, s) {
        return this.matrix.get(this.row, s);
    }
}
class js extends tt {
    constructor(t, s){
        Ht(t, s), super(t, s.length, t.columns), this.rowIndices = s;
    }
    set(t, s, e) {
        return this.matrix.set(this.rowIndices[t], s, e), this;
    }
    get(t, s) {
        return this.matrix.get(this.rowIndices[t], s);
    }
}
class zt extends tt {
    constructor(t, s, e){
        Ht(t, s), te(t, e), super(t, s.length, e.length), this.rowIndices = s, this.columnIndices = e;
    }
    set(t, s, e) {
        return this.matrix.set(this.rowIndices[t], this.columnIndices[s], e), this;
    }
    get(t, s) {
        return this.matrix.get(this.rowIndices[t], this.columnIndices[s]);
    }
}
class Ms extends tt {
    constructor(t, s, e, r, o){
        Kt(t, s, e, r, o), super(t, e - s + 1, o - r + 1), this.startRow = s, this.startColumn = r;
    }
    set(t, s, e) {
        return this.matrix.set(this.startRow + t, this.startColumn + s, e), this;
    }
    get(t, s) {
        return this.matrix.get(this.startRow + t, this.startColumn + s);
    }
}
class Ps extends tt {
    constructor(t){
        super(t, t.columns, t.rows);
    }
    set(t, s, e) {
        return this.matrix.set(s, t, e), this;
    }
    get(t, s) {
        return this.matrix.get(s, t);
    }
}
class me extends I {
    constructor(t, s = {}){
        const { rows: e = 1 } = s;
        if (t.length % e !== 0) throw new Error("the data length is not divisible by the number of rows");
        super(), this.rows = e, this.columns = t.length / e, this.data = t;
    }
    set(t, s, e) {
        let r = this._calculateIndex(t, s);
        return this.data[r] = e, this;
    }
    get(t, s) {
        let e = this._calculateIndex(t, s);
        return this.data[e];
    }
    _calculateIndex(t, s) {
        return t * this.columns + s;
    }
}
class X extends I {
    constructor(t){
        super(), this.data = t, this.rows = t.length, this.columns = t[0].length;
    }
    set(t, s, e) {
        return this.data[t][s] = e, this;
    }
    get(t, s) {
        return this.data[t][s];
    }
}
function vs(i, t) {
    if (U.isAnyArray(i)) return i[0] && U.isAnyArray(i[0]) ? new X(i) : new me(i, t);
    throw new Error("the argument is not an array");
}
class _t {
    constructor(t){
        t = X.checkMatrix(t);
        let s = t.clone(), e = s.rows, r = s.columns, o = new Float64Array(e), n = 1, h, l, a, c, u, g, y, w, p;
        for(h = 0; h < e; h++)o[h] = h;
        for(w = new Float64Array(e), l = 0; l < r; l++){
            for(h = 0; h < e; h++)w[h] = s.get(h, l);
            for(h = 0; h < e; h++){
                for(p = Math.min(h, l), u = 0, a = 0; a < p; a++)u += s.get(h, a) * w[a];
                w[h] -= u, s.set(h, l, w[h]);
            }
            for(c = l, h = l + 1; h < e; h++)Math.abs(w[h]) > Math.abs(w[c]) && (c = h);
            if (c !== l) {
                for(a = 0; a < r; a++)g = s.get(c, a), s.set(c, a, s.get(l, a)), s.set(l, a, g);
                y = o[c], o[c] = o[l], o[l] = y, n = -n;
            }
            if (l < e && s.get(l, l) !== 0) for(h = l + 1; h < e; h++)s.set(h, l, s.get(h, l) / s.get(l, l));
        }
        this.LU = s, this.pivotVector = o, this.pivotSign = n;
    }
    isSingular() {
        let t = this.LU, s = t.columns;
        for(let e = 0; e < s; e++)if (t.get(e, e) === 0) return !0;
        return !1;
    }
    solve(t) {
        t = P.checkMatrix(t);
        let s = this.LU;
        if (s.rows !== t.rows) throw new Error("Invalid matrix dimensions");
        if (this.isSingular()) throw new Error("LU matrix is singular");
        let r = t.columns, o = t.subMatrixRow(this.pivotVector, 0, r - 1), n = s.columns, h, l, a;
        for(a = 0; a < n; a++)for(h = a + 1; h < n; h++)for(l = 0; l < r; l++)o.set(h, l, o.get(h, l) - o.get(a, l) * s.get(h, a));
        for(a = n - 1; a >= 0; a--){
            for(l = 0; l < r; l++)o.set(a, l, o.get(a, l) / s.get(a, a));
            for(h = 0; h < a; h++)for(l = 0; l < r; l++)o.set(h, l, o.get(h, l) - o.get(a, l) * s.get(h, a));
        }
        return o;
    }
    get determinant() {
        let t = this.LU;
        if (!t.isSquare()) throw new Error("Matrix must be square");
        let s = this.pivotSign, e = t.columns;
        for(let r = 0; r < e; r++)s *= t.get(r, r);
        return s;
    }
    get lowerTriangularMatrix() {
        let t = this.LU, s = t.rows, e = t.columns, r = new P(s, e);
        for(let o = 0; o < s; o++)for(let n = 0; n < e; n++)o > n ? r.set(o, n, t.get(o, n)) : o === n ? r.set(o, n, 1) : r.set(o, n, 0);
        return r;
    }
    get upperTriangularMatrix() {
        let t = this.LU, s = t.rows, e = t.columns, r = new P(s, e);
        for(let o = 0; o < s; o++)for(let n = 0; n < e; n++)o <= n ? r.set(o, n, t.get(o, n)) : r.set(o, n, 0);
        return r;
    }
    get pivotPermutationVector() {
        return Array.from(this.pivotVector);
    }
}
function H(i, t) {
    let s = 0;
    return Math.abs(i) > Math.abs(t) ? (s = t / i, Math.abs(i) * Math.sqrt(1 + s * s)) : t !== 0 ? (s = i / t, Math.abs(t) * Math.sqrt(1 + s * s)) : 0;
}
class ee {
    constructor(t){
        t = X.checkMatrix(t);
        let s = t.clone(), e = t.rows, r = t.columns, o = new Float64Array(r), n, h, l, a;
        for(l = 0; l < r; l++){
            let c = 0;
            for(n = l; n < e; n++)c = H(c, s.get(n, l));
            if (c !== 0) {
                for(s.get(l, l) < 0 && (c = -c), n = l; n < e; n++)s.set(n, l, s.get(n, l) / c);
                for(s.set(l, l, s.get(l, l) + 1), h = l + 1; h < r; h++){
                    for(a = 0, n = l; n < e; n++)a += s.get(n, l) * s.get(n, h);
                    for(a = -a / s.get(l, l), n = l; n < e; n++)s.set(n, h, s.get(n, h) + a * s.get(n, l));
                }
            }
            o[l] = -c;
        }
        this.QR = s, this.Rdiag = o;
    }
    solve(t) {
        t = P.checkMatrix(t);
        let s = this.QR, e = s.rows;
        if (t.rows !== e) throw new Error("Matrix row dimensions must agree");
        if (!this.isFullRank()) throw new Error("Matrix is rank deficient");
        let r = t.columns, o = t.clone(), n = s.columns, h, l, a, c;
        for(a = 0; a < n; a++)for(l = 0; l < r; l++){
            for(c = 0, h = a; h < e; h++)c += s.get(h, a) * o.get(h, l);
            for(c = -c / s.get(a, a), h = a; h < e; h++)o.set(h, l, o.get(h, l) + c * s.get(h, a));
        }
        for(a = n - 1; a >= 0; a--){
            for(l = 0; l < r; l++)o.set(a, l, o.get(a, l) / this.Rdiag[a]);
            for(h = 0; h < a; h++)for(l = 0; l < r; l++)o.set(h, l, o.get(h, l) - o.get(a, l) * s.get(h, a));
        }
        return o.subMatrix(0, n - 1, 0, r - 1);
    }
    isFullRank() {
        let t = this.QR.columns;
        for(let s = 0; s < t; s++)if (this.Rdiag[s] === 0) return !1;
        return !0;
    }
    get upperTriangularMatrix() {
        let t = this.QR, s = t.columns, e = new P(s, s), r, o;
        for(r = 0; r < s; r++)for(o = 0; o < s; o++)r < o ? e.set(r, o, t.get(r, o)) : r === o ? e.set(r, o, this.Rdiag[r]) : e.set(r, o, 0);
        return e;
    }
    get orthogonalMatrix() {
        let t = this.QR, s = t.rows, e = t.columns, r = new P(s, e), o, n, h, l;
        for(h = e - 1; h >= 0; h--){
            for(o = 0; o < s; o++)r.set(o, h, 0);
            for(r.set(h, h, 1), n = h; n < e; n++)if (t.get(h, h) !== 0) {
                for(l = 0, o = h; o < s; o++)l += t.get(o, h) * r.get(o, n);
                for(l = -l / t.get(h, h), o = h; o < s; o++)r.set(o, n, r.get(o, n) + l * t.get(o, h));
            }
        }
        return r;
    }
}
let dt = class {
    constructor(t, s = {}){
        if (t = X.checkMatrix(t), t.isEmpty()) throw new Error("Matrix must be non-empty");
        let e = t.rows, r = t.columns;
        const { computeLeftSingularVectors: o = !0, computeRightSingularVectors: n = !0, autoTranspose: h = !1 } = s;
        let l = !!o, a = !!n, c = !1, u;
        if (e < r) if (!h) u = t.clone(), console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");
        else {
            u = t.transpose(), e = u.rows, r = u.columns, c = !0;
            let m = l;
            l = a, a = m;
        }
        else u = t.clone();
        let g = Math.min(e, r), y = Math.min(e + 1, r), w = new Float64Array(y), p = new P(e, g), v = new P(r, r), f = new Float64Array(r), M = new Float64Array(e), k = new Float64Array(y);
        for(let m = 0; m < y; m++)k[m] = m;
        let F = Math.min(e - 1, r), G = Math.max(0, Math.min(r - 2, e)), B = Math.max(F, G);
        for(let m = 0; m < B; m++){
            if (m < F) {
                w[m] = 0;
                for(let d = m; d < e; d++)w[m] = H(w[m], u.get(d, m));
                if (w[m] !== 0) {
                    u.get(m, m) < 0 && (w[m] = -w[m]);
                    for(let d = m; d < e; d++)u.set(d, m, u.get(d, m) / w[m]);
                    u.set(m, m, u.get(m, m) + 1);
                }
                w[m] = -w[m];
            }
            for(let d = m + 1; d < r; d++){
                if (m < F && w[m] !== 0) {
                    let E = 0;
                    for(let j = m; j < e; j++)E += u.get(j, m) * u.get(j, d);
                    E = -E / u.get(m, m);
                    for(let j = m; j < e; j++)u.set(j, d, u.get(j, d) + E * u.get(j, m));
                }
                f[d] = u.get(m, d);
            }
            if (l && m < F) for(let d = m; d < e; d++)p.set(d, m, u.get(d, m));
            if (m < G) {
                f[m] = 0;
                for(let d = m + 1; d < r; d++)f[m] = H(f[m], f[d]);
                if (f[m] !== 0) {
                    f[m + 1] < 0 && (f[m] = 0 - f[m]);
                    for(let d = m + 1; d < r; d++)f[d] /= f[m];
                    f[m + 1] += 1;
                }
                if (f[m] = -f[m], m + 1 < e && f[m] !== 0) {
                    for(let d = m + 1; d < e; d++)M[d] = 0;
                    for(let d = m + 1; d < e; d++)for(let E = m + 1; E < r; E++)M[d] += f[E] * u.get(d, E);
                    for(let d = m + 1; d < r; d++){
                        let E = -f[d] / f[m + 1];
                        for(let j = m + 1; j < e; j++)u.set(j, d, u.get(j, d) + E * M[j]);
                    }
                }
                if (a) for(let d = m + 1; d < r; d++)v.set(d, m, f[d]);
            }
        }
        let b = Math.min(r, e + 1);
        if (F < r && (w[F] = u.get(F, F)), e < b && (w[b - 1] = 0), G + 1 < b && (f[G] = u.get(G, b - 1)), f[b - 1] = 0, l) {
            for(let m = F; m < g; m++){
                for(let d = 0; d < e; d++)p.set(d, m, 0);
                p.set(m, m, 1);
            }
            for(let m = F - 1; m >= 0; m--)if (w[m] !== 0) {
                for(let d = m + 1; d < g; d++){
                    let E = 0;
                    for(let j = m; j < e; j++)E += p.get(j, m) * p.get(j, d);
                    E = -E / p.get(m, m);
                    for(let j = m; j < e; j++)p.set(j, d, p.get(j, d) + E * p.get(j, m));
                }
                for(let d = m; d < e; d++)p.set(d, m, -p.get(d, m));
                p.set(m, m, 1 + p.get(m, m));
                for(let d = 0; d < m - 1; d++)p.set(d, m, 0);
            } else {
                for(let d = 0; d < e; d++)p.set(d, m, 0);
                p.set(m, m, 1);
            }
        }
        if (a) for(let m = r - 1; m >= 0; m--){
            if (m < G && f[m] !== 0) for(let d = m + 1; d < r; d++){
                let E = 0;
                for(let j = m + 1; j < r; j++)E += v.get(j, m) * v.get(j, d);
                E = -E / v.get(m + 1, m);
                for(let j = m + 1; j < r; j++)v.set(j, d, v.get(j, d) + E * v.get(j, m));
            }
            for(let d = 0; d < r; d++)v.set(d, m, 0);
            v.set(m, m, 1);
        }
        let S = b - 1, C = Number.EPSILON;
        for(; b > 0;){
            let m, d;
            for(m = b - 2; m >= -1 && m !== -1; m--){
                const E = Number.MIN_VALUE + C * Math.abs(w[m] + Math.abs(w[m + 1]));
                if (Math.abs(f[m]) <= E || Number.isNaN(f[m])) {
                    f[m] = 0;
                    break;
                }
            }
            if (m === b - 2) d = 4;
            else {
                let E;
                for(E = b - 1; E >= m && E !== m; E--){
                    let j = (E !== b ? Math.abs(f[E]) : 0) + (E !== m + 1 ? Math.abs(f[E - 1]) : 0);
                    if (Math.abs(w[E]) <= C * j) {
                        w[E] = 0;
                        break;
                    }
                }
                E === m ? d = 3 : E === b - 1 ? d = 1 : (d = 2, m = E);
            }
            switch(m++, d){
                case 1:
                    {
                        let E = f[b - 2];
                        f[b - 2] = 0;
                        for(let j = b - 2; j >= m; j--){
                            let $ = H(w[j], E), R = w[j] / $, N = E / $;
                            if (w[j] = $, j !== m && (E = -N * f[j - 1], f[j - 1] = R * f[j - 1]), a) for(let L = 0; L < r; L++)$ = R * v.get(L, j) + N * v.get(L, b - 1), v.set(L, b - 1, -N * v.get(L, j) + R * v.get(L, b - 1)), v.set(L, j, $);
                        }
                        break;
                    }
                case 2:
                    {
                        let E = f[m - 1];
                        f[m - 1] = 0;
                        for(let j = m; j < b; j++){
                            let $ = H(w[j], E), R = w[j] / $, N = E / $;
                            if (w[j] = $, E = -N * f[j], f[j] = R * f[j], l) for(let L = 0; L < e; L++)$ = R * p.get(L, j) + N * p.get(L, m - 1), p.set(L, m - 1, -N * p.get(L, j) + R * p.get(L, m - 1)), p.set(L, j, $);
                        }
                        break;
                    }
                case 3:
                    {
                        const E = Math.max(Math.abs(w[b - 1]), Math.abs(w[b - 2]), Math.abs(f[b - 2]), Math.abs(w[m]), Math.abs(f[m])), j = w[b - 1] / E, $ = w[b - 2] / E, R = f[b - 2] / E, N = w[m] / E, L = f[m] / E, O = (($ + j) * ($ - j) + R * R) / 2, Z = j * R * (j * R);
                        let z = 0;
                        (O !== 0 || Z !== 0) && (O < 0 ? z = 0 - Math.sqrt(O * O + Z) : z = Math.sqrt(O * O + Z), z = Z / (O + z));
                        let A = (N + j) * (N - j) + z, x = N * L;
                        for(let D = m; D < b - 1; D++){
                            let W = H(A, x);
                            W === 0 && (W = Number.MIN_VALUE);
                            let Y = A / W, _ = x / W;
                            if (D !== m && (f[D - 1] = W), A = Y * w[D] + _ * f[D], f[D] = Y * f[D] - _ * w[D], x = _ * w[D + 1], w[D + 1] = Y * w[D + 1], a) for(let V = 0; V < r; V++)W = Y * v.get(V, D) + _ * v.get(V, D + 1), v.set(V, D + 1, -_ * v.get(V, D) + Y * v.get(V, D + 1)), v.set(V, D, W);
                            if (W = H(A, x), W === 0 && (W = Number.MIN_VALUE), Y = A / W, _ = x / W, w[D] = W, A = Y * f[D] + _ * w[D + 1], w[D + 1] = -_ * f[D] + Y * w[D + 1], x = _ * f[D + 1], f[D + 1] = Y * f[D + 1], l && D < e - 1) for(let V = 0; V < e; V++)W = Y * p.get(V, D) + _ * p.get(V, D + 1), p.set(V, D + 1, -_ * p.get(V, D) + Y * p.get(V, D + 1)), p.set(V, D, W);
                        }
                        f[b - 2] = A;
                        break;
                    }
                case 4:
                    {
                        if (w[m] <= 0 && (w[m] = w[m] < 0 ? -w[m] : 0, a)) for(let E = 0; E <= S; E++)v.set(E, m, -v.get(E, m));
                        for(; m < S && !(w[m] >= w[m + 1]);){
                            let E = w[m];
                            if (w[m] = w[m + 1], w[m + 1] = E, a && m < r - 1) for(let j = 0; j < r; j++)E = v.get(j, m + 1), v.set(j, m + 1, v.get(j, m)), v.set(j, m, E);
                            if (l && m < e - 1) for(let j = 0; j < e; j++)E = p.get(j, m + 1), p.set(j, m + 1, p.get(j, m)), p.set(j, m, E);
                            m++;
                        }
                        b--;
                        break;
                    }
            }
        }
        if (c) {
            let m = v;
            v = p, p = m;
        }
        this.m = e, this.n = r, this.s = w, this.U = p, this.V = v;
    }
    solve(t) {
        let s = t, e = this.threshold, r = this.s.length, o = P.zeros(r, r);
        for(let g = 0; g < r; g++)Math.abs(this.s[g]) <= e ? o.set(g, g, 0) : o.set(g, g, 1 / this.s[g]);
        let n = this.U, h = this.rightSingularVectors, l = h.mmul(o), a = h.rows, c = n.rows, u = P.zeros(a, c);
        for(let g = 0; g < a; g++)for(let y = 0; y < c; y++){
            let w = 0;
            for(let p = 0; p < r; p++)w += l.get(g, p) * n.get(y, p);
            u.set(g, y, w);
        }
        return u.mmul(s);
    }
    solveForDiagonal(t) {
        return this.solve(P.diag(t));
    }
    inverse() {
        let t = this.V, s = this.threshold, e = t.rows, r = t.columns, o = new P(e, this.s.length);
        for(let c = 0; c < e; c++)for(let u = 0; u < r; u++)Math.abs(this.s[u]) > s && o.set(c, u, t.get(c, u) / this.s[u]);
        let n = this.U, h = n.rows, l = n.columns, a = new P(e, h);
        for(let c = 0; c < e; c++)for(let u = 0; u < h; u++){
            let g = 0;
            for(let y = 0; y < l; y++)g += o.get(c, y) * n.get(u, y);
            a.set(c, u, g);
        }
        return a;
    }
    get condition() {
        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
    }
    get norm2() {
        return this.s[0];
    }
    get rank() {
        let t = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON, s = 0, e = this.s;
        for(let r = 0, o = e.length; r < o; r++)e[r] > t && s++;
        return s;
    }
    get diagonal() {
        return Array.from(this.s);
    }
    get threshold() {
        return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
    }
    get leftSingularVectors() {
        return this.U;
    }
    get rightSingularVectors() {
        return this.V;
    }
    get diagonalMatrix() {
        return P.diag(this.s);
    }
};
function Es(i, t = !1) {
    return i = X.checkMatrix(i), t ? new dt(i).inverse() : ge(i, P.eye(i.rows));
}
function ge(i, t, s = !1) {
    return i = X.checkMatrix(i), t = X.checkMatrix(t), s ? new dt(i).solve(t) : i.isSquare() ? new _t(i).solve(t) : new ee(i).solve(t);
}
function Vt(i) {
    if (i = P.checkMatrix(i), i.isSquare()) {
        if (i.columns === 0) return 1;
        let t, s, e, r;
        if (i.columns === 2) return t = i.get(0, 0), s = i.get(0, 1), e = i.get(1, 0), r = i.get(1, 1), t * r - s * e;
        if (i.columns === 3) {
            let o, n, h;
            return o = new zt(i, [
                1,
                2
            ], [
                1,
                2
            ]), n = new zt(i, [
                1,
                2
            ], [
                0,
                2
            ]), h = new zt(i, [
                1,
                2
            ], [
                0,
                1
            ]), t = i.get(0, 0), s = i.get(0, 1), e = i.get(0, 2), t * Vt(o) - s * Vt(n) + e * Vt(h);
        } else return new _t(i).determinant;
    } else throw Error("determinant can only be calculated for a square matrix");
}
function ks(i, t) {
    let s = [];
    for(let e = 0; e < i; e++)e !== t && s.push(e);
    return s;
}
function bs(i, t, s, e = 1e-9, r = 1e-9) {
    if (i > r) return new Array(t.rows + 1).fill(0);
    {
        let o = t.addRow(s, [
            0
        ]);
        for(let n = 0; n < o.rows; n++)Math.abs(o.get(n, 0)) < e && o.set(n, 0, 0);
        return o.to1DArray();
    }
}
function Ss(i, t = {}) {
    const { thresholdValue: s = 1e-9, thresholdError: e = 1e-9 } = t;
    i = P.checkMatrix(i);
    let r = i.rows, o = new P(r, r);
    for(let n = 0; n < r; n++){
        let h = P.columnVector(i.getRow(n)), l = i.subMatrixRow(ks(r, n)).transpose(), c = new dt(l).solve(h), u = P.sub(h, l.mmul(c)).abs().max();
        o.setRow(n, bs(u, c, n, s, e));
    }
    return o;
}
function Fs(i, t = Number.EPSILON) {
    if (i = P.checkMatrix(i), i.isEmpty()) return i.transpose();
    let s = new dt(i, {
        autoTranspose: !0
    }), e = s.leftSingularVectors, r = s.rightSingularVectors, o = s.diagonal;
    for(let n = 0; n < o.length; n++)Math.abs(o[n]) > t ? o[n] = 1 / o[n] : o[n] = 0;
    return r.mmul(P.diag(o).mmul(e.transpose()));
}
function Gs(i, t = i, s = {}) {
    i = new P(i);
    let e = !1;
    if (typeof t == "object" && !P.isMatrix(t) && !U.isAnyArray(t) ? (s = t, t = i, e = !0) : t = new P(t), i.rows !== t.rows) throw new TypeError("Both matrices must have the same number of rows");
    const { center: r = !0 } = s;
    r && (i = i.center("column"), e || (t = t.center("column")));
    const o = i.transpose().mmul(t);
    for(let n = 0; n < o.rows; n++)for(let h = 0; h < o.columns; h++)o.set(n, h, o.get(n, h) * (1 / (i.rows - 1)));
    return o;
}
function Is(i, t = i, s = {}) {
    i = new P(i);
    let e = !1;
    if (typeof t == "object" && !P.isMatrix(t) && !U.isAnyArray(t) ? (s = t, t = i, e = !0) : t = new P(t), i.rows !== t.rows) throw new TypeError("Both matrices must have the same number of rows");
    const { center: r = !0, scale: o = !0 } = s;
    r && (i.center("column"), e || t.center("column")), o && (i.scale("column"), e || t.scale("column"));
    const n = i.standardDeviation("column", {
        unbiased: !0
    }), h = e ? n : t.standardDeviation("column", {
        unbiased: !0
    }), l = i.transpose().mmul(t);
    for(let a = 0; a < l.rows; a++)for(let c = 0; c < l.columns; c++)l.set(a, c, l.get(a, c) * (1 / (n[a] * h[c])) * (1 / (i.rows - 1)));
    return l;
}
class we {
    constructor(t, s = {}){
        const { assumeSymmetric: e = !1 } = s;
        if (t = X.checkMatrix(t), !t.isSquare()) throw new Error("Matrix is not a square matrix");
        if (t.isEmpty()) throw new Error("Matrix must be non-empty");
        let r = t.columns, o = new P(r, r), n = new Float64Array(r), h = new Float64Array(r), l = t, a, c, u = !1;
        if (e ? u = !0 : u = t.isSymmetric(), u) {
            for(a = 0; a < r; a++)for(c = 0; c < r; c++)o.set(a, c, l.get(a, c));
            Ts(r, h, n, o), Ds(r, h, n, o);
        } else {
            let g = new P(r, r), y = new Float64Array(r);
            for(c = 0; c < r; c++)for(a = 0; a < r; a++)g.set(a, c, l.get(a, c));
            Rs(r, g, y, o), Cs(r, h, n, o, g);
        }
        this.n = r, this.e = h, this.d = n, this.V = o;
    }
    get realEigenvalues() {
        return Array.from(this.d);
    }
    get imaginaryEigenvalues() {
        return Array.from(this.e);
    }
    get eigenvectorMatrix() {
        return this.V;
    }
    get diagonalMatrix() {
        let t = this.n, s = this.e, e = this.d, r = new P(t, t), o, n;
        for(o = 0; o < t; o++){
            for(n = 0; n < t; n++)r.set(o, n, 0);
            r.set(o, o, e[o]), s[o] > 0 ? r.set(o, o + 1, s[o]) : s[o] < 0 && r.set(o, o - 1, s[o]);
        }
        return r;
    }
}
function Ts(i, t, s, e) {
    let r, o, n, h, l, a, c, u;
    for(l = 0; l < i; l++)s[l] = e.get(i - 1, l);
    for(h = i - 1; h > 0; h--){
        for(u = 0, n = 0, a = 0; a < h; a++)u = u + Math.abs(s[a]);
        if (u === 0) for(t[h] = s[h - 1], l = 0; l < h; l++)s[l] = e.get(h - 1, l), e.set(h, l, 0), e.set(l, h, 0);
        else {
            for(a = 0; a < h; a++)s[a] /= u, n += s[a] * s[a];
            for(r = s[h - 1], o = Math.sqrt(n), r > 0 && (o = -o), t[h] = u * o, n = n - r * o, s[h - 1] = r - o, l = 0; l < h; l++)t[l] = 0;
            for(l = 0; l < h; l++){
                for(r = s[l], e.set(l, h, r), o = t[l] + e.get(l, l) * r, a = l + 1; a <= h - 1; a++)o += e.get(a, l) * s[a], t[a] += e.get(a, l) * r;
                t[l] = o;
            }
            for(r = 0, l = 0; l < h; l++)t[l] /= n, r += t[l] * s[l];
            for(c = r / (n + n), l = 0; l < h; l++)t[l] -= c * s[l];
            for(l = 0; l < h; l++){
                for(r = s[l], o = t[l], a = l; a <= h - 1; a++)e.set(a, l, e.get(a, l) - (r * t[a] + o * s[a]));
                s[l] = e.get(h - 1, l), e.set(h, l, 0);
            }
        }
        s[h] = n;
    }
    for(h = 0; h < i - 1; h++){
        if (e.set(i - 1, h, e.get(h, h)), e.set(h, h, 1), n = s[h + 1], n !== 0) {
            for(a = 0; a <= h; a++)s[a] = e.get(a, h + 1) / n;
            for(l = 0; l <= h; l++){
                for(o = 0, a = 0; a <= h; a++)o += e.get(a, h + 1) * e.get(a, l);
                for(a = 0; a <= h; a++)e.set(a, l, e.get(a, l) - o * s[a]);
            }
        }
        for(a = 0; a <= h; a++)e.set(a, h + 1, 0);
    }
    for(l = 0; l < i; l++)s[l] = e.get(i - 1, l), e.set(i - 1, l, 0);
    e.set(i - 1, i - 1, 1), t[0] = 0;
}
function Ds(i, t, s, e) {
    let r, o, n, h, l, a, c, u, g, y, w, p, v, f, M, k;
    for(n = 1; n < i; n++)t[n - 1] = t[n];
    t[i - 1] = 0;
    let F = 0, G = 0, B = Number.EPSILON;
    for(a = 0; a < i; a++){
        for(G = Math.max(G, Math.abs(s[a]) + Math.abs(t[a])), c = a; c < i && !(Math.abs(t[c]) <= B * G);)c++;
        if (c > a) do {
            for(r = s[a], u = (s[a + 1] - r) / (2 * t[a]), g = H(u, 1), u < 0 && (g = -g), s[a] = t[a] / (u + g), s[a + 1] = t[a] * (u + g), y = s[a + 1], o = r - s[a], n = a + 2; n < i; n++)s[n] -= o;
            for(F = F + o, u = s[c], w = 1, p = w, v = w, f = t[a + 1], M = 0, k = 0, n = c - 1; n >= a; n--)for(v = p, p = w, k = M, r = w * t[n], o = w * u, g = H(u, t[n]), t[n + 1] = M * g, M = t[n] / g, w = u / g, u = w * s[n] - M * r, s[n + 1] = o + M * (w * r + M * s[n]), l = 0; l < i; l++)o = e.get(l, n + 1), e.set(l, n + 1, M * e.get(l, n) + w * o), e.set(l, n, w * e.get(l, n) - M * o);
            u = -M * k * v * f * t[a] / y, t[a] = M * u, s[a] = w * u;
        }while (Math.abs(t[a]) > B * G)
        s[a] = s[a] + F, t[a] = 0;
    }
    for(n = 0; n < i - 1; n++){
        for(l = n, u = s[n], h = n + 1; h < i; h++)s[h] < u && (l = h, u = s[h]);
        if (l !== n) for(s[l] = s[n], s[n] = u, h = 0; h < i; h++)u = e.get(h, n), e.set(h, n, e.get(h, l)), e.set(h, l, u);
    }
}
function Rs(i, t, s, e) {
    let r = 0, o = i - 1, n, h, l, a, c, u, g;
    for(u = r + 1; u <= o - 1; u++){
        for(g = 0, a = u; a <= o; a++)g = g + Math.abs(t.get(a, u - 1));
        if (g !== 0) {
            for(l = 0, a = o; a >= u; a--)s[a] = t.get(a, u - 1) / g, l += s[a] * s[a];
            for(h = Math.sqrt(l), s[u] > 0 && (h = -h), l = l - s[u] * h, s[u] = s[u] - h, c = u; c < i; c++){
                for(n = 0, a = o; a >= u; a--)n += s[a] * t.get(a, c);
                for(n = n / l, a = u; a <= o; a++)t.set(a, c, t.get(a, c) - n * s[a]);
            }
            for(a = 0; a <= o; a++){
                for(n = 0, c = o; c >= u; c--)n += s[c] * t.get(a, c);
                for(n = n / l, c = u; c <= o; c++)t.set(a, c, t.get(a, c) - n * s[c]);
            }
            s[u] = g * s[u], t.set(u, u - 1, g * h);
        }
    }
    for(a = 0; a < i; a++)for(c = 0; c < i; c++)e.set(a, c, a === c ? 1 : 0);
    for(u = o - 1; u >= r + 1; u--)if (t.get(u, u - 1) !== 0) {
        for(a = u + 1; a <= o; a++)s[a] = t.get(a, u - 1);
        for(c = u; c <= o; c++){
            for(h = 0, a = u; a <= o; a++)h += s[a] * e.get(a, c);
            for(h = h / s[u] / t.get(u, u - 1), a = u; a <= o; a++)e.set(a, c, e.get(a, c) + h * s[a]);
        }
    }
}
function Cs(i, t, s, e, r) {
    let o = i - 1, n = 0, h = i - 1, l = Number.EPSILON, a = 0, c = 0, u = 0, g = 0, y = 0, w = 0, p = 0, v = 0, f, M, k, F, G, B, b, S, C, m, d, E, j, $, R;
    for(f = 0; f < i; f++)for((f < n || f > h) && (s[f] = r.get(f, f), t[f] = 0), M = Math.max(f - 1, 0); M < i; M++)c = c + Math.abs(r.get(f, M));
    for(; o >= n;){
        for(F = o; F > n && (w = Math.abs(r.get(F - 1, F - 1)) + Math.abs(r.get(F, F)), w === 0 && (w = c), !(Math.abs(r.get(F, F - 1)) < l * w));)F--;
        if (F === o) r.set(o, o, r.get(o, o) + a), s[o] = r.get(o, o), t[o] = 0, o--, v = 0;
        else if (F === o - 1) {
            if (b = r.get(o, o - 1) * r.get(o - 1, o), u = (r.get(o - 1, o - 1) - r.get(o, o)) / 2, g = u * u + b, p = Math.sqrt(Math.abs(g)), r.set(o, o, r.get(o, o) + a), r.set(o - 1, o - 1, r.get(o - 1, o - 1) + a), S = r.get(o, o), g >= 0) {
                for(p = u >= 0 ? u + p : u - p, s[o - 1] = S + p, s[o] = s[o - 1], p !== 0 && (s[o] = S - b / p), t[o - 1] = 0, t[o] = 0, S = r.get(o, o - 1), w = Math.abs(S) + Math.abs(p), u = S / w, g = p / w, y = Math.sqrt(u * u + g * g), u = u / y, g = g / y, M = o - 1; M < i; M++)p = r.get(o - 1, M), r.set(o - 1, M, g * p + u * r.get(o, M)), r.set(o, M, g * r.get(o, M) - u * p);
                for(f = 0; f <= o; f++)p = r.get(f, o - 1), r.set(f, o - 1, g * p + u * r.get(f, o)), r.set(f, o, g * r.get(f, o) - u * p);
                for(f = n; f <= h; f++)p = e.get(f, o - 1), e.set(f, o - 1, g * p + u * e.get(f, o)), e.set(f, o, g * e.get(f, o) - u * p);
            } else s[o - 1] = S + u, s[o] = S + u, t[o - 1] = p, t[o] = -p;
            o = o - 2, v = 0;
        } else {
            if (S = r.get(o, o), C = 0, b = 0, F < o && (C = r.get(o - 1, o - 1), b = r.get(o, o - 1) * r.get(o - 1, o)), v === 10) {
                for(a += S, f = n; f <= o; f++)r.set(f, f, r.get(f, f) - S);
                w = Math.abs(r.get(o, o - 1)) + Math.abs(r.get(o - 1, o - 2)), S = C = 0.75 * w, b = -0.4375 * w * w;
            }
            if (v === 30 && (w = (C - S) / 2, w = w * w + b, w > 0)) {
                for(w = Math.sqrt(w), C < S && (w = -w), w = S - b / ((C - S) / 2 + w), f = n; f <= o; f++)r.set(f, f, r.get(f, f) - w);
                a += w, S = C = b = 0.964;
            }
            for(v = v + 1, G = o - 2; G >= F && (p = r.get(G, G), y = S - p, w = C - p, u = (y * w - b) / r.get(G + 1, G) + r.get(G, G + 1), g = r.get(G + 1, G + 1) - p - y - w, y = r.get(G + 2, G + 1), w = Math.abs(u) + Math.abs(g) + Math.abs(y), u = u / w, g = g / w, y = y / w, !(G === F || Math.abs(r.get(G, G - 1)) * (Math.abs(g) + Math.abs(y)) < l * (Math.abs(u) * (Math.abs(r.get(G - 1, G - 1)) + Math.abs(p) + Math.abs(r.get(G + 1, G + 1))))));)G--;
            for(f = G + 2; f <= o; f++)r.set(f, f - 2, 0), f > G + 2 && r.set(f, f - 3, 0);
            for(k = G; k <= o - 1 && ($ = k !== o - 1, k !== G && (u = r.get(k, k - 1), g = r.get(k + 1, k - 1), y = $ ? r.get(k + 2, k - 1) : 0, S = Math.abs(u) + Math.abs(g) + Math.abs(y), S !== 0 && (u = u / S, g = g / S, y = y / S)), S !== 0); k++)if (w = Math.sqrt(u * u + g * g + y * y), u < 0 && (w = -w), w !== 0) {
                for(k !== G ? r.set(k, k - 1, -w * S) : F !== G && r.set(k, k - 1, -r.get(k, k - 1)), u = u + w, S = u / w, C = g / w, p = y / w, g = g / u, y = y / u, M = k; M < i; M++)u = r.get(k, M) + g * r.get(k + 1, M), $ && (u = u + y * r.get(k + 2, M), r.set(k + 2, M, r.get(k + 2, M) - u * p)), r.set(k, M, r.get(k, M) - u * S), r.set(k + 1, M, r.get(k + 1, M) - u * C);
                for(f = 0; f <= Math.min(o, k + 3); f++)u = S * r.get(f, k) + C * r.get(f, k + 1), $ && (u = u + p * r.get(f, k + 2), r.set(f, k + 2, r.get(f, k + 2) - u * y)), r.set(f, k, r.get(f, k) - u), r.set(f, k + 1, r.get(f, k + 1) - u * g);
                for(f = n; f <= h; f++)u = S * e.get(f, k) + C * e.get(f, k + 1), $ && (u = u + p * e.get(f, k + 2), e.set(f, k + 2, e.get(f, k + 2) - u * y)), e.set(f, k, e.get(f, k) - u), e.set(f, k + 1, e.get(f, k + 1) - u * g);
            }
        }
    }
    if (c !== 0) {
        for(o = i - 1; o >= 0; o--)if (u = s[o], g = t[o], g === 0) for(F = o, r.set(o, o, 1), f = o - 1; f >= 0; f--){
            for(b = r.get(f, f) - u, y = 0, M = F; M <= o; M++)y = y + r.get(f, M) * r.get(M, o);
            if (t[f] < 0) p = b, w = y;
            else if (F = f, t[f] === 0 ? r.set(f, o, b !== 0 ? -y / b : -y / (l * c)) : (S = r.get(f, f + 1), C = r.get(f + 1, f), g = (s[f] - u) * (s[f] - u) + t[f] * t[f], B = (S * w - p * y) / g, r.set(f, o, B), r.set(f + 1, o, Math.abs(S) > Math.abs(p) ? (-y - b * B) / S : (-w - C * B) / p)), B = Math.abs(r.get(f, o)), l * B * B > 1) for(M = f; M <= o; M++)r.set(M, o, r.get(M, o) / B);
        }
        else if (g < 0) for(F = o - 1, Math.abs(r.get(o, o - 1)) > Math.abs(r.get(o - 1, o)) ? (r.set(o - 1, o - 1, g / r.get(o, o - 1)), r.set(o - 1, o, -(r.get(o, o) - u) / r.get(o, o - 1))) : (R = Nt(0, -r.get(o - 1, o), r.get(o - 1, o - 1) - u, g), r.set(o - 1, o - 1, R[0]), r.set(o - 1, o, R[1])), r.set(o, o - 1, 0), r.set(o, o, 1), f = o - 2; f >= 0; f--){
            for(m = 0, d = 0, M = F; M <= o; M++)m = m + r.get(f, M) * r.get(M, o - 1), d = d + r.get(f, M) * r.get(M, o);
            if (b = r.get(f, f) - u, t[f] < 0) p = b, y = m, w = d;
            else if (F = f, t[f] === 0 ? (R = Nt(-m, -d, b, g), r.set(f, o - 1, R[0]), r.set(f, o, R[1])) : (S = r.get(f, f + 1), C = r.get(f + 1, f), E = (s[f] - u) * (s[f] - u) + t[f] * t[f] - g * g, j = (s[f] - u) * 2 * g, E === 0 && j === 0 && (E = l * c * (Math.abs(b) + Math.abs(g) + Math.abs(S) + Math.abs(C) + Math.abs(p))), R = Nt(S * y - p * m + g * d, S * w - p * d - g * m, E, j), r.set(f, o - 1, R[0]), r.set(f, o, R[1]), Math.abs(S) > Math.abs(p) + Math.abs(g) ? (r.set(f + 1, o - 1, (-m - b * r.get(f, o - 1) + g * r.get(f, o)) / S), r.set(f + 1, o, (-d - b * r.get(f, o) - g * r.get(f, o - 1)) / S)) : (R = Nt(-y - C * r.get(f, o - 1), -w - C * r.get(f, o), p, g), r.set(f + 1, o - 1, R[0]), r.set(f + 1, o, R[1]))), B = Math.max(Math.abs(r.get(f, o - 1)), Math.abs(r.get(f, o))), l * B * B > 1) for(M = f; M <= o; M++)r.set(M, o - 1, r.get(M, o - 1) / B), r.set(M, o, r.get(M, o) / B);
        }
        for(f = 0; f < i; f++)if (f < n || f > h) for(M = f; M < i; M++)e.set(f, M, r.get(f, M));
        for(M = i - 1; M >= n; M--)for(f = n; f <= h; f++){
            for(p = 0, k = n; k <= Math.min(M, h); k++)p = p + e.get(f, k) * r.get(k, M);
            e.set(f, M, p);
        }
    }
}
function Nt(i, t, s, e) {
    let r, o;
    return Math.abs(s) > Math.abs(e) ? (r = e / s, o = s + r * e, [
        (i + r * t) / o,
        (t - r * i) / o
    ]) : (r = s / e, o = e + r * s, [
        (r * i + t) / o,
        (r * t - i) / o
    ]);
}
class pe {
    constructor(t){
        if (t = X.checkMatrix(t), !t.isSymmetric()) throw new Error("Matrix is not symmetric");
        let s = t, e = s.rows, r = new P(e, e), o = !0, n, h, l;
        for(h = 0; h < e; h++){
            let a = 0;
            for(l = 0; l < h; l++){
                let c = 0;
                for(n = 0; n < l; n++)c += r.get(l, n) * r.get(h, n);
                c = (s.get(h, l) - c) / r.get(l, l), r.set(h, l, c), a = a + c * c;
            }
            for(a = s.get(h, h) - a, o &= a > 0, r.set(h, h, Math.sqrt(Math.max(a, 0))), l = h + 1; l < e; l++)r.set(h, l, 0);
        }
        this.L = r, this.positiveDefinite = !!o;
    }
    isPositiveDefinite() {
        return this.positiveDefinite;
    }
    solve(t) {
        t = X.checkMatrix(t);
        let s = this.L, e = s.rows;
        if (t.rows !== e) throw new Error("Matrix dimensions do not match");
        if (this.isPositiveDefinite() === !1) throw new Error("Matrix is not positive definite");
        let r = t.columns, o = t.clone(), n, h, l;
        for(l = 0; l < e; l++)for(h = 0; h < r; h++){
            for(n = 0; n < l; n++)o.set(l, h, o.get(l, h) - o.get(n, h) * s.get(l, n));
            o.set(l, h, o.get(l, h) / s.get(l, l));
        }
        for(l = e - 1; l >= 0; l--)for(h = 0; h < r; h++){
            for(n = l + 1; n < e; n++)o.set(l, h, o.get(l, h) - o.get(n, h) * s.get(n, l));
            o.set(l, h, o.get(l, h) / s.get(l, l));
        }
        return o;
    }
    get lowerTriangularMatrix() {
        return this.L;
    }
}
class de {
    constructor(t, s = {}){
        t = X.checkMatrix(t);
        let { Y: e } = s;
        const { scaleScores: r = !1, maxIterations: o = 1e3, terminationCriteria: n = 1e-10 } = s;
        let h;
        if (e) {
            if (U.isAnyArray(e) && typeof e[0] == "number" ? e = P.columnVector(e) : e = X.checkMatrix(e), e.rows !== t.rows) throw new Error("Y should have the same number of rows as X");
            h = e.getColumnVector(0);
        } else h = t.getColumnVector(0);
        let l = 1, a, c, u, g;
        for(let y = 0; y < o && l > n; y++)u = t.transpose().mmul(h).div(h.transpose().mmul(h).get(0, 0)), u = u.div(u.norm()), a = t.mmul(u).div(u.transpose().mmul(u).get(0, 0)), y > 0 && (l = a.clone().sub(g).pow(2).sum()), g = a.clone(), e ? (c = e.transpose().mmul(a).div(a.transpose().mmul(a).get(0, 0)), c = c.div(c.norm()), h = e.mmul(c).div(c.transpose().mmul(c).get(0, 0))) : h = a;
        if (e) {
            let y = t.transpose().mmul(a).div(a.transpose().mmul(a).get(0, 0));
            y = y.div(y.norm());
            let w = t.clone().sub(a.clone().mmul(y.transpose())), p = h.transpose().mmul(a).div(a.transpose().mmul(a).get(0, 0)), v = e.clone().sub(a.clone().mulS(p.get(0, 0)).mmul(c.transpose()));
            this.t = a, this.p = y.transpose(), this.w = u.transpose(), this.q = c, this.u = h, this.s = a.transpose().mmul(a), this.xResidual = w, this.yResidual = v, this.betas = p;
        } else this.w = u.transpose(), this.s = a.transpose().mmul(a).sqrt(), r ? this.t = a.clone().div(this.s.get(0, 0)) : this.t = a, this.xResidual = t.sub(a.mmul(u.transpose()));
    }
}
T.AbstractMatrix = I;
T.CHO = pe;
T.CholeskyDecomposition = pe;
T.DistanceMatrix = Yt;
T.EVD = we;
T.EigenvalueDecomposition = we;
T.LU = _t;
T.LuDecomposition = _t;
var ye = T.Matrix = P;
T.MatrixColumnSelectionView = ws;
T.MatrixColumnView = gs;
T.MatrixFlipColumnView = ps;
T.MatrixFlipRowView = ds;
T.MatrixRowSelectionView = js;
T.MatrixRowView = ys;
T.MatrixSelectionView = zt;
T.MatrixSubView = Ms;
T.MatrixTransposeView = Ps;
T.NIPALS = de;
T.Nipals = de;
T.QR = ee;
T.QrDecomposition = ee;
T.SVD = dt;
var Ns = T.SingularValueDecomposition = dt;
T.SymmetricMatrix = mt;
T.WrapperMatrix1D = me;
T.WrapperMatrix2D = X;
T.correlation = Is;
T.covariance = Gs;
var ie = T.default = P;
T.determinant = Vt;
var qs = T.inverse = Es;
T.linearDependencies = Ss;
var Bs = T.pseudoInverse = Fs;
T.solve = ge;
T.wrap = vs;
const K = ye, $s = Ns;
ie.Matrix && ie.Matrix;
const Ls = qs, je = Bs;
class jt {
    sourcePoints;
    destinationPoints;
    pointCount;
    pointCountMinimum;
    type;
    /**
   * Create a transformation
   * @param {Point[]} sourcePoints - The source points
   * @param {Point[]} destinationPoints - The destination points
   * @param {TransformationType} type - The transformation type
   * @param {number} pointCountMinimum - The minimum number of points for the transformation type
   */ constructor(t, s, e, r){
        if (this.sourcePoints = t, this.destinationPoints = s, this.pointCount = this.sourcePoints.length, this.type = e, this.pointCountMinimum = r, this.pointCount < this.pointCountMinimum) throw new Error("Not enough control points. A " + this.type + " transformation requires a minimum of " + this.pointCountMinimum + " points, but " + this.pointCount + " are given.");
    }
    evaluate(t, s = "function") {
        if (s == "function") return this.evaluateFunction(t);
        if (s == "partialDerivativeX") return this.evaluatePartialDerivativeX(t);
        if (s == "partialDerivativeY") return this.evaluatePartialDerivativeY(t);
        throw new Error("Evaluation of type " + s + " not supported");
    }
}
class Me extends jt {
    helmertParametersMatrix;
    helmertParameters;
    scale;
    rotation;
    translation;
    constructor(t, s){
        super(t, s, "helmert", 2);
        const e = K.columnVector(s.flat()), r = K.zeros(2 * this.pointCount, 4);
        for(let n = 0; n < this.pointCount; n++)r.set(2 * n, 0, 1), r.set(2 * n, 1, 0), r.set(2 * n, 2, this.sourcePoints[n][0]), r.set(2 * n, 3, -this.sourcePoints[n][1]), r.set(2 * n + 1, 0, 0), r.set(2 * n + 1, 1, 1), r.set(2 * n + 1, 2, this.sourcePoints[n][1]), r.set(2 * n + 1, 3, this.sourcePoints[n][0]);
        const o = je(r);
        this.helmertParametersMatrix = o.mmul(e), this.helmertParameters = this.helmertParametersMatrix.to1DArray(), this.scale = Math.sqrt(this.helmertParameters[2] ** 2 + this.helmertParameters[3] ** 2), this.rotation = Math.atan2(this.helmertParameters[3], this.helmertParameters[2]), this.translation = [
            this.helmertParameters[0],
            this.helmertParameters[1]
        ];
    }
    // Evaluate the transformation function at a new point
    evaluateFunction(t) {
        if (!this.helmertParameters) throw new Error("Helmert parameters not computed");
        return [
            this.helmertParameters[0] + this.helmertParameters[2] * t[0] - this.helmertParameters[3] * t[1],
            this.helmertParameters[1] + this.helmertParameters[2] * t[1] + this.helmertParameters[3] * t[0]
        ];
    }
    // Evaluate the transformation function's partial derivative to x at a new point
    evaluatePartialDerivativeX(t) {
        if (!this.helmertParameters) throw new Error("Helmert parameters not computed");
        return [
            this.helmertParameters[2],
            this.helmertParameters[3]
        ];
    }
    // Evaluate the transformation function's partial derivative to y at a new point
    evaluatePartialDerivativeY(t) {
        if (!this.helmertParameters) throw new Error("Helmert parameters not computed");
        return [
            -this.helmertParameters[3],
            this.helmertParameters[2]
        ];
    }
}
class zs extends jt {
    scale;
    sourcePointsCenter;
    destinationPointsCenter;
    translation;
    constructor(t, s){
        super(t, s, "straight", 2);
        const e = new Me(this.sourcePoints, this.destinationPoints);
        if (this.scale = e.scale, !this.scale) throw new Error("Scale could not be computed");
        this.sourcePointsCenter = this.sourcePoints.reduce((o, n)=>[
                o[0] + n[0],
                o[1] + n[1]
            ]).map((o)=>o / this.pointCount), this.destinationPointsCenter = this.destinationPoints.reduce((o, n)=>[
                o[0] + n[0],
                o[1] + n[1]
            ]).map((o)=>o / this.pointCount);
        const r = this.scale;
        this.translation = this.destinationPointsCenter.map((o, n)=>o - this.sourcePointsCenter[n] * r);
    }
    // Evaluate the transformation function at a new point
    evaluateFunction(t) {
        if (!this.scale || !this.translation) throw new Error("Straight parameters not computed");
        return [
            this.translation[0] + this.scale * t[0],
            this.translation[1] + this.scale * t[1]
        ];
    }
    // Evaluate the transformation function's partial derivative to x at a new point
    evaluatePartialDerivativeX(t) {
        if (!this.scale || !this.translation) throw new Error("Straight parameters not computed");
        return [
            this.scale,
            0
        ];
    }
    // Evaluate the transformation function's partial derivative to y at a new point
    evaluatePartialDerivativeY(t) {
        if (!this.scale || !this.translation) throw new Error("Straight parameters not computed");
        return [
            0,
            this.scale
        ];
    }
}
class Jt extends jt {
    polynomialParametersMatrices;
    polynomialParameters;
    order;
    pointCountMinimum;
    constructor(t, s, e){
        e = e || 1;
        const r = (e + 1) * (e + 2) / 2;
        if (super(t, s, "polynomial" + e, r), this.order = e, this.pointCountMinimum = r, this.order < 1 || this.order > 3) throw new Error("Only polynomial transformations of order 1, 2 or 3 are supported");
        const o = [
            K.columnVector(this.destinationPoints.map((l)=>l[0])),
            K.columnVector(this.destinationPoints.map((l)=>l[1]))
        ], n = K.zeros(this.pointCount, this.pointCountMinimum);
        for(let l = 0; l < this.pointCount; l++)switch(this.order){
            case 1:
                n.set(l, 0, 1), n.set(l, 1, this.sourcePoints[l][0]), n.set(l, 2, this.sourcePoints[l][1]);
                break;
            case 2:
                n.set(l, 0, 1), n.set(l, 1, this.sourcePoints[l][0]), n.set(l, 2, this.sourcePoints[l][1]), n.set(l, 3, this.sourcePoints[l][0] ** 2), n.set(l, 4, this.sourcePoints[l][1] ** 2), n.set(l, 5, this.sourcePoints[l][0] * this.sourcePoints[l][1]);
                break;
            case 3:
                n.set(l, 0, 1), n.set(l, 1, this.sourcePoints[l][0]), n.set(l, 2, this.sourcePoints[l][1]), n.set(l, 3, this.sourcePoints[l][0] ** 2), n.set(l, 4, this.sourcePoints[l][1] ** 2), n.set(l, 5, this.sourcePoints[l][0] * this.sourcePoints[l][1]), n.set(l, 6, this.sourcePoints[l][0] ** 3), n.set(l, 7, this.sourcePoints[l][1] ** 3), n.set(l, 8, this.sourcePoints[l][0] ** 2 * this.sourcePoints[l][1]), n.set(l, 9, this.sourcePoints[l][0] * this.sourcePoints[l][1] ** 2);
                break;
        }
        const h = je(n);
        this.polynomialParametersMatrices = [
            h.mmul(o[0]),
            h.mmul(o[1])
        ], this.polynomialParameters = this.polynomialParametersMatrices.map((l)=>l.to1DArray());
    }
    // Evaluate the transformation function at a new point
    evaluateFunction(t) {
        if (!this.polynomialParameters) throw new Error("Polynomial parameters not computed");
        const s = [
            0,
            0
        ];
        for(let e = 0; e < 2; e++)switch(this.order){
            case 1:
                s[e] += this.polynomialParameters[e][0] + this.polynomialParameters[e][1] * t[0] + this.polynomialParameters[e][2] * t[1];
                break;
            case 2:
                s[e] += this.polynomialParameters[e][0] + this.polynomialParameters[e][1] * t[0] + this.polynomialParameters[e][2] * t[1] + this.polynomialParameters[e][3] * t[0] ** 2 + this.polynomialParameters[e][4] * t[1] ** 2 + this.polynomialParameters[e][5] * t[0] * t[1];
                break;
            case 3:
                s[e] += this.polynomialParameters[e][0] + this.polynomialParameters[e][1] * t[0] + this.polynomialParameters[e][2] * t[1] + this.polynomialParameters[e][3] * t[0] ** 2 + this.polynomialParameters[e][4] * t[1] ** 2 + this.polynomialParameters[e][5] * t[0] * t[1] + this.polynomialParameters[e][6] * t[0] ** 3 + this.polynomialParameters[e][7] * t[1] ** 3 + this.polynomialParameters[e][8] * t[0] ** 2 * t[1] + this.polynomialParameters[e][9] * t[0] * t[1] ** 2;
                break;
        }
        return s;
    }
    // Evaluate the transformation function's partial derivative to x at a new point
    evaluatePartialDerivativeX(t) {
        if (!this.polynomialParameters) throw new Error("Polynomial parameters not computed");
        const s = [
            0,
            0
        ];
        for(let e = 0; e < 2; e++)switch(this.order){
            case 1:
                s[e] += this.polynomialParameters[e][1];
                break;
            case 2:
                s[e] += this.polynomialParameters[e][1] + 2 * this.polynomialParameters[e][3] * t[0] + this.polynomialParameters[e][5] * t[1];
                break;
            case 3:
                s[e] += this.polynomialParameters[e][1] + 2 * this.polynomialParameters[e][3] * t[0] + this.polynomialParameters[e][5] * t[1] + 3 * this.polynomialParameters[e][6] * t[0] ** 2 + 2 * this.polynomialParameters[e][8] * t[0] * t[1] + this.polynomialParameters[e][9] * t[1] ** 2;
                break;
        }
        return s;
    }
    // Evaluate the transformation function's partial derivative to x at a new point
    evaluatePartialDerivativeY(t) {
        if (!this.polynomialParameters) throw new Error("Polynomial parameters not computed");
        const s = [
            0,
            0
        ];
        for(let e = 0; e < 2; e++)switch(this.order){
            case 1:
                s[e] += this.polynomialParameters[e][2];
                break;
            case 2:
                s[e] += this.polynomialParameters[e][2] + 2 * this.polynomialParameters[e][4] * t[1] + this.polynomialParameters[e][5] * t[0];
                break;
            case 3:
                s[e] += this.polynomialParameters[e][2] + 2 * this.polynomialParameters[e][4] * t[1] + this.polynomialParameters[e][5] * t[0] + 3 * this.polynomialParameters[e][7] * t[1] ** 2 + this.polynomialParameters[e][8] * t[0] ** 2 + 2 * this.polynomialParameters[e][9] * t[0] * t[1];
                break;
        }
        return s;
    }
}
class Vs extends jt {
    projectiveParametersMatrix;
    projectiveParameters;
    constructor(t, s){
        super(t, s, "projective", 4);
        const e = K.zeros(2 * this.pointCount, 9);
        for(let o = 0; o < this.pointCount; o++)e.set(2 * o, 0, -t[o][0]), e.set(2 * o, 1, -t[o][1]), e.set(2 * o, 2, -1), e.set(2 * o, 3, 0), e.set(2 * o, 4, 0), e.set(2 * o, 5, 0), e.set(2 * o, 6, s[o][0] * t[o][0]), e.set(2 * o, 7, s[o][0] * t[o][1]), e.set(2 * o, 8, s[o][0]), e.set(2 * o + 1, 0, 0), e.set(2 * o + 1, 1, 0), e.set(2 * o + 1, 2, 0), e.set(2 * o + 1, 3, -t[o][0]), e.set(2 * o + 1, 4, -t[o][1]), e.set(2 * o + 1, 5, -1), e.set(2 * o + 1, 6, s[o][1] * t[o][0]), e.set(2 * o + 1, 7, s[o][1] * t[o][1]), e.set(2 * o + 1, 8, s[o][1]);
        const r = new $s(e);
        this.projectiveParametersMatrix = K.from1DArray(3, 3, r.rightSingularVectors.getColumn(8)).transpose(), this.projectiveParameters = this.projectiveParametersMatrix.to2DArray();
    }
    // Evaluate the transformation function at a new point
    evaluateFunction(t) {
        if (!this.projectiveParameters) throw new Error("projective parameters not computed");
        const s = this.projectiveParameters[0][2] * t[0] + this.projectiveParameters[1][2] * t[1] + this.projectiveParameters[2][2], e = this.projectiveParameters[0][0] * t[0] + this.projectiveParameters[1][0] * t[1] + this.projectiveParameters[2][0], r = this.projectiveParameters[0][1] * t[0] + this.projectiveParameters[1][1] * t[1] + this.projectiveParameters[2][1];
        return [
            e / s,
            r / s
        ];
    }
    // Evaluate the transformation function's partial derivative to x at a new point
    evaluatePartialDerivativeX(t) {
        if (!this.projectiveParameters) throw new Error("projective parameters not computed");
        const s = this.projectiveParameters[0][2] * t[0] + this.projectiveParameters[1][2] * t[1] + this.projectiveParameters[2][2], e = this.projectiveParameters[0][0] * t[0] + this.projectiveParameters[1][0] * t[1] + this.projectiveParameters[2][0], r = this.projectiveParameters[0][1] * t[0] + this.projectiveParameters[1][1] * t[1] + this.projectiveParameters[2][1];
        return [
            (s * this.projectiveParameters[0][0] - this.projectiveParameters[0][2] * e) / s ** 2,
            (s * this.projectiveParameters[0][1] - this.projectiveParameters[0][2] * r) / s ** 2
        ];
    }
    // Evaluate the transformation function's partial derivative to y at a new point
    evaluatePartialDerivativeY(t) {
        if (!this.projectiveParameters) throw new Error("projective parameters not computed");
        const s = this.projectiveParameters[0][2] * t[0] + this.projectiveParameters[1][2] * t[1] + this.projectiveParameters[2][2], e = this.projectiveParameters[0][0] * t[0] + this.projectiveParameters[1][0] * t[1] + this.projectiveParameters[2][0], r = this.projectiveParameters[0][1] * t[0] + this.projectiveParameters[1][1] * t[1] + this.projectiveParameters[2][1];
        return [
            (s * this.projectiveParameters[1][0] - this.projectiveParameters[1][2] * e) / s ** 2,
            (s * this.projectiveParameters[1][1] - this.projectiveParameters[1][2] * r) / s ** 2
        ];
    }
}
class Os extends jt {
    kernelFunction;
    normFunction;
    weightsMatrices;
    rbfWeights;
    affineWeights;
    epsilon;
    constructor(t, s, e, r, o){
        super(t, s, "thinPlateSpline", 3), this.kernelFunction = e, this.normFunction = r;
        const n = [
            K.columnVector([
                ...this.destinationPoints,
                [
                    0,
                    0
                ],
                [
                    0,
                    0
                ],
                [
                    0,
                    0
                ]
            ].map((u)=>u[0])),
            K.columnVector([
                ...this.destinationPoints,
                [
                    0,
                    0
                ],
                [
                    0,
                    0
                ],
                [
                    0,
                    0
                ]
            ].map((u)=>u[1]))
        ], h = K.zeros(this.pointCount, this.pointCount);
        for(let u = 0; u < this.pointCount; u++)for(let g = 0; g < this.pointCount; g++)h.set(u, g, r(this.sourcePoints[u], this.sourcePoints[g]));
        o === void 0 && (o = h.sum() / (Math.pow(this.pointCount, 2) - this.pointCount)), this.epsilon = o;
        for(let u = 0; u < this.pointCount; u++)for(let g = 0; g < this.pointCount; g++)h.set(u, g, e(h.get(u, g), {
            epsilon: o
        }));
        const l = K.zeros(this.pointCount, 3), a = K.zeros(this.pointCount + 3, this.pointCount + 3);
        for(let u = 0; u < this.pointCount; u++)l.set(u, 0, 1), l.set(u, 1, this.sourcePoints[u][0]), l.set(u, 2, this.sourcePoints[u][1]);
        for(let u = 0; u < this.pointCount + 3; u++)for(let g = 0; g < this.pointCount + 3; g++)u < this.pointCount && g < this.pointCount ? a.set(u, g, h.get(u, g)) : u >= this.pointCount && g < this.pointCount ? a.set(u, g, l.transpose().get(u - this.pointCount, g)) : u < this.pointCount && g >= this.pointCount && a.set(u, g, l.get(u, g - this.pointCount));
        const c = Ls(a);
        this.weightsMatrices = [
            c.mmul(n[0]),
            c.mmul(n[1])
        ], this.rbfWeights = this.weightsMatrices.map((u)=>u.selection([
                ...Array(this.pointCount).keys()
            ], [
                0
            ]).to1DArray()), this.affineWeights = this.weightsMatrices.map((u)=>u.selection([
                0,
                1,
                2
            ].map((g)=>g + this.pointCount), [
                0
            ]).to1DArray());
    }
    // Evaluate the transformation function at a new point
    evaluateFunction(t) {
        if (!this.rbfWeights || !this.affineWeights) throw new Error("Weights not computed");
        const s = this.sourcePoints.map((r)=>this.normFunction(t, r)), e = [
            0,
            0
        ];
        for(let r = 0; r < 2; r++)e[r] = s.reduce((o, n, h)=>o + this.kernelFunction(n, {
                epsilon: this.epsilon
            }) * this.rbfWeights[r][h], 0), e[r] += this.affineWeights[r][0] + this.affineWeights[r][1] * t[0] + this.affineWeights[r][2] * t[1];
        return e;
    }
    // Evaluate the transformation function's partial derivative to x at a new point
    evaluatePartialDerivativeX(t) {
        if (!this.rbfWeights || !this.affineWeights) throw new Error("Weights not computed");
        const s = this.sourcePoints.map((r)=>this.normFunction(t, r)), e = [
            0,
            0
        ];
        for(let r = 0; r < 2; r++)e[r] = s.reduce((o, n, h)=>o + (n == 0 ? 0 : this.kernelFunction(n, {
                derivative: 1,
                epsilon: this.epsilon
            }) * ((t[0] - this.sourcePoints[h][0]) / n) * this.rbfWeights[r][h]), 0), e[r] += this.affineWeights[r][1];
        return e;
    }
    // Evaluate the transformation function's partial derivative to y at a new point
    evaluatePartialDerivativeY(t) {
        if (!this.rbfWeights || !this.affineWeights) throw new Error("Weights not computed");
        const s = this.sourcePoints.map((r)=>this.normFunction(t, r)), e = [
            0,
            0
        ];
        for(let r = 0; r < 2; r++)e[r] = s.reduce((o, n, h)=>o + (n == 0 ? 0 : this.kernelFunction(n, {
                derivative: 1,
                epsilon: this.epsilon
            }) * ((t[1] - this.sourcePoints[h][1]) / n) * this.rbfWeights[r][h]), 0), e[r] += this.affineWeights[r][2];
        return e;
    }
}
function Ws(i, t) {
    if (t.derivative) {
        if (t.derivative == 1) return i === 0 ? 0 : i + 2 * i * Math.log(i);
        throw new Error("Derivate of order " + t.derivative + " not implemented");
    } else return i === 0 ? 0 : Math.pow(i, 2) * Math.log(i);
}
function Us(i, t) {
    const s = [
        t[0] - i[0],
        t[1] - i[1]
    ];
    return Math.sqrt(s[0] ** 2 + s[1] ** 2);
}
function q(i, t, s) {
    return {
        ...{
            maxOffsetRatio: 0,
            maxDepth: 0,
            destinationIsGeographic: !1,
            sourceIsGeographic: !1,
            inputIsMultiGeometry: !1,
            differentHandedness: !1,
            evaluationType: "function"
        },
        ...s,
        ...t,
        ...i
    };
}
function qt(i, t, s) {
    t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["conformLineString"])(t);
    const e = t.map((n)=>({
            source: n,
            destination: i.transformForward(n)
        })), r = Xt(e, !1), o = Pe(i, r, s);
    return Qt(o, !0).map((n)=>n.destination);
}
function Bt(i, t, s) {
    t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["conformLineString"])(t);
    const e = t.map((n)=>({
            source: i.transformBackward(n),
            destination: n
        })), r = Xt(e, !1), o = ve(i, r, s);
    return Qt(o, !0).map((n)=>n.source);
}
function Ys(i, t, s) {
    t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["conformRing"])(t);
    const e = t.map((n)=>({
            source: n,
            destination: i.transformForward(n)
        })), r = Xt(e, !0), o = Pe(i, r, s);
    return Qt(o, !1).map((n)=>n.destination);
}
function _s(i, t, s) {
    t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["conformRing"])(t);
    const e = t.map((n)=>({
            source: i.transformBackward(n),
            destination: n
        })), r = Xt(e, !0), o = ve(i, r, s);
    return Qt(o, !1).map((n)=>n.source);
}
function $t(i, t, s) {
    return t.map((e)=>Ys(i, e, s));
}
function Lt(i, t, s) {
    return t.map((e)=>_s(i, e, s));
}
function Xt(i, t = !1) {
    const s = i.length - (t ? 0 : 1), e = [];
    for(let r = 0; r < s; r++)e.push({
        from: i[r],
        to: i[(r + 1) % i.length]
    });
    return e;
}
function Qt(i, t = !1) {
    const s = i.map((e)=>e.from);
    return t && s.push(i[i.length - 1].to), s;
}
function Pe(i, t, s) {
    return s.maxDepth <= 0 ? t : t.map((e)=>At(i, e, s, 0)).flat(1);
}
function ve(i, t, s) {
    return s.maxDepth <= 0 ? t : t.map((e)=>xt(i, e, s, 0)).flat(1);
}
function At(i, t, s, e) {
    if (e >= s.maxDepth) return t;
    const o = (s.sourceIsGeographic ? (g, y)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$midpoint$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(g, y).geometry.coordinates : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["midPoint"])(t.from.source, t.to.source), h = (s.destinationIsGeographic ? (g, y)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$midpoint$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(g, y).geometry.coordinates : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["midPoint"])(t.from.destination, t.to.destination), l = i.transformForward(o), a = s.destinationIsGeographic ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"], c = a(t.from.destination, t.to.destination);
    if (a(h, l) / c > s.maxOffsetRatio && c > 0) {
        const g = {
            source: o,
            destination: l
        };
        return [
            At(i, {
                from: t.from,
                to: g
            }, s, e + 1),
            At(i, {
                from: g,
                to: t.to
            }, s, e + 1)
        ].flat(1);
    } else return t;
}
function xt(i, t, s, e) {
    if (e >= s.maxDepth) return t;
    const o = (s.destinationIsGeographic ? (g, y)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$midpoint$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(g, y).geometry.coordinates : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["midPoint"])(t.from.destination, t.to.destination), h = (s.sourceIsGeographic ? (g, y)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$midpoint$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(g, y).geometry.coordinates : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["midPoint"])(t.from.source, t.to.source), l = i.transformBackward(o), a = s.sourceIsGeographic ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"], c = a(t.from.source, t.to.source);
    if (a(h, l) / c > s.maxOffsetRatio && c > 0) {
        const g = {
            source: l,
            destination: o
        };
        return [
            xt(i, {
                from: t.from,
                to: g
            }, s, e + 1),
            xt(i, {
                from: g,
                to: t.to
            }, s, e + 1)
        ].flat(1);
    } else return t;
}
class As {
    gcps;
    sourcePoints;
    destinationPoints;
    type;
    options;
    forwardTransformation;
    backwardTransformation;
    /**
   * Create a GcpTransformer
   * @param {TransformGcp[] | Gcp[]} gcps - An array of Ground Control Points (GCPs)
   * @param {TransformationType} [type='polynomial'] - The transformation type
   */ constructor(t, s = "polynomial", e){
        if (e && (this.options = e), t.length === 0) throw new Error("No control points");
        this.gcps = t.map((r)=>{
            if ("resource" in r && "geo" in r) return {
                source: r.resource,
                destination: r.geo
            };
            if ("source" in r && "destination" in r) return r;
            throw new Error("Unsupported GCP type");
        }), this.sourcePoints = this.gcps.map((r)=>r.source), this.destinationPoints = this.gcps.map((r)=>r.destination), this.type = s;
    }
    /**
   * Create forward transformation
   */ createForwardTransformation() {
        this.forwardTransformation = this.computeTransformation(this.sourcePoints.map((t)=>this.assureEqualHandedness(t)), this.destinationPoints);
    }
    /**
   * Create backward transformation
   */ createBackwardTransformation() {
        this.backwardTransformation = this.computeTransformation(this.destinationPoints, this.sourcePoints.map((t)=>this.assureEqualHandedness(t)));
    }
    /**
   * Transforms a Geometry or a GeoJSON geometry forward to a Geometry
   * @param {Geometry | GeojsonGeometry} input - Geometry or GeoJSON geometry to transform
   * @param {Partial<TransformOptions>} [options] - Transform options
   * @returns {Geometry} Forward transform of input as Geometry
   * @type {{
   * (input:Point | GeojsonPoint) => Point;
   * (input:LineString | GeojsonLineString) => LineString;
   * (input:Polygon | GeojsonPolygon) => Polygon;
   * (input:MultiPoint | GeojsonMultiPoint) => MultiPoint;
   * (input:MultiLineString | GeojsonMultiLineString) => MultiLineString;
   * (input:MultiPolygon | GeojsonMultiPolygon) => MultiPolygon;
   * }}
   */ transformForward(t, s) {
        if (!q(s, this.options).inputIsMultiGeometry) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPoint"])(t)) return this.forwardTransformation || this.createForwardTransformation(), this.forwardTransformation.evaluate(this.assureEqualHandedness(t), q(s, this.options).evaluationType);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPoint"])(t)) return this.transformForward((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertGeojsonPointToPoint"])(t), s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLineString"])(t)) return qt(this, t, q(s, this.options));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonLineString"])(t)) return qt(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertGeojsonLineStringToLineString"])(t), q(s, this.options, {
                sourceIsGeographic: !0
            }));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolygon"])(t)) return $t(this, t, q(s, this.options));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPolygon"])(t)) return $t(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertGeojsonPolygonToPolygon"])(t), q(s, this.options, {
                sourceIsGeographic: !0
            }));
        }
        if (s && (s.inputIsMultiGeometry = !1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPoint"])(t)) return t.map((e)=>this.transformForward(e, s));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPoint"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["expandGeojsonMultiPointToGeojsonPointArray"])(t).map((e)=>this.transformForward(e, s));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiLineString"])(t)) return t.map((e)=>this.transformForward(e, s));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiLineString"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["expandGeojsonMultiLineStringToGeojsonLineStringArray"])(t).map((e)=>this.transformForward(e, s));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPolygon"])(t)) return t.map((e)=>this.transformForward(e, s));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPolygon"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["expandGeojsonMultiPolygonToGeojsonPolygonArray"])(t).map((e)=>this.transformForward(e, s));
        throw new Error("Input type not supported");
    }
    /**
   * Transforms a Geometry or a GeoJSON geometry forward to a GeoJSON geometry
   * @param {Geometry | GeojsonGeometry} input - Geometry or GeoJSON geometry to transform
   * @param {Partial<TransformOptions>} [options] - Transform options
   * @returns {GeojsonGeometry} Forward transform of input, as GeoJSON geometry
   * @type {{
   * (input:Point | GeojsonPoint) => GeojsonPoint;
   * (input:LineString | GeojsonLineString) => GeojsonLineString;
   * (input:Polygon | GeojsonPolygon) => GeojsonPolygon;
   * (input:MultiPoint | GeojsonMultiPoint) => GeojsonMultiPoint;
   * (input:MultiLineString | GeojsonMultiLineString) => GeojsonMultiLineString;
   * (input:MultiPolygon | GeojsonMultiPolygon) => GeojsonMultiPolygon;
   * }}
   */ transformForwardAsGeojson(t, s) {
        if (!q(s, this.options).inputIsMultiGeometry) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPoint"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPointToGeojsonPoint"])(this.transformForward(t));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPoint"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPointToGeojsonPoint"])(this.transformForward((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertGeojsonPointToPoint"])(t)));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLineString"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertLineStringToGeojsonLineString"])(qt(this, t, q(s, this.options, {
                destinationIsGeographic: !0
            })));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonLineString"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertLineStringToGeojsonLineString"])(qt(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertGeojsonLineStringToLineString"])(t), q(s, this.options, {
                sourceIsGeographic: !0,
                destinationIsGeographic: !0
            })));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolygon"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPolygonToGeojsonPolygon"])($t(this, t, q(s, this.options, {
                destinationIsGeographic: !0
            })));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPolygon"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPolygonToGeojsonPolygon"])($t(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertGeojsonPolygonToPolygon"])(t), q(s, this.options, {
                sourceIsGeographic: !0,
                destinationIsGeographic: !0
            })));
        }
        if (s && (s.inputIsMultiGeometry = !1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPoint"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinGeojsonPointArrayToGeojsonMultiPoint"])(t.map((e)=>this.transformForwardAsGeojson(e, s)));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPoint"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinGeojsonPointArrayToGeojsonMultiPoint"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["expandGeojsonMultiPointToGeojsonPointArray"])(t).map((e)=>this.transformForwardAsGeojson(e, s)));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiLineString"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinGeojsonLineStringArrayToGeojsonMultiLineString"])(t.map((e)=>this.transformForwardAsGeojson(e, s)));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiLineString"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinGeojsonLineStringArrayToGeojsonMultiLineString"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["expandGeojsonMultiLineStringToGeojsonLineStringArray"])(t).map((e)=>this.transformForwardAsGeojson(e, s)));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPolygon"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinGeojsonPolygonArrayToGeojsonMultiPolygon"])(t.map((e)=>this.transformForwardAsGeojson(e, s)));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPolygon"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinGeojsonPolygonArrayToGeojsonMultiPolygon"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["expandGeojsonMultiPolygonToGeojsonPolygonArray"])(t).map((e)=>this.transformForwardAsGeojson(e, s)));
        throw new Error("Input type not supported");
    }
    /**
   * Transforms a geometry or a GeoJSON geometry backward to a Geometry
   * @param {Geometry | GeojsonGeometry} input - Geometry or GeoJSON geometry to transform
   * @param {Partial<TransformOptions>} [options] - Transform options
   * @returns {Geometry} backward transform of input, as geometry
   * @type {{
   * (input:Point | GeojsonPoint) => Point;
   * (input:LineString | GeojsonLineString) => LineString;
   * (input:Polygon | GeojsonPolygon) => Polygon;
   * (input:MultiPoint | GeojsonMultiPoint) => MultiPoint;
   * (input:MultiLineString | GeojsonMultiLineString) => MultiLineString;
   * (input:MultiPolygon | GeojsonMultiPolygon) => MultiPolygon;
   * }}
   */ transformBackward(t, s) {
        if (!q(s, this.options).inputIsMultiGeometry) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPoint"])(t)) return this.backwardTransformation || this.createBackwardTransformation(), this.assureEqualHandedness(this.backwardTransformation.evaluate(t));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPoint"])(t)) return this.transformBackward((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertGeojsonPointToPoint"])(t));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLineString"])(t)) return Bt(this, t, q(s, this.options));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonLineString"])(t)) return Bt(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertGeojsonLineStringToLineString"])(t), q(s, this.options, {
                destinationIsGeographic: !0
            }));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolygon"])(t)) return Lt(this, t, q(s, this.options));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPolygon"])(t)) return Lt(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertGeojsonPolygonToPolygon"])(t), q(s, this.options, {
                destinationIsGeographic: !0
            }));
        }
        if (s && (s.inputIsMultiGeometry = !1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPoint"])(t)) return t.map((e)=>this.transformBackward(e, s));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPoint"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["expandGeojsonMultiPointToGeojsonPointArray"])(t).map((e)=>this.transformBackward(e, s));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiLineString"])(t)) return t.map((e)=>this.transformBackward(e, s));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiLineString"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["expandGeojsonMultiLineStringToGeojsonLineStringArray"])(t).map((e)=>this.transformBackward(e, s));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPolygon"])(t)) return t.map((e)=>this.transformBackward(e, s));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPolygon"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["expandGeojsonMultiPolygonToGeojsonPolygonArray"])(t).map((e)=>this.transformBackward(e, s));
        throw new Error("Input type not supported");
    }
    /**
   * Transforms a Geometry or a GeoJSON geometry backward to a GeoJSON geometry
   * @param {Geometry | GeojsonGeometry} input - Geometry or GeoJSON geometry to transform
   * @param {Partial<TransformOptions>} [options] - Transform options
   * @returns {GeojsonGeometry} backward transform of input, as GeoJSON geometry
   * @type {{
   * (input:Point | GeojsonPoint) => GeojsonPoint;
   * (input:LineString | GeojsonLineString) => GeojsonLineString;
   * (input:Polygon | GeojsonPolygon) => GeojsonPolygon;
   * (input:MultiPoint | GeojsonMultiPoint) => GeojsonMultiPoint;
   * (input:MultiLineString | GeojsonMultiLineString) => GeojsonMultiLineString;
   * (input:MultiPolygon | GeojsonMultiPolygon) => GeojsonMultiPolygon;
   * }}
   */ transformBackwardAsGeojson(t, s) {
        if (!q(s, this.options).inputIsMultiGeometry) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPoint"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPointToGeojsonPoint"])(this.transformBackward(t));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPoint"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPointToGeojsonPoint"])(this.transformBackward((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertGeojsonPointToPoint"])(t)));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLineString"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertLineStringToGeojsonLineString"])(Bt(this, t, q(s, this.options, {
                sourceIsGeographic: !0
            })));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonLineString"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertLineStringToGeojsonLineString"])(Bt(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertGeojsonLineStringToLineString"])(t), q(s, this.options, {
                sourceIsGeographic: !0,
                destinationIsGeographic: !0
            })));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolygon"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPolygonToGeojsonPolygon"])(Lt(this, t, q(s, this.options, {
                sourceIsGeographic: !0
            })));
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPolygon"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPolygonToGeojsonPolygon"])(Lt(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertGeojsonPolygonToPolygon"])(t), q(s, this.options, {
                sourceIsGeographic: !0,
                destinationIsGeographic: !0
            })));
        }
        if (s && (s.inputIsMultiGeometry = !1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPoint"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinGeojsonPointArrayToGeojsonMultiPoint"])(t.map((e)=>this.transformBackwardAsGeojson(e, s)));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPoint"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinGeojsonPointArrayToGeojsonMultiPoint"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["expandGeojsonMultiPointToGeojsonPointArray"])(t).map((e)=>this.transformBackwardAsGeojson(e, s)));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiLineString"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinGeojsonLineStringArrayToGeojsonMultiLineString"])(t.map((e)=>this.transformBackwardAsGeojson(e, s)));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiLineString"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinGeojsonLineStringArrayToGeojsonMultiLineString"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["expandGeojsonMultiLineStringToGeojsonLineStringArray"])(t).map((e)=>this.transformBackwardAsGeojson(e, s)));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPolygon"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinGeojsonPolygonArrayToGeojsonMultiPolygon"])(t.map((e)=>this.transformBackwardAsGeojson(e, s)));
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPolygon"])(t)) return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["joinGeojsonPolygonArrayToGeojsonMultiPolygon"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["expandGeojsonMultiPolygonToGeojsonPolygonArray"])(t).map((e)=>this.transformBackwardAsGeojson(e, s)));
        throw new Error("Input type not supported");
    }
    /**
   * Transforms Geometry or GeoJSON geometry forward, as Geometry
   * @param {Geometry | GeojsonGeometry} input - Input to transform
   * @param {Partial<TransformOptions>} [options] - Transform options
   * @returns {Geometry} Forward transform of input, as Geometry
   * @type {{
   * (input:Point | GeojsonPoint) => Point;
   * (input:LineString | GeojsonLineString) => LineString;
   * (input:Polygon | GeojsonPolygon) => Polygon;
   * (input:MultiPoint | GeojsonMultiPoint) => MultiPoint;
   * (input:MultiLineString | GeojsonMultiLineString) => MultiLineString;
   * (input:MultiPolygon | GeojsonMultiPolygon) => MultiPolygon;
   * }}
   */ transformToGeo(t, s) {
        if (!q(s, this.options).inputIsMultiGeometry) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPoint"])(t)) return this.transformForward(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPoint"])(t)) return this.transformForward(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLineString"])(t)) return this.transformForward(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonLineString"])(t)) return this.transformForward(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolygon"])(t)) return this.transformForward(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPolygon"])(t)) return this.transformForward(t, s);
        }
        if (s && (s.inputIsMultiGeometry = !1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPoint"])(t)) return this.transformForward(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPoint"])(t)) return this.transformForward(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiLineString"])(t)) return this.transformForward(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiLineString"])(t)) return this.transformForward(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPolygon"])(t)) return this.transformForward(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPolygon"])(t)) return this.transformForward(t, s);
        throw new Error("Input type not supported");
    }
    /**
   * Transforms a Geometry or a GeoJSON geometry forward, to a GeoJSON geometry
   * @param {Geometry | GeojsonGeometry} input - Input to transform
   * @param {Partial<TransformOptions>} [options] - Transform options
   * @returns {Geometry} Forward transform of input, as GeoJSON geometry
   * @type {{
   * (input:Point | GeojsonPoint) => GeojsonPoint;
   * (input:LineString | GeojsonLineString) => GeojsonLineString;
   * (input:Polygon | GeojsonPolygon) => GeojsonPolygon;
   * (input:MultiPoint | GeojsonMultiPoint) => GeojsonMultiPoint;
   * (input:MultiLineString | GeojsonMultiLineString) => GeojsonMultiLineString;
   * (input:MultiPolygon | GeojsonMultiPolygon) => GeojsonMultiPolygon;
   * }}
   */ transformToGeoAsGeojson(t, s) {
        if (!q(s, this.options).inputIsMultiGeometry) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPoint"])(t)) return this.transformForwardAsGeojson(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPoint"])(t)) return this.transformForwardAsGeojson(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLineString"])(t)) return this.transformForwardAsGeojson(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonLineString"])(t)) return this.transformForwardAsGeojson(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolygon"])(t)) return this.transformForwardAsGeojson(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPolygon"])(t)) return this.transformForwardAsGeojson(t, s);
        }
        if (s && (s.inputIsMultiGeometry = !1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPoint"])(t)) return this.transformForwardAsGeojson(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPoint"])(t)) return this.transformForwardAsGeojson(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiLineString"])(t)) return this.transformForwardAsGeojson(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiLineString"])(t)) return this.transformForwardAsGeojson(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPolygon"])(t)) return this.transformForwardAsGeojson(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPolygon"])(t)) return this.transformForwardAsGeojson(t, s);
        throw new Error("Input type not supported");
    }
    /**
   * Transforms a Geometry or a GeoJSON geometry backward, to a Geometry
   * @param {Geometry | GeojsonGeometry} input - Input to transform
   * @param {Partial<TransformOptions>} [options] - Transform options
   * @returns {Geometry} Backward transform of input, as a Geometry
   * @type {{
   * (input:Point | GeojsonPoint) => Point;
   * (input:LineString | GeojsonLineString) => LineString;
   * (input:Polygon | GeojsonPolygon) => Polygon;
   * (input:MultiPoint | GeojsonMultiPoint) => MultiPoint;
   * (input:MultiLineString | GeojsonMultiLineString) => MultiLineString;
   * (input:MultiPolygon | GeojsonMultiPolygon) => MultiPolygon;
   * }}
   */ transformToResource(t, s) {
        if (!q(s, this.options).inputIsMultiGeometry) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPoint"])(t)) return this.transformBackward(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPoint"])(t)) return this.transformBackward(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLineString"])(t)) return this.transformBackward(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonLineString"])(t)) return this.transformBackward(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolygon"])(t)) return this.transformBackward(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPolygon"])(t)) return this.transformBackward(t, s);
        }
        if (s && (s.inputIsMultiGeometry = !1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPoint"])(t)) return this.transformBackward(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPoint"])(t)) return this.transformBackward(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiLineString"])(t)) return this.transformBackward(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiLineString"])(t)) return this.transformBackward(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPolygon"])(t)) return this.transformBackward(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPolygon"])(t)) return this.transformBackward(t, s);
        throw new Error("Input type not supported");
    }
    /**
   * Transforms a Geometry or a GeoJSON geometry backward, to a GeoJSON geometry
   * @param {Geometry | GeojsonGeometry} input - Input to transform
   * @param {Partial<TransformOptions>} [options] - Transform options
   * @returns {GeojsonGeometry} Backward transform of input, as a GeoJSON geometry
   * @type {{
   * (input:Point | GeojsonPoint) => GeojsonPoint;
   * (input:LineString | GeojsonLineString) => GeojsonLineString;
   * (input:Polygon | GeojsonPolygon) => GeojsonPolygon;
   * (input:MultiPoMultiint | GeojsonMultiPoint) => GeojsonMultiPoint;
   * (input:MultiLineString | GeojsonMultiLineString) => GeojsonMultiLineString;
   * (input:MultiPolygon | GeojsonMultiPolygon) => GeojsonMultiPolygon;
   * }}
   */ transformToResourceAsGeojson(t, s) {
        if (!q(s, this.options).inputIsMultiGeometry) {
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPoint"])(t)) return this.transformBackwardAsGeojson(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPoint"])(t)) return this.transformBackwardAsGeojson(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLineString"])(t)) return this.transformBackwardAsGeojson(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonLineString"])(t)) return this.transformBackwardAsGeojson(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolygon"])(t)) return this.transformBackwardAsGeojson(t, s);
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonPolygon"])(t)) return this.transformBackwardAsGeojson(t, s);
        }
        if (s && (s.inputIsMultiGeometry = !1), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPoint"])(t)) return this.transformBackwardAsGeojson(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPoint"])(t)) return this.transformBackwardAsGeojson(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiLineString"])(t)) return this.transformBackwardAsGeojson(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiLineString"])(t)) return this.transformBackwardAsGeojson(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPolygon"])(t)) return this.transformBackwardAsGeojson(t, s);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonMultiPolygon"])(t)) return this.transformBackwardAsGeojson(t, s);
        throw new Error("Input type not supported");
    }
    // Shortcuts for SVG <> GeoJSON
    /**
   * Transforms a SVG geometry forward to a GeoJSON geometry
   *
   * Note: Multi-geometries are not supported
   * @param {SvgGeometry} geometry - SVG geometry to transform
   * @param {Partial<TransformOptions>} [options] - Transform options
   * @returns {GeojsonGeometry} Forward transform of input, as a GeoJSON geometry
   */ transformSvgToGeojson(t, s) {
        if (t.type === "circle") return this.transformForwardAsGeojson(t.coordinates);
        if (t.type === "line") return this.transformForwardAsGeojson(t.coordinates, s);
        if (t.type === "polyline") return this.transformForwardAsGeojson(t.coordinates, s);
        if (t.type === "rect") return this.transformForwardAsGeojson([
            t.coordinates
        ], s);
        if (t.type === "polygon") return this.transformForwardAsGeojson([
            t.coordinates
        ], s);
        throw new Error("Unsupported SVG geometry");
    }
    /**
   * Transforms a SVG string forward to a GeoJSON FeatureCollection
   *
   * Note: Multi-geometries are not supported
   * @param {string} svg - SVG string to transform
   * @param {Partial<TransformOptions>} [options] - Transform options
   * @returns {GeojsonFeatureCollection} Forward transform of input, as a GeoJSON FeatureCollection
   */ transformSvgStringToGeojsonFeatureCollection(t, s) {
        const e = [];
        for (const r of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$svg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringToSvgGeometriesGenerator"])(t)){
            const o = this.transformSvgToGeojson(r, s);
            e.push(o);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["geometriesToFeatureCollection"])(e);
    }
    /**
   * Transforms a GeoJSON geometry backward to a SVG geometry
   *
   * Note: Multi-geometries are not supported
   * @param {GeojsonGeometry} geometry - GeoJSON geometry to transform
   * @param {Partial<TransformOptions>} [options] - Transform options
   * @returns {SvgGeometry} Backward transform of input, as SVG geometry
   */ transformGeojsonToSvg(t, s) {
        if (t.type === "Point") return {
            type: "circle",
            coordinates: this.transformBackward(t)
        };
        if (t.type === "LineString") return {
            type: "polyline",
            coordinates: this.transformBackward(t, s)
        };
        if (t.type === "Polygon") return {
            type: "polygon",
            coordinates: this.transformBackward(t, s)[0]
        };
        throw new Error("Unsupported GeoJSON geometry");
    }
    /**
   * Transforms a GeoJSON FeatureCollection backward to a SVG string
   *
   * Note: Multi-geometries are not supported
   * @param {GeojsonFeatureCollection} geojson - GeoJSON FeatureCollection to transform
   * @param {Partial<TransformOptions>} [options] - Transform options
   * @returns {string} Backward transform of input, as SVG string
   */ transformGeojsonFeatureCollectionToSvgString(t, s) {
        const e = [];
        for (const r of (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["featureCollectionToGeometries"])(t)){
            const o = this.transformGeojsonToSvg(r, s);
            e.push(o);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$svg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["svgGeometriesToSvgString"])(e);
    }
    assureEqualHandedness(t) {
        return this.options?.differentHandedness ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["flipY"])(t) : t;
    }
    computeTransformation(t, s) {
        if (this.type === "straight") return new zs(t, s);
        if (this.type === "helmert") return new Me(t, s);
        if (this.type === "polynomial1" || this.type === "polynomial") return new Jt(t, s);
        if (this.type === "polynomial2") return new Jt(t, s, 2);
        if (this.type === "polynomial3") return new Jt(t, s, 3);
        if (this.type === "projective") return new Vs(t, s);
        if (this.type === "thinPlateSpline") return new Os(t, s, Ws, Us);
        throw new Error(`Unsupported transformation type: ${this.type}`);
    }
}
const Xs = [
    "log2sigma",
    "twoOmega",
    "airyKavr",
    "signDetJ",
    "thetaa"
];
function xs(i, t, s, e = 1) {
    if (!s) return 0;
    const r = i[0] ** 2 + i[1] ** 2, o = t[0] ** 2 + t[1] ** 2, n = i[0] * t[0] + i[1] * t[1], h = Math.sqrt(0.5 * (r + o + Math.sqrt((r - o) ** 2 + 4 * n ** 2))), l = Math.sqrt(0.5 * (r + o - Math.sqrt((r - o) ** 2 + 4 * n ** 2))), a = Math.atan(i[1] / i[0]), c = Math.sign(-n) * Math.asin(Math.sqrt((1 - h ** 2 / r) / (1 - (h / l) ** 2)));
    switch(Xs.indexOf(s)){
        case 0:
            return (Math.log(h * l) - 2 * Math.log(e)) / Math.log(2);
        case 1:
            return 2 * Math.asin((h - l) / (h + l));
        case 2:
            return 0.5 * (Math.log(h / e) ** 2 + Math.log(l / e) ** 2);
        case 3:
            return Math.sign(i[0] * t[1] - i[1] * t[0]);
        case 4:
            return a - c;
        default:
            throw new Error("Distortion " + s + " not supported");
    }
}
;
 //# sourceMappingURL=index.es.js.map

})()),
}]);

//# sourceMappingURL=node_modules_%40allmaps_transform_dist_bundled_index_es_a8e89d.js.map