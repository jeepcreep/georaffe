(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_12d472._.js", {

"[project]/node_modules/global/window.js [app-client] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports, t: require }) { !function() {

var win;
if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined") {
    win = self;
} else {
    win = {};
}
module.exports = win;

}.call(this) }),
"[project]/node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js [app-client] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports, t: require }) { !function() {

"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _jsxruntime = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
const _dynamicbailouttocsr = __turbopack_require__("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/dynamic-bailout-to-csr.js [app-client] (ecmascript)");
const _preloadcss = __turbopack_require__("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/preload-css.js [app-client] (ecmascript)");
// Normalize loader to return the module as form { default: Component } for `React.lazy`.
// Also for backward compatible since next/dynamic allows to resolve a component directly with loader
// Client component reference proxy need to be converted to a module.
function convertModule(mod) {
    // Check "default" prop before accessing it, as it could be client reference proxy that could break it reference.
    // Cases:
    // mod: { default: Component }
    // mod: Component
    // mod: { $$typeof, default: proxy(Component) }
    // mod: proxy(Component)
    const hasDefault = mod && "default" in mod;
    return {
        default: hasDefault ? mod.default : mod
    };
}
const defaultOptions = {
    loader: ()=>Promise.resolve(convertModule(()=>null)),
    loading: null,
    ssr: true
};
function Loadable(options) {
    const opts = {
        ...defaultOptions,
        ...options
    };
    const Lazy = /*#__PURE__*/ (0, _react.lazy)(()=>opts.loader().then(convertModule));
    const Loading = opts.loading;
    function LoadableComponent(props) {
        const fallbackElement = Loading ? /*#__PURE__*/ (0, _jsxruntime.jsx)(Loading, {
            isLoading: true,
            pastDelay: true,
            error: null
        }) : null;
        const children = opts.ssr ? /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
            children: [
                typeof window === "undefined" ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_preloadcss.PreloadCss, {
                    moduleIds: opts.modules
                }) : null,
                /*#__PURE__*/ (0, _jsxruntime.jsx)(Lazy, {
                    ...props
                })
            ]
        }) : /*#__PURE__*/ (0, _jsxruntime.jsx)(_dynamicbailouttocsr.BailoutToCSR, {
            reason: "next/dynamic",
            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(Lazy, {
                ...props
            })
        });
        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {
            fallback: fallbackElement,
            children: children
        });
    }
    LoadableComponent.displayName = "LoadableComponent";
    return LoadableComponent;
}
const _default = Loadable; //# sourceMappingURL=loadable.js.map

}.call(this) }),
"[project]/node_modules/next/dist/shared/lib/app-dynamic.js [app-client] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports, t: require }) { !function() {

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return dynamic;
    }
});
const _interop_require_default = __turbopack_require__("[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)");
const _jsxruntime = __turbopack_require__("[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)");
const _react = /*#__PURE__*/ _interop_require_default._(__turbopack_require__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"));
const _loadable = /*#__PURE__*/ _interop_require_default._(__turbopack_require__("[project]/node_modules/next/dist/shared/lib/lazy-dynamic/loadable.js [app-client] (ecmascript)"));
function dynamic(dynamicOptions, options) {
    var _mergedOptions_loadableGenerated;
    let loadableOptions = {
        // A loading component is not required, so we default it
        loading: (param)=>{
            let { error, isLoading, pastDelay } = param;
            if (!pastDelay) return null;
            if ("TURBOPACK compile-time truthy", 1) {
                if (isLoading) {
                    return null;
                }
                if (error) {
                    return /*#__PURE__*/ (0, _jsxruntime.jsxs)("p", {
                        children: [
                            error.message,
                            /*#__PURE__*/ (0, _jsxruntime.jsx)("br", {}),
                            error.stack
                        ]
                    });
                }
            }
            return null;
        }
    };
    if (typeof dynamicOptions === "function") {
        loadableOptions.loader = dynamicOptions;
    }
    const mergedOptions = {
        ...loadableOptions,
        ...options
    };
    return (0, _loadable.default)({
        ...mergedOptions,
        modules: (_mergedOptions_loadableGenerated = mergedOptions.loadableGenerated) == null ? void 0 : _mergedOptions_loadableGenerated.modules
    });
}
if ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {
    Object.defineProperty(exports.default, '__esModule', {
        value: true
    });
    Object.assign(exports.default, exports);
    module.exports = exports.default;
} //# sourceMappingURL=app-dynamic.js.map

}.call(this) }),
"[project]/node_modules/@react-leaflet/core/lib/context.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "CONTEXT_VERSION": ()=>CONTEXT_VERSION,
    "LeafletContext": ()=>LeafletContext,
    "LeafletProvider": ()=>LeafletProvider,
    "createLeafletContext": ()=>createLeafletContext,
    "extendContext": ()=>extendContext,
    "useLeafletContext": ()=>useLeafletContext
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
const CONTEXT_VERSION = 1;
function createLeafletContext(map) {
    return Object.freeze({
        __version: CONTEXT_VERSION,
        map
    });
}
function extendContext(source, extra) {
    return Object.freeze({
        ...source,
        ...extra
    });
}
const LeafletContext = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContext"])(null);
const LeafletProvider = LeafletContext.Provider;
function useLeafletContext() {
    const context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useContext"])(LeafletContext);
    if (context == null) {
        throw new Error('No context provided: useLeafletContext() can only be used in a descendant of <MapContainer>');
    }
    return context;
}

})()),
"[project]/node_modules/@react-leaflet/core/lib/element.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "createElementHook": ()=>createElementHook,
    "createElementObject": ()=>createElementObject
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
function createElementObject(instance, context, container) {
    return Object.freeze({
        instance,
        context,
        container
    });
}
function createElementHook(createElement, updateElement) {
    if (updateElement == null) {
        return function useImmutableLeafletElement(props, context) {
            const elementRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
            if (!elementRef.current) elementRef.current = createElement(props, context);
            return elementRef;
        };
    }
    return function useMutableLeafletElement(props, context) {
        const elementRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
        if (!elementRef.current) elementRef.current = createElement(props, context);
        const propsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(props);
        const { instance } = elementRef.current;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function updateElementProps() {
            if (propsRef.current !== props) {
                updateElement(instance, props, propsRef.current);
                propsRef.current = props;
            }
        }, [
            instance,
            props,
            context
        ]);
        return elementRef;
    };
}

})()),
"[project]/node_modules/@react-leaflet/core/lib/component.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "createContainerComponent": ()=>createContainerComponent,
    "createDivOverlayComponent": ()=>createDivOverlayComponent,
    "createLeafComponent": ()=>createLeafComponent
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/context.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
function createContainerComponent(useElement) {
    function ContainerComponent(props, forwardedRef) {
        const { instance, context } = useElement(props).current;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(forwardedRef, ()=>instance);
        return props.children == null ? null : /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LeafletProvider"], {
            value: context
        }, props.children);
    }
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(ContainerComponent);
}
function createDivOverlayComponent(useElement) {
    function OverlayComponent(props, forwardedRef) {
        const [isOpen, setOpen] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(false);
        const { instance } = useElement(props, setOpen).current;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(forwardedRef, ()=>instance);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function updateOverlay() {
            if (isOpen) {
                instance.update();
            }
        }, [
            instance,
            isOpen,
            props.children
        ]);
        // @ts-ignore _contentNode missing in type definition
        const contentNode = instance._contentNode;
        return contentNode ? /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createPortal"])(props.children, contentNode) : null;
    }
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(OverlayComponent);
}
function createLeafComponent(useElement) {
    function LeafComponent(props, forwardedRef) {
        const { instance } = useElement(props).current;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(forwardedRef, ()=>instance);
        return null;
    }
    return /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(LeafComponent);
}

})()),
"[project]/node_modules/@react-leaflet/core/lib/control.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "createControlHook": ()=>createControlHook
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/context.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
function createControlHook(useElement) {
    return function useLeafletControl(props) {
        const context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLeafletContext"])();
        const elementRef = useElement(props, context);
        const { instance } = elementRef.current;
        const positionRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(props.position);
        const { position } = props;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function addControl() {
            instance.addTo(context.map);
            return function removeControl() {
                instance.remove();
            };
        }, [
            context.map,
            instance
        ]);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function updateControl() {
            if (position != null && position !== positionRef.current) {
                instance.setPosition(position);
                positionRef.current = position;
            }
        }, [
            instance,
            position
        ]);
        return elementRef;
    };
}

})()),
"[project]/node_modules/@react-leaflet/core/lib/attribution.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "useAttribution": ()=>useAttribution
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
function useAttribution(map, attribution) {
    const attributionRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])(attribution);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function updateAttribution() {
        if (attribution !== attributionRef.current && map.attributionControl != null) {
            if (attributionRef.current != null) {
                map.attributionControl.removeAttribution(attributionRef.current);
            }
            if (attribution != null) {
                map.attributionControl.addAttribution(attribution);
            }
        }
        attributionRef.current = attribution;
    }, [
        map,
        attribution
    ]);
}

})()),
"[project]/node_modules/@react-leaflet/core/lib/events.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "useEventHandlers": ()=>useEventHandlers
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
function useEventHandlers(element, eventHandlers) {
    const eventHandlersRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function addEventHandlers() {
        if (eventHandlers != null) {
            element.instance.on(eventHandlers);
        }
        eventHandlersRef.current = eventHandlers;
        return function removeEventHandlers() {
            if (eventHandlersRef.current != null) {
                element.instance.off(eventHandlersRef.current);
            }
            eventHandlersRef.current = null;
        };
    }, [
        element,
        eventHandlers
    ]);
}

})()),
"[project]/node_modules/@react-leaflet/core/lib/pane.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "withPane": ()=>withPane
});
function withPane(props, context) {
    const pane = props.pane ?? context.pane;
    return pane ? {
        ...props,
        pane
    } : props;
}

})()),
"[project]/node_modules/@react-leaflet/core/lib/layer.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "createLayerHook": ()=>createLayerHook,
    "useLayerLifecycle": ()=>useLayerLifecycle
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$attribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/attribution.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$pane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/pane.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
;
function useLayerLifecycle(element, context) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function addLayer() {
        const container = context.layerContainer ?? context.map;
        container.addLayer(element.instance);
        return function removeLayer() {
            context.layerContainer?.removeLayer(element.instance);
            context.map.removeLayer(element.instance);
        };
    }, [
        context,
        element
    ]);
}
function createLayerHook(useElement) {
    return function useLayer(props) {
        const context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLeafletContext"])();
        const elementRef = useElement((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$pane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withPane"])(props, context), context);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$attribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useAttribution"])(context.map, props.attribution);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEventHandlers"])(elementRef.current, props.eventHandlers);
        useLayerLifecycle(elementRef.current, context);
        return elementRef;
    };
}

})()),
"[project]/node_modules/@react-leaflet/core/lib/div-overlay.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "createDivOverlayHook": ()=>createDivOverlayHook
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$attribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/attribution.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$pane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/pane.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
function createDivOverlayHook(useElement, useLifecycle) {
    return function useDivOverlay(props, setOpen) {
        const context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLeafletContext"])();
        const elementRef = useElement((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$pane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withPane"])(props, context), context);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$attribution$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useAttribution"])(context.map, props.attribution);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEventHandlers"])(elementRef.current, props.eventHandlers);
        useLifecycle(elementRef.current, context, props, setOpen);
        return elementRef;
    };
}

})()),
"[project]/node_modules/@react-leaflet/core/lib/path.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "createPathHook": ()=>createPathHook,
    "usePathOptions": ()=>usePathOptions
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/events.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$pane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/pane.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
;
function usePathOptions(element, props) {
    const optionsRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useRef"])();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function updatePathOptions() {
        if (props.pathOptions !== optionsRef.current) {
            const options = props.pathOptions ?? {};
            element.instance.setStyle(options);
            optionsRef.current = options;
        }
    }, [
        element,
        props
    ]);
}
function createPathHook(useElement) {
    return function usePath(props) {
        const context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLeafletContext"])();
        const elementRef = useElement((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$pane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withPane"])(props, context), context);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$events$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEventHandlers"])(elementRef.current, props.eventHandlers);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLayerLifecycle"])(elementRef.current, context);
        usePathOptions(elementRef.current, props);
        return elementRef;
    };
}

})()),
"[project]/node_modules/@react-leaflet/core/lib/generic.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "createControlComponent": ()=>createControlComponent,
    "createLayerComponent": ()=>createLayerComponent,
    "createOverlayComponent": ()=>createOverlayComponent,
    "createPathComponent": ()=>createPathComponent,
    "createTileLayerComponent": ()=>createTileLayerComponent
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/component.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/control.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/element.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$div$2d$overlay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/div-overlay.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/path.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
;
;
;
function createControlComponent(createInstance) {
    function createElement(props, context) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementObject"])(createInstance(props), context);
    }
    const useElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementHook"])(createElement);
    const useControl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$control$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createControlHook"])(useElement);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLeafComponent"])(useControl);
}
function createLayerComponent(createElement, updateElement) {
    const useElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementHook"])(createElement, updateElement);
    const useLayer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLayerHook"])(useElement);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContainerComponent"])(useLayer);
}
function createOverlayComponent(createElement, useLifecycle) {
    const useElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementHook"])(createElement);
    const useOverlay = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$div$2d$overlay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDivOverlayHook"])(useElement, useLifecycle);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDivOverlayComponent"])(useOverlay);
}
function createPathComponent(createElement, updateElement) {
    const useElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementHook"])(createElement, updateElement);
    const usePath = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$path$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createPathHook"])(useElement);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createContainerComponent"])(usePath);
}
function createTileLayerComponent(createElement, updateElement) {
    const useElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementHook"])(createElement, updateElement);
    const useLayer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLayerHook"])(useElement);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$component$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLeafComponent"])(useLayer);
}

})()),
"[project]/node_modules/@react-leaflet/core/lib/grid-layer.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "updateGridLayer": ()=>updateGridLayer
});
function updateGridLayer(layer, props, prevProps) {
    const { opacity, zIndex } = props;
    if (opacity != null && opacity !== prevProps.opacity) {
        layer.setOpacity(opacity);
    }
    if (zIndex != null && zIndex !== prevProps.zIndex) {
        layer.setZIndex(zIndex);
    }
}

})()),
"[project]/node_modules/@react-leaflet/core/lib/media-overlay.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "updateMediaOverlay": ()=>updateMediaOverlay
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/leaflet/dist/leaflet-src.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
function updateMediaOverlay(overlay, props, prevProps) {
    if (props.bounds instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LatLngBounds"] && props.bounds !== prevProps.bounds) {
        overlay.setBounds(props.bounds);
    }
    if (props.opacity != null && props.opacity !== prevProps.opacity) {
        overlay.setOpacity(props.opacity);
    }
    if (props.zIndex != null && props.zIndex !== prevProps.zIndex) {
        // @ts-ignore missing in definition but inherited from ImageOverlay
        overlay.setZIndex(props.zIndex);
    }
}

})()),
"[project]/node_modules/react-leaflet/lib/MapContainer.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "MapContainer": ()=>MapContainer
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/leaflet/dist/leaflet-src.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
;
;
;
function MapContainerComponent({ bounds, boundsOptions, center, children, className, id, placeholder, style, whenReady, zoom, ...options }, forwardedRef) {
    const [props] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])({
        className,
        id,
        style
    });
    const [context, setContext] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useState"])(null);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useImperativeHandle"])(forwardedRef, ()=>context?.map ?? null, [
        context
    ]);
    const mapRef = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useCallback"])((node)=>{
        if (node !== null && context === null) {
            const map = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Map"](node, options);
            if (center != null && zoom != null) {
                map.setView(center, zoom);
            } else if (bounds != null) {
                map.fitBounds(bounds, boundsOptions);
            }
            if (whenReady != null) {
                map.whenReady(whenReady);
            }
            setContext((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLeafletContext"])(map));
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(()=>{
        return ()=>{
            context?.map.remove();
        };
    }, [
        context
    ]);
    const contents = context ? /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LeafletProvider"], {
        value: context
    }, children) : placeholder ?? null;
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("div", _extends({}, props, {
        ref: mapRef
    }), contents);
}
const MapContainer = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["forwardRef"])(MapContainerComponent);

})()),
"[project]/node_modules/react-leaflet/lib/TileLayer.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "TileLayer": ()=>TileLayer
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/element.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$generic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/generic.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$grid$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/grid-layer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$pane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/pane.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/leaflet/dist/leaflet-src.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
const TileLayer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$generic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTileLayerComponent"])(function createTileLayer({ url, ...options }, context) {
    const layer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TileLayer"](url, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$pane$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withPane"])(options, context));
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementObject"])(layer, context);
}, function updateTileLayer(layer, props, prevProps) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$grid$2d$layer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["updateGridLayer"])(layer, props, prevProps);
    const { url } = props;
    if (url != null && url !== prevProps.url) {
        layer.setUrl(url);
    }
});

})()),
"[project]/node_modules/react-leaflet/lib/Marker.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "Marker": ()=>Marker
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/element.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$generic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/generic.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/leaflet/dist/leaflet-src.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
const Marker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$generic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLayerComponent"])(function createMarker({ position, ...options }, ctx) {
    const marker = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Marker"](position, options);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementObject"])(marker, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extendContext"])(ctx, {
        overlayContainer: marker
    }));
}, function updateMarker(marker, props, prevProps) {
    if (props.position !== prevProps.position) {
        marker.setLatLng(props.position);
    }
    if (props.icon != null && props.icon !== prevProps.icon) {
        marker.setIcon(props.icon);
    }
    if (props.zIndexOffset != null && props.zIndexOffset !== prevProps.zIndexOffset) {
        marker.setZIndexOffset(props.zIndexOffset);
    }
    if (props.opacity != null && props.opacity !== prevProps.opacity) {
        marker.setOpacity(props.opacity);
    }
    if (marker.dragging != null && props.draggable !== prevProps.draggable) {
        if (props.draggable === true) {
            marker.dragging.enable();
        } else {
            marker.dragging.disable();
        }
    }
});

})()),
"[project]/node_modules/react-leaflet/lib/Popup.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "Popup": ()=>Popup
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/element.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$generic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/generic.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/leaflet/dist/leaflet-src.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
const Popup = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$generic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOverlayComponent"])(function createPopup(props, context) {
    const popup = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Popup"](props, context.overlayContainer);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementObject"])(popup, context);
}, function usePopupLifecycle(element, context, { position }, setOpen) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function addPopup() {
        const { instance } = element;
        function onPopupOpen(event) {
            if (event.popup === instance) {
                instance.update();
                setOpen(true);
            }
        }
        function onPopupClose(event) {
            if (event.popup === instance) {
                setOpen(false);
            }
        }
        context.map.on({
            popupopen: onPopupOpen,
            popupclose: onPopupClose
        });
        if (context.overlayContainer == null) {
            // Attach to a Map
            if (position != null) {
                instance.setLatLng(position);
            }
            instance.openOn(context.map);
        } else {
            // Attach to container component
            context.overlayContainer.bindPopup(instance);
        }
        return function removePopup() {
            context.map.off({
                popupopen: onPopupOpen,
                popupclose: onPopupClose
            });
            context.overlayContainer?.unbindPopup();
            context.map.removeLayer(instance);
        };
    }, [
        element,
        context,
        setOpen,
        position
    ]);
});

})()),
"[project]/node_modules/react-leaflet/lib/hooks.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "useMap": ()=>useMap,
    "useMapEvent": ()=>useMapEvent,
    "useMapEvents": ()=>useMapEvents
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
function useMap() {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useLeafletContext"])().map;
}
function useMapEvent(type, handler) {
    const map = useMap();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function addMapEventHandler() {
        // @ts-ignore event type
        map.on(type, handler);
        return function removeMapEventHandler() {
            // @ts-ignore event type
            map.off(type, handler);
        };
    }, [
        map,
        type,
        handler
    ]);
    return map;
}
function useMapEvents(handlers) {
    const map = useMap();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useEffect"])(function addMapEventHandlers() {
        map.on(handlers);
        return function removeMapEventHandlers() {
            map.off(handlers);
        };
    }, [
        map,
        handlers
    ]);
    return map;
}

})()),
"[project]/node_modules/react-leaflet/lib/ImageOverlay.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "ImageOverlay": ()=>ImageOverlay
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/element.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$generic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/generic.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/context.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$media$2d$overlay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@react-leaflet/core/lib/media-overlay.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/leaflet/dist/leaflet-src.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
const ImageOverlay = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$generic$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createLayerComponent"])(function createImageOveraly({ bounds, url, ...options }, ctx) {
    const overlay = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ImageOverlay"](url, bounds, options);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$element$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createElementObject"])(overlay, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$context$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extendContext"])(ctx, {
        overlayContainer: overlay
    }));
}, function updateImageOverlay(overlay, props, prevProps) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$react$2d$leaflet$2f$core$2f$lib$2f$media$2d$overlay$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["updateMediaOverlay"])(overlay, props, prevProps);
    if (props.bounds !== prevProps.bounds) {
        const bounds = props.bounds instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LatLngBounds"] ? props.bounds : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LatLngBounds"](props.bounds);
        overlay.setBounds(bounds);
    }
    if (props.url !== prevProps.url) {
        overlay.setUrl(props.url);
    }
});

})()),
"[project]/node_modules/leaflet-defaulticon-compatibility/src/Icon.Default.compatibility.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/leaflet/dist/leaflet-src.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Icon.Default.mergeOptions({
    // Erase default options, so that they can be overridden by _initializeOptions if not supplied.
    iconUrl: null,
    iconRetinaUrl: null,
    shadowUrl: null,
    iconSize: null,
    iconAnchor: null,
    popupAnchor: null,
    tooltipAnchor: null,
    shadowSize: null,
    // @option classNamePrefix: String = 'leaflet-default-icon-'
    // Prefix for the classes defined in CSS that contain the Icon options.
    // See the leaflet-defaulticon-compatibility.css file as a starter.
    // Expected suffixes are "icon", "shadow", "popup" and "tooltip".
    classNamePrefix: 'leaflet-default-icon-'
});
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Icon.Default.include({
    _needsInit: true,
    // Override to make sure options are retrieved from CSS.
    _getIconUrl: function(name) {
        // @option imagePath: String
        // `Icon.Default` will try to auto-detect the location of
        // the blue icon images. If you are placing these images in a
        // non-standard way, set this option to point to the right
        // path, before any marker is added to a map.
        // Caution: do not use this option with inline base64 image(s).
        var imagePath = this.options.imagePath || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Icon.Default.imagePath || '';
        // Deprecated (IconDefault.imagePath), backwards-compatibility only
        if (this._needsInit) {
            // Modifying imagePath option after _getIconUrl has been called
            // once in this instance of IconDefault will no longer have any
            // effect.
            this._initializeOptions(imagePath);
        }
        return imagePath + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Icon.prototype._getIconUrl.call(this, name);
    },
    // Initialize all necessary options for this instance.
    _initializeOptions: function(imagePath) {
        this._setOptions('icon', _detectIconOptions, imagePath);
        this._setOptions('shadow', _detectIconOptions, imagePath);
        this._setOptions('popup', _detectDivOverlayOptions);
        this._setOptions('tooltip', _detectDivOverlayOptions);
        this._needsInit = false;
    },
    // Retrieve values from CSS and assign to this instance options.
    _setOptions: function(name, detectorFn, imagePath) {
        var options = this.options, prefix = options.classNamePrefix, optionValues = detectorFn(prefix + name, imagePath);
        for(var optionName in optionValues){
            options[name + optionName] = options[name + optionName] || optionValues[optionName];
        }
    }
});
// Retrieve icon option values from CSS (icon or shadow).
function _detectIconOptions(className, imagePath) {
    var el = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.DomUtil.create('div', className, document.body), urlsContainer = _getBkgImageOrCursor(el), urls = _extractUrls(urlsContainer, imagePath), iconX = _getStyleInt(el, 'width'), iconY = _getStyleInt(el, 'height'), anchorNX = _getStyleInt(el, 'margin-left'), anchorNY = _getStyleInt(el, 'margin-top');
    el.parentNode.removeChild(el);
    return {
        Url: urls[0],
        RetinaUrl: urls[1],
        Size: [
            iconX,
            iconY
        ],
        Anchor: [
            -anchorNX,
            -anchorNY
        ]
    };
}
// Retrieve anchor option values from CSS (popup or tooltip).
function _detectDivOverlayOptions(className) {
    var el = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.DomUtil.create('div', className, document.body), anchorX = _getStyleInt(el, 'margin-left'), anchorY = _getStyleInt(el, 'margin-top');
    el.parentNode.removeChild(el);
    return {
        Anchor: [
            anchorX,
            anchorY
        ]
    };
}
// Read the CSS url (could be path or inline base64), may be multiple.
// First: normal icon
// Second: Retina icon
function _extractUrls(urlsContainer, imagePath) {
    var re = /url\(['"]?([^"']*?)['"]?\)/gi, urls = [], m = re.exec(urlsContainer);
    while(m){
        // Keep the entire URL from CSS rule, so that each image can have its own full URL.
        // Except in the case imagePath is provided: remove the path part (i.e. keep only the file name).
        urls.push(imagePath ? _stripPath(m[1]) : m[1]);
        m = re.exec(urlsContainer);
    }
    return urls;
}
// Remove anything before the last slash (/) occurrence (inclusive).
// Caution: will give unexpected result if url is inline base64 data
// => do not specify imagePath in that case!
function _stripPath(url) {
    return url.substr(url.lastIndexOf('/') + 1);
}
function _getStyleInt(el, style) {
    return parseInt(_getStyle(el, style), 10);
}
// Factorize style reading fallback for IE8.
function _getStyle(el, style) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.DomUtil.getStyle(el, style) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$leaflet$2f$dist$2f$leaflet$2d$src$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.DomUtil.getStyle(el, _kebabToCamelCase(style));
}
// When Firefox high contrast (colours override) option is enabled,
// "background-image" is overridden by the browser as "none".
// In that case, fallback to "cursor". But keep "background-image"
// as primary source because IE expects cursor URL as relative to HTML page
// instead of relative to CSS file.
function _getBkgImageOrCursor(el) {
    var bkgImage = _getStyle(el, 'background-image');
    return bkgImage && bkgImage !== 'none' ? bkgImage : _getStyle(el, 'cursor');
}
// Convert kebab-case CSS property name to camelCase for IE currentStyle.
function _kebabToCamelCase(prop) {
    return prop.replace(/-(\w)/g, function(str, w) {
        return w.toUpperCase();
    });
}

})()),
"[project]/node_modules/leaflet-rastercoords/rastercoords.js [app-client] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__, m: module, e: exports, t: require }) { !function() {

/**
 * leaflet plugin for plain image map projection
 * @copyright 2016- commenthol
 * @license MIT
 */ /* globals define */ ;
(function(factory) {
    var L;
    if (typeof define === 'function' && define.amd) {
        // AMD
        ((r)=>r !== undefined && __turbopack_export_value__(r))(factory(__turbopack_require__("[project]/node_modules/leaflet/dist/leaflet-src.js [app-client] (ecmascript)")));
    } else if (typeof module !== 'undefined') {
        // Node/CommonJS
        L = __turbopack_require__("[project]/node_modules/leaflet/dist/leaflet-src.js [app-client] (ecmascript)");
        module.exports = factory(L);
    } else {
        // Browser globals
        if (typeof window.L === 'undefined') {
            throw new Error('Leaflet must be loaded first');
        }
        factory(window.L);
    }
})(function(L) {
    /**
   * L.RasterCoords
   * @param {L.map} map - the map used
   * @param {Array} imgsize - [ width, height ] image dimensions
   * @param {Number} [tilesize] - tilesize in pixels. Default=256
   * @param {Boolean} setmaxbounds - automatically set map max bounds. Default=true
   */ L.RasterCoords = function(map, imgsize, tilesize, setmaxbounds = true) {
        this.map = map;
        this.width = imgsize[0];
        this.height = imgsize[1];
        this.tilesize = tilesize || 256;
        this.zoom = this.zoomLevel();
        if (setmaxbounds && this.width && this.height) {
            this.setMaxBounds();
        }
    };
    L.RasterCoords.prototype = {
        /**
     * calculate accurate zoom level for the given image size
     */ zoomLevel: function() {
            return Math.ceil(Math.log(Math.max(this.width, this.height) / this.tilesize) / Math.log(2));
        },
        /**
     * unproject `coords` to the raster coordinates used by the raster image projection
     * @param {Array} coords - [ x, y ]
     * @return {L.LatLng} - internal coordinates
     */ unproject: function(coords) {
            return this.map.unproject(coords, this.zoom);
        },
        /**
     * project `coords` back to image coordinates
     * @param {Array} coords - [ x, y ]
     * @return {L.LatLng} - image coordinates
     */ project: function(coords) {
            return this.map.project(coords, this.zoom);
        },
        /**
     * get the max bounds of the image
     */ getMaxBounds: function() {
            var southWest = this.unproject([
                0,
                this.height
            ]);
            var northEast = this.unproject([
                this.width,
                0
            ]);
            return new L.LatLngBounds(southWest, northEast);
        },
        /**
     * sets the max bounds on map
     */ setMaxBounds: function() {
            var bounds = this.getMaxBounds();
            this.map.setMaxBounds(bounds);
        }
    };
    return L.RasterCoords;
}); // eslint-disable-line semi

}.call(this) }),
"[project]/node_modules/@allmaps/stdlib/dist/fetch.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "fetchImageBitmap": ()=>fetchImageBitmap,
    "fetchImageInfo": ()=>fetchImageInfo,
    "fetchJson": ()=>fetchJson,
    "fetchUrl": ()=>fetchUrl
});
async function fetchUrl(input, init, fetchFn) {
    let response;
    if (typeof fetchFn === 'function') {
        response = await fetchFn(input, init);
    } else {
        response = await fetch(input, init);
    }
    if (!response.ok) {
        throw new Error(response.statusText);
    }
    return response;
}
async function fetchJson(input, init, fetchFn) {
    const response = await fetchUrl(input, init, fetchFn);
    return await response.json();
}
async function fetchImageInfo(imageUri, init, fetchFn) {
    return await fetchJson(`${imageUri}/info.json`, init, fetchFn);
}
async function fetchImageBitmap(input, init, fetchFn) {
    const response = await fetchUrl(input, init, fetchFn);
    const blob = await response.blob();
    return await createImageBitmap(blob);
}

})()),
"[project]/node_modules/@allmaps/stdlib/dist/api.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "fetchAnnotationsFromApi": ()=>fetchAnnotationsFromApi
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/fetch.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
function fetchAnnotationsByIiifUrl(url) {
    // TODO: move base URLs to env/config file
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fetchJson"])(`https://annotations.allmaps.org/?url=${url}`);
}
async function fetchAnnotationsForImage(parsedImage) {
    try {
        const annotations = await fetchAnnotationsByIiifUrl(`${parsedImage.uri}/info.json`);
        return [
            annotations
        ];
    } catch (err) {
        return [];
    }
}
async function fetchAnnotationsForManifest(parsedManifest) {
    try {
        const annotations = await fetchAnnotationsByIiifUrl(parsedManifest.uri);
        return [
            annotations
        ];
    } catch (err) {
        const annotations = [];
        for (const canvas of parsedManifest.canvases){
            const imageAnnotations = await fetchAnnotationsForImage(canvas.image);
            annotations.push(...imageAnnotations);
        }
        return annotations;
    }
}
async function fetchAnnotationsForCollection(parsedCollection) {
    try {
        const annotations = await fetchAnnotationsByIiifUrl(parsedCollection.uri);
        return [
            annotations
        ];
    } catch (err) {
        const annotations = [];
        for (const item of parsedCollection.items){
            if (item.type === 'collection') {
                const itemAnnotations = await fetchAnnotationsForCollection(item);
                annotations.push(...itemAnnotations);
            } else if (item.type === 'manifest' && 'canvases' in item) {
                const itemAnnotations = await fetchAnnotationsForManifest(item);
                annotations.push(...itemAnnotations);
            }
        }
        return annotations;
    }
}
function fetchAnnotationsFromApi(parsedIiif) {
    if (parsedIiif.type === 'image') {
        return fetchAnnotationsForImage(parsedIiif);
    } else if (parsedIiif.type === 'manifest') {
        return fetchAnnotationsForManifest(parsedIiif);
    } else if (parsedIiif.type === 'collection') {
        return fetchAnnotationsForCollection(parsedIiif);
    } else {
        throw new Error('Unsupported IIIF resource');
    }
}

})()),
"[project]/node_modules/@allmaps/stdlib/dist/background-color.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "getColorHistogram": ()=>getColorHistogram,
    "getColorsArray": ()=>getColorsArray,
    "getImageData": ()=>getImageData,
    "getMaxOccurringColor": ()=>getMaxOccurringColor
});
const DEFAULT_BIN_SIZE = 5;
const DEFAULT_RESOLUTION = 2;
function getImageData(imageBitmap, mask) {
    const canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);
    const context = canvas.getContext('2d');
    if (!context) {
        throw new Error('Could not create OffscreenCanvas context');
    }
    if (mask) {
        context.fillStyle = 'rgba(0, 0, 0, 0)';
        context.fillRect(0, 0, imageBitmap.width, imageBitmap.height);
        context.beginPath();
        context.moveTo(mask[0][0], mask[0][1]);
        mask.slice(1).forEach((point)=>context.lineTo(point[0], point[1]));
        context.closePath();
        context.clip();
    }
    context.drawImage(imageBitmap, 0, 0);
    return context.getImageData(0, 0, imageBitmap.width, imageBitmap.height);
}
function getColorsArray(imageData, resolution = DEFAULT_RESOLUTION) {
    const colors = [];
    for(let x = 0; x < imageData.width; x += resolution){
        for(let y = 0; y < imageData.height; y += resolution){
            const startIndex = (x + y * imageData.width) * 4;
            const opacity = imageData.data[startIndex + 3];
            if (opacity > 0) {
                const color = [
                    imageData.data[startIndex],
                    imageData.data[startIndex + 1],
                    imageData.data[startIndex + 2]
                ];
                colors.push(color);
            }
        }
    }
    return colors;
}
function getColorHistogram(colors, binSize = DEFAULT_BIN_SIZE) {
    const histogram = {};
    for (const color of colors){
        const bin = createColorBin(color, binSize);
        if (!histogram[bin]) {
            histogram[bin] = {
                count: 0,
                color
            };
        }
        histogram[bin].count += 1;
    }
    return histogram;
}
function getMaxOccurringColor(histogram) {
    let max = Number.NEGATIVE_INFINITY;
    let maxOccurringColor;
    for (const { count, color } of Object.values(histogram)){
        if (count > max) {
            max = count;
            maxOccurringColor = color;
        }
    }
    if (!maxOccurringColor) {
        throw new Error('Histogram is empty');
    }
    return {
        count: max,
        color: maxOccurringColor
    };
}
function createColorBin(color, binSize) {
    return color.map((c)=>Math.round(c / binSize)).toString();
}

})()),
"[project]/node_modules/@allmaps/stdlib/dist/geometry.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */ __turbopack_esm__({
    "conformLineString": ()=>conformLineString,
    "conformMultiLineString": ()=>conformMultiLineString,
    "conformMultiPolygon": ()=>conformMultiPolygon,
    "conformPolygon": ()=>conformPolygon,
    "conformRing": ()=>conformRing,
    "convertGeometryToGeojsonGeometry": ()=>convertGeometryToGeojsonGeometry,
    "convertLineStringToGeojsonLineString": ()=>convertLineStringToGeojsonLineString,
    "convertMultiLineStringToGeojsonMultiLineString": ()=>convertMultiLineStringToGeojsonMultiLineString,
    "convertMultiPointToGeojsonMultiPoint": ()=>convertMultiPointToGeojsonMultiPoint,
    "convertMultiPolygonToGeojsonMultiPolygon": ()=>convertMultiPolygonToGeojsonMultiPolygon,
    "convertPointToGeojsonPoint": ()=>convertPointToGeojsonPoint,
    "convertPolygonToGeojsonPolygon": ()=>convertPolygonToGeojsonPolygon,
    "convertRingToGeojsonPolygon": ()=>convertRingToGeojsonPolygon,
    "degreesToRadians": ()=>degreesToRadians,
    "distance": ()=>distance,
    "flipX": ()=>flipX,
    "flipY": ()=>flipY,
    "isClosed": ()=>isClosed,
    "isEqualPoint": ()=>isEqualPoint,
    "isEqualPointArray": ()=>isEqualPointArray,
    "isEqualPointArrayArray": ()=>isEqualPointArrayArray,
    "isGeometry": ()=>isGeometry,
    "isLineString": ()=>isLineString,
    "isMultiLineString": ()=>isMultiLineString,
    "isMultiPoint": ()=>isMultiPoint,
    "isMultiPolygon": ()=>isMultiPolygon,
    "isPoint": ()=>isPoint,
    "isPolygon": ()=>isPolygon,
    "midPoint": ()=>midPoint,
    "mixNumbers": ()=>mixNumbers,
    "mixPoints": ()=>mixPoints,
    "pixelToIntArrayIndex": ()=>pixelToIntArrayIndex,
    "pointToPixel": ()=>pointToPixel
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$placemarkio$2f$geojson$2d$rewind$2f$dist$2f$rewind$2e$es$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@placemarkio/geojson-rewind/dist/rewind.es.mjs [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
function isPoint(input) {
    return Array.isArray(input) && input.length === 2 && typeof input[0] === 'number' && typeof input[1] === 'number';
}
function isLineString(input) {
    return Array.isArray(input) && input.every(isPoint);
// && !isClosed(input) // Possible addition if we want to check for closedness
}
// TODO: check if we keep Ring as unclosed.
// This function is not exported because Ring should not be used externally, since it can not be distingised from LineSting
function isRing(input) {
    return Array.isArray(input) && input.every(isPoint);
}
function isPolygon(input) {
    return Array.isArray(input) && input.every(isRing);
}
function isMultiPoint(input) {
    return Array.isArray(input) && input.every(isPoint);
}
function isMultiLineString(input) {
    return Array.isArray(input) && input.every(isLineString);
}
function isMultiPolygon(input) {
    return Array.isArray(input) && input.every(isPolygon);
}
function isGeometry(input) {
    return isPoint(input) || isLineString(input) || isPolygon(input) || isMultiPoint(input) || isMultiLineString(input) || isMultiPolygon(input);
}
function conformLineString(lineString) {
    // Filter out repeated points
    lineString = lineString.filter(function(point, i, originalLineString) {
        return i === 0 || !isEqualPoint(point, originalLineString[i - 1]);
    });
    if (lineString.length < 2) {
        throw new Error('LineString should contain at least 2 points');
    }
    return lineString;
}
function conformRing(ring) {
    // Filter out repeated points
    ring = ring.filter(function(point, i, originalRing) {
        return i === 0 || !isEqualPoint(point, originalRing[i - 1]);
    });
    // Remove last point if input is closed ring
    if (isClosed(ring)) {
        ring.splice(-1);
    }
    if (ring.length < 3) {
        throw new Error('Ring should contain at least 3 points');
    }
    return ring;
}
function conformPolygon(polygon) {
    return polygon.map((ring)=>{
        return conformRing(ring);
    });
}
function conformMultiLineString(multiLineString) {
    return multiLineString.map((lineString)=>conformLineString(lineString));
}
function conformMultiPolygon(multiPolygon) {
    return multiPolygon.map((polygon)=>conformPolygon(polygon));
}
function convertPointToGeojsonPoint(point) {
    return {
        type: 'Point',
        coordinates: point
    };
}
function convertLineStringToGeojsonLineString(lineString) {
    return {
        type: 'LineString',
        coordinates: lineString
    };
}
function convertRingToGeojsonPolygon(ring, close = true) {
    const geometry = {
        type: 'Polygon',
        coordinates: close ? [
            [
                ...ring,
                ring[0]
            ]
        ] : [
            ring
        ]
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$placemarkio$2f$geojson$2d$rewind$2f$dist$2f$rewind$2e$es$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rewindGeometry"])(geometry);
}
function convertPolygonToGeojsonPolygon(polygon, close = true) {
    const geometry = {
        type: 'Polygon',
        coordinates: close ? polygon.map((ring)=>{
            return [
                ...ring,
                ring[0]
            ];
        }) : polygon
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$placemarkio$2f$geojson$2d$rewind$2f$dist$2f$rewind$2e$es$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rewindGeometry"])(geometry);
}
function convertMultiPointToGeojsonMultiPoint(multiPoint) {
    return {
        type: 'MultiPoint',
        coordinates: multiPoint
    };
}
function convertMultiLineStringToGeojsonMultiLineString(multiLineString) {
    return {
        type: 'MultiLineString',
        coordinates: multiLineString
    };
}
function convertMultiPolygonToGeojsonMultiPolygon(multiPolygon, close = true) {
    const geometry = {
        type: 'MultiPolygon',
        coordinates: close ? multiPolygon.map((polygon)=>polygon.map((ring)=>{
                return [
                    ...ring,
                    ring[0]
                ];
            })) : multiPolygon
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$placemarkio$2f$geojson$2d$rewind$2f$dist$2f$rewind$2e$es$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rewindGeometry"])(geometry);
}
function convertGeometryToGeojsonGeometry(geometry) {
    if (isPoint(geometry)) {
        return convertPointToGeojsonPoint(geometry);
    } else if (isLineString(geometry)) {
        return convertLineStringToGeojsonLineString(geometry);
    } else if (isPolygon(geometry)) {
        return convertPolygonToGeojsonPolygon(geometry);
    } else if (isMultiPoint(geometry)) {
        return convertMultiPointToGeojsonMultiPoint(geometry);
    } else if (isMultiLineString(geometry)) {
        return convertMultiLineStringToGeojsonMultiLineString(geometry);
    } else if (isMultiPolygon(geometry)) {
        return convertMultiPolygonToGeojsonMultiPolygon(geometry);
    } else {
        throw new Error('Geometry type not supported');
    }
}
function isClosed(input) {
    return Array.isArray(input) && input.length >= 2 && isEqualPoint(input[0], input[input.length - 1]);
}
function isEqualPoint(point0, point1) {
    if (point0 === point1) return true;
    if (point0 === null || point1 === null) return false;
    return point0[0] === point1[0] && point0[1] === point1[1];
}
function isEqualPointArray(pointArray0, pointArray1) {
    if (pointArray0 === pointArray1) return true;
    if (!pointArray0 || !pointArray1) return false;
    if (pointArray0.length !== pointArray1.length) return false;
    for(let i = 0; i < pointArray0.length; ++i){
        if (isEqualPoint(pointArray0[i], pointArray1[i])) return false;
    }
    return true;
}
function isEqualPointArrayArray(pointArrayArray0, pointArrayArray1) {
    if (pointArrayArray0 === pointArrayArray1) return true;
    if (!pointArrayArray0 || !pointArrayArray1) return false;
    if (pointArrayArray0.length !== pointArrayArray1.length) return false;
    for(let i = 0; i < pointArrayArray0.length; ++i){
        if (isEqualPointArray(pointArrayArray0[i], pointArrayArray1[i])) return false;
    }
    return true;
}
function pointToPixel(point, translate = [
    0,
    0
], size) {
    return point.map((coordinate, index)=>{
        let result = Math.floor(coordinate + translate[index]);
        if (size) {
            result = Math.max(result, 0);
            result = Math.min(result, size[index] - 1);
        }
        return result;
    });
}
function pixelToIntArrayIndex(pixel, size, channels, flipY = false) {
    const column = pixel[0];
    const row = flipY ? size[1] - 1 - pixel[1] : pixel[1];
    return (row * size[0] + column) * channels;
}
function flipX(point) {
    return [
        -point[0],
        point[1]
    ];
}
function flipY(point) {
    return [
        point[0],
        -point[1]
    ];
}
function midPoint(point0, point1) {
    return [
        (point1[0] - point0[0]) / 2 + point0[0],
        (point1[1] - point0[1]) / 2 + point0[1]
    ];
}
function mixNumbers(number0, number1, t) {
    return number0 * t + number1 * (1 - t);
}
function mixPoints(point0, point1, t) {
    return [
        point0[0] * t + point1[0] * (1 - t),
        point0[1] * t + point1[1] * (1 - t)
    ];
}
function distance(from, to) {
    if (isLineString(from) && from.length === 2) {
        return distance(from[0], from[1]);
    } else if (isPoint(from) && isPoint(to)) {
        return Math.sqrt((to[0] - from[0]) ** 2 + (to[1] - from[1]) ** 2);
    } else {
        throw new Error('Input type not supported');
    }
}
function degreesToRadians(degrees) {
    return degrees * (Math.PI / 180);
}

})()),
"[project]/node_modules/@allmaps/stdlib/dist/geojson.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "convertGeojsonGeometryToGeometry": ()=>convertGeojsonGeometryToGeometry,
    "convertGeojsonLineStringToLineString": ()=>convertGeojsonLineStringToLineString,
    "convertGeojsonMultiLineStringToMultiLineString": ()=>convertGeojsonMultiLineStringToMultiLineString,
    "convertGeojsonMultiPointToMultiPoint": ()=>convertGeojsonMultiPointToMultiPoint,
    "convertGeojsonMultiPolygonToMultiPolygon": ()=>convertGeojsonMultiPolygonToMultiPolygon,
    "convertGeojsonPointToPoint": ()=>convertGeojsonPointToPoint,
    "convertGeojsonPolygonToPolygon": ()=>convertGeojsonPolygonToPolygon,
    "convertGeojsonPolygonToRing": ()=>convertGeojsonPolygonToRing,
    "convertGeojsonToSvg": ()=>convertGeojsonToSvg,
    "expandGeojsonMultiGeometryToGeojsonGeometryArray": ()=>expandGeojsonMultiGeometryToGeojsonGeometryArray,
    "expandGeojsonMultiLineStringToGeojsonLineStringArray": ()=>expandGeojsonMultiLineStringToGeojsonLineStringArray,
    "expandGeojsonMultiPointToGeojsonPointArray": ()=>expandGeojsonMultiPointToGeojsonPointArray,
    "expandGeojsonMultiPolygonToGeojsonPolygonArray": ()=>expandGeojsonMultiPolygonToGeojsonPolygonArray,
    "featureCollectionToGeometries": ()=>featureCollectionToGeometries,
    "featureToGeometry": ()=>featureToGeometry,
    "featuresToFeatureCollection": ()=>featuresToFeatureCollection,
    "geometriesToFeatureCollection": ()=>geometriesToFeatureCollection,
    "geometryToFeature": ()=>geometryToFeature,
    "isGeojsonGeometry": ()=>isGeojsonGeometry,
    "isGeojsonLineString": ()=>isGeojsonLineString,
    "isGeojsonMultiLineString": ()=>isGeojsonMultiLineString,
    "isGeojsonMultiPoint": ()=>isGeojsonMultiPoint,
    "isGeojsonMultiPolygon": ()=>isGeojsonMultiPolygon,
    "isGeojsonPoint": ()=>isGeojsonPoint,
    "isGeojsonPolygon": ()=>isGeojsonPolygon,
    "joinGeojsonGeometryArrayToGeojsonMultiGeometry": ()=>joinGeojsonGeometryArrayToGeojsonMultiGeometry,
    "joinGeojsonLineStringArrayToGeojsonMultiLineString": ()=>joinGeojsonLineStringArrayToGeojsonMultiLineString,
    "joinGeojsonPointArrayToGeojsonMultiPoint": ()=>joinGeojsonPointArrayToGeojsonMultiPoint,
    "joinGeojsonPolygonArrayToGeojsonMultiPolygon": ()=>joinGeojsonPolygonArrayToGeojsonMultiPolygon
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/geometry.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
function isGeojsonPoint(input) {
    return typeof input === 'object' && input !== null && input.type === 'Point' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPoint"])(input.coordinates);
}
function isGeojsonLineString(input) {
    return typeof input === 'object' && input !== null && input.type === 'LineString' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLineString"])(input.coordinates);
}
function isGeojsonPolygon(input) {
    return typeof input === 'object' && input !== null && input.type === 'Polygon' && Array.isArray(input.coordinates) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolygon"])(input.coordinates);
}
function isGeojsonMultiPoint(input) {
    return typeof input === 'object' && input !== null && input.type === 'MultiPoint' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPoint"])(input.coordinates);
}
function isGeojsonMultiLineString(input) {
    return typeof input === 'object' && input !== null && input.type === 'MultiLineString' && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiLineString"])(input.coordinates);
}
function isGeojsonMultiPolygon(input) {
    return typeof input === 'object' && input !== null && input.type === 'MultiPolygon' && Array.isArray(input.coordinates) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isMultiPolygon"])(input.coordinates);
}
function isGeojsonGeometry(obj) {
    const isObject = typeof obj === 'object' && obj !== null;
    const hasStringType = isObject && 'type' in obj && typeof obj.type === 'string';
    const isValidType = hasStringType && (obj.type === 'Point' || obj.type === 'LineString' || obj.type === 'Polygon' || obj.type === 'MultiPoint' || obj.type === 'MultiLineString' || obj.type === 'MultiPolygon');
    const hasCoordinatesArray = isObject && 'coordinates' in obj && Array.isArray(obj.coordinates);
    return isValidType && hasCoordinatesArray;
}
function convertGeojsonPointToPoint(geojsonPoint) {
    return geojsonPoint.coordinates;
}
function convertGeojsonLineStringToLineString(geojsonLineString) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["conformLineString"])(geojsonLineString.coordinates);
}
function convertGeojsonPolygonToRing(geojsonPolygon, close = false) {
    let outerRing = geojsonPolygon.coordinates[0];
    outerRing = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["conformRing"])(outerRing);
    return close ? [
        ...outerRing,
        outerRing[0]
    ] : outerRing;
}
function convertGeojsonPolygonToPolygon(geojsonPolygon, close = false) {
    let polygon = geojsonPolygon.coordinates;
    polygon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["conformPolygon"])(polygon);
    return close ? polygon.map((ring)=>[
            ...ring,
            ring[0]
        ]) : polygon;
}
function convertGeojsonMultiPointToMultiPoint(geojsonMultiPoint) {
    return geojsonMultiPoint.coordinates;
}
function convertGeojsonMultiLineStringToMultiLineString(geojsonMultiLineString) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["conformMultiLineString"])(geojsonMultiLineString.coordinates);
}
function convertGeojsonMultiPolygonToMultiPolygon(geojsonMultiPolygon, close = false) {
    let multipolygon = geojsonMultiPolygon.coordinates;
    multipolygon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["conformMultiPolygon"])(multipolygon);
    return close ? multipolygon.map((polygon)=>polygon.map((ring)=>[
                ...ring,
                ring[0]
            ])) : multipolygon;
}
function convertGeojsonGeometryToGeometry(geojsonGeometry) {
    if (isGeojsonPoint(geojsonGeometry)) {
        return convertGeojsonPointToPoint(geojsonGeometry);
    } else if (isGeojsonLineString(geojsonGeometry)) {
        return convertGeojsonLineStringToLineString(geojsonGeometry);
    } else if (isGeojsonPolygon(geojsonGeometry)) {
        return convertGeojsonPolygonToPolygon(geojsonGeometry);
    } else if (isGeojsonMultiPoint(geojsonGeometry)) {
        return convertGeojsonMultiPointToMultiPoint(geojsonGeometry);
    } else if (isGeojsonMultiLineString(geojsonGeometry)) {
        return convertGeojsonMultiLineStringToMultiLineString(geojsonGeometry);
    } else if (isGeojsonMultiPolygon(geojsonGeometry)) {
        return convertGeojsonMultiPolygonToMultiPolygon(geojsonGeometry);
    } else {
        throw new Error('Geometry type not supported');
    }
}
function expandGeojsonMultiPointToGeojsonPointArray(geojsonMultiPoint) {
    return geojsonMultiPoint.coordinates.map((point)=>{
        return {
            type: 'Point',
            coordinates: point
        };
    });
}
function expandGeojsonMultiLineStringToGeojsonLineStringArray(geojsonMultiLineString) {
    return geojsonMultiLineString.coordinates.map((lineString)=>{
        return {
            type: 'LineString',
            coordinates: lineString
        };
    });
}
function expandGeojsonMultiPolygonToGeojsonPolygonArray(geojsonMultiPolygon) {
    return geojsonMultiPolygon.coordinates.map((polygon)=>{
        return {
            type: 'Polygon',
            coordinates: polygon
        };
    });
}
function expandGeojsonMultiGeometryToGeojsonGeometryArray(geojsonMultiGeometry) {
    if (isGeojsonMultiPoint(geojsonMultiGeometry)) {
        return expandGeojsonMultiPointToGeojsonPointArray(geojsonMultiGeometry);
    } else if (isGeojsonMultiLineString(geojsonMultiGeometry)) {
        return expandGeojsonMultiLineStringToGeojsonLineStringArray(geojsonMultiGeometry);
    } else if (isGeojsonMultiPolygon(geojsonMultiGeometry)) {
        return expandGeojsonMultiPolygonToGeojsonPolygonArray(geojsonMultiGeometry);
    } else {
        throw new Error('Geometry type not supported');
    }
}
function joinGeojsonPointArrayToGeojsonMultiPoint(geojsonPointArray) {
    return {
        type: 'MultiPoint',
        coordinates: geojsonPointArray.map((geojsonPoint)=>geojsonPoint.coordinates)
    };
}
function joinGeojsonLineStringArrayToGeojsonMultiLineString(geojsonLineStringArray) {
    return {
        type: 'MultiLineString',
        coordinates: geojsonLineStringArray.map((geojsonLineString)=>geojsonLineString.coordinates)
    };
}
function joinGeojsonPolygonArrayToGeojsonMultiPolygon(geojsonPolygonArray) {
    return {
        type: 'MultiPolygon',
        coordinates: geojsonPolygonArray.map((geojsonPolygon)=>geojsonPolygon.coordinates)
    };
}
function joinGeojsonGeometryArrayToGeojsonMultiGeometry(geojsonGeometryArray) {
    if (geojsonGeometryArray.every(isGeojsonPoint)) {
        return joinGeojsonPointArrayToGeojsonMultiPoint(geojsonGeometryArray);
    } else if (geojsonGeometryArray.every(isGeojsonLineString)) {
        return joinGeojsonLineStringArrayToGeojsonMultiLineString(geojsonGeometryArray);
    } else if (geojsonGeometryArray.every(isGeojsonPolygon)) {
        return joinGeojsonPolygonArrayToGeojsonMultiPolygon(geojsonGeometryArray);
    } else {
        throw new Error('Geometry type not supported');
    }
}
function convertGeojsonToSvg(geometry) {
    if (geometry.type === 'Point') {
        return {
            type: 'circle',
            coordinates: geometry.coordinates
        };
    } else if (geometry.type === 'LineString') {
        return {
            type: 'polyline',
            coordinates: geometry.coordinates
        };
    } else if (geometry.type === 'Polygon') {
        return {
            type: 'polygon',
            coordinates: geometry.coordinates[0]
        };
    } else {
        throw new Error(`Unsupported GeoJSON geometry`); // MultiPolygons not supported in SVG
    }
}
function geometryToFeature(geometry, properties) {
    return {
        type: 'Feature',
        properties: properties ? properties : {},
        geometry: geometry
    };
}
function featuresToFeatureCollection(features) {
    if (!Array.isArray(features)) {
        features = [
            features
        ];
    }
    return {
        type: 'FeatureCollection',
        features: features
    };
}
function geometriesToFeatureCollection(geometries, properties) {
    return {
        type: 'FeatureCollection',
        features: geometries.map((geometry, i)=>properties ? geometryToFeature(geometry, properties[i]) : geometryToFeature(geometry))
    };
}
function featureToGeometry(feature) {
    return feature.geometry;
}
function featureCollectionToGeometries(featureCollection) {
    return featureCollection.features.map(featureToGeometry);
}

})()),
"[project]/node_modules/@allmaps/stdlib/dist/bbox.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "bboxToCenter": ()=>bboxToCenter,
    "bboxToDiameter": ()=>bboxToDiameter,
    "bboxToLine": ()=>bboxToLine,
    "bboxToPoint": ()=>bboxToPoint,
    "bboxToPolygon": ()=>bboxToPolygon,
    "bboxToRectangle": ()=>bboxToRectangle,
    "bboxToSize": ()=>bboxToSize,
    "bboxesToScale": ()=>bboxesToScale,
    "combineBboxes": ()=>combineBboxes,
    "computeBbox": ()=>computeBbox,
    "computeMinMax": ()=>computeMinMax,
    "geometryToDiameter": ()=>geometryToDiameter,
    "isOverlapping": ()=>isOverlapping,
    "pointInBbox": ()=>pointInBbox,
    "rectangleToSize": ()=>rectangleToSize,
    "rectanglesToScale": ()=>rectanglesToScale,
    "sizesToScale": ()=>sizesToScale
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/geojson.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/geometry.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
function computeMinMax(values) {
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    for (const value of values){
        if (min === undefined) {
            if (value >= value) min = max = value;
        } else {
            if (min > value) min = value;
            if (max < value) max = value;
        }
    }
    return [
        min,
        max
    ];
}
function computeBbox(points) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPoint"])(points)) {
        points = [
            points
        ];
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPolygon"])(points)) {
        points = points.flat();
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isGeojsonGeometry"])(points)) {
        return computeBbox((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertGeojsonGeometryToGeometry"])(points));
    }
    // TODO: do this without making two new arrays
    const xs = [];
    const ys = [];
    for (const point of points){
        xs.push(point[0]);
        ys.push(point[1]);
    }
    const [minX, maxX] = computeMinMax(xs);
    const [minY, maxY] = computeMinMax(ys);
    return [
        minX,
        minY,
        maxX,
        maxY
    ];
}
function combineBboxes(bbox0, bbox1) {
    return [
        Math.min(bbox0[0], bbox1[0]),
        Math.min(bbox0[1], bbox1[1]),
        Math.max(bbox0[2], bbox1[2]),
        Math.max(bbox0[3], bbox1[3])
    ];
}
function isOverlapping(bbox0, bbox1) {
    const isOverlappingInX = bbox0[2] >= bbox1[0] && bbox1[2] >= bbox0[0];
    const isOverlappingInY = bbox0[3] >= bbox1[1] && bbox1[3] >= bbox0[1];
    return isOverlappingInX && isOverlappingInY;
}
function pointInBbox(point, bbox) {
    return isOverlapping([
        point[0],
        point[1],
        point[0],
        point[1]
    ], bbox);
}
function bboxToRectangle(bbox) {
    return [
        [
            bbox[0],
            bbox[1]
        ],
        [
            bbox[2],
            bbox[1]
        ],
        [
            bbox[2],
            bbox[3]
        ],
        [
            bbox[0],
            bbox[3]
        ]
    ];
}
function bboxToPolygon(bbox) {
    return [
        bboxToRectangle(bbox)
    ];
}
function bboxToLine(bbox) {
    return [
        [
            bbox[0],
            bbox[1]
        ],
        [
            bbox[2],
            bbox[3]
        ]
    ];
}
function bboxToPoint(bbox) {
    return [
        bbox[0],
        bbox[1]
    ];
}
function bboxToDiameter(bbox) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(bboxToLine(bbox));
}
function geometryToDiameter(geometry) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(bboxToLine(computeBbox(geometry)));
}
function bboxToCenter(bbox) {
    return [
        (bbox[0] + bbox[2]) / 2,
        (bbox[1] + bbox[3]) / 2
    ];
}
function bboxToSize(bbox) {
    return [
        bbox[2] - bbox[0],
        bbox[3] - bbox[1]
    ];
}
function rectangleToSize(rectangle) {
    return [
        0.5 * ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(rectangle[0], rectangle[1]) + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(rectangle[2], rectangle[3])),
        0.5 * ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(rectangle[1], rectangle[2]) + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["distance"])(rectangle[3], rectangle[0]))
    ];
}
function sizesToScale(size0, size1, fit) {
    if (!fit) {
        return Math.sqrt(size0[0] * size0[1] / (size1[0] * size1[1]));
    } else if (fit === 'contain') {
        return size1[0] >= size1[1] ? size0[0] / size1[0] : size0[1] / size1[1];
    } else {
        return size1[0] >= size1[1] ? size0[1] / size1[1] : size0[0] / size1[0];
    }
}
function bboxesToScale(bbox0, bbox1) {
    return sizesToScale(bboxToSize(bbox0), bboxToSize(bbox1));
}
function rectanglesToScale(rectangle0, rectangle1) {
    return sizesToScale(rectangleToSize(rectangle0), rectangleToSize(rectangle1));
}

})()),
"[project]/node_modules/@allmaps/stdlib/dist/cache.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "getPropertyFromCacheOrComputation": ()=>getPropertyFromCacheOrComputation,
    "getPropertyFromDoubleCacheOrComputation": ()=>getPropertyFromDoubleCacheOrComputation
});
function getPropertyFromCacheOrComputation(cache, key, computation, useCache = true) {
    if (cache.has(key) && useCache) {
        return cache.get(key);
    } else {
        const result = computation();
        cache.set(key, result);
        return result;
    }
}
function getPropertyFromDoubleCacheOrComputation(cache, key0, key1, computation, useCache = true) {
    if (cache.get(key0)?.has(key1) && useCache) {
        return cache.get(key0)?.get(key1);
    } else {
        const result = computation();
        if (!cache.get(key0)) {
            cache.set(key0, new Map());
        }
        cache.get(key0)?.set(key1, result);
        return result;
    }
}

})()),
"[project]/node_modules/@allmaps/stdlib/dist/color.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

/**
 * Convert RBG to hex
 * @param {[number, number, number]} [r, g, b] - rgb, e.g. [0, 51, 255]
 * @returns {Color} hex string, e.g. '#0033ff'
 */ __turbopack_esm__({
    "hexToFractionalRgb": ()=>hexToFractionalRgb,
    "hexToRgb": ()=>hexToRgb,
    "rgbToHex": ()=>rgbToHex
});
function rgbToHex([r, g, b]) {
    return '#' + [
        r,
        g,
        b
    ].map((x)=>{
        const hex = x.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }).join('');
}
function hexToRgb(hex) {
    const bigint = parseInt(hex.replace(/^#/, ''), 16);
    const r = bigint >> 16 & 255;
    const g = bigint >> 8 & 255;
    const b = bigint & 255;
    return [
        r,
        g,
        b
    ];
}
function hexToFractionalRgb(hex) {
    return hexToRgb(hex).map((c)=>c / 255);
}

})()),
"[project]/node_modules/@allmaps/stdlib/dist/main.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "equalArray": ()=>equalArray,
    "equalSet": ()=>equalSet,
    "isValidHttpUrl": ()=>isValidHttpUrl,
    "maxOfNumberOrUndefined": ()=>maxOfNumberOrUndefined
});
function equalArray(arr1, arr2) {
    if (!arr1 || !arr2) {
        return false;
    }
    if (arr1.length !== arr2.length) {
        return false;
    }
    for(let i = 0; i < arr1.length; i++){
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
function equalSet(set1, set2) {
    if (!set1 || !set2) {
        return false;
    }
    if (set1.size !== set2.size) {
        return false;
    }
    return [
        ...set1
    ].every((x)=>set2.has(x));
}
function maxOfNumberOrUndefined(number1, number2) {
    if (number1 !== undefined && number2 !== undefined) {
        return Math.max(number1, number2);
    } else if (number1 !== undefined) {
        return number1;
    } else if (number2 !== undefined) {
        return number2;
    }
}
function isValidHttpUrl(string) {
    let url;
    try {
        url = new URL(string);
    } catch (_) {
        return false;
    }
    return url.protocol === 'http:' || url.protocol === 'https:';
}

})()),
"[project]/node_modules/@allmaps/stdlib/dist/masks.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

// TODO: the fullResourceMask is available directly in WarpedMap class!
// This also means this function can be removed from stdlib.
__turbopack_esm__({
    "getFullResourceMask": ()=>getFullResourceMask
});
function getFullResourceMask(imageWidth, imageHeight) {
    return [
        [
            0,
            0
        ],
        [
            imageWidth,
            0
        ],
        [
            imageWidth,
            imageHeight
        ],
        [
            0,
            imageHeight
        ]
    ];
}

})()),
"[project]/node_modules/@allmaps/stdlib/dist/svg.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "convertSvgToGeojson": ()=>convertSvgToGeojson,
    "mapToResourceMaskSvgPolygon": ()=>mapToResourceMaskSvgPolygon,
    "stringToSvgGeometriesGenerator": ()=>stringToSvgGeometriesGenerator,
    "svgGeometriesToSvgString": ()=>svgGeometriesToSvgString
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$svg$2d$parser$2f$dist$2f$svg$2d$parser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/svg-parser/dist/svg-parser.esm.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
function* stringToSvgGeometriesGenerator(svg) {
    function* helper(node) {
        if ('children' in node) {
            for (const childNode of node.children){
                if (typeof childNode !== 'string') {
                    yield* helper(childNode);
                }
            }
        }
        yield node;
    }
    const parsedSvg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$svg$2d$parser$2f$dist$2f$svg$2d$parser$2e$esm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(svg);
    for (const node of helper(parsedSvg)){
        if ('tagName' in node) {
            if (node.tagName !== 'svg' && node.tagName !== 'g') {
                const geometry = getNodeSvgGeometry(node);
                if (geometry) {
                    yield geometry;
                }
            }
        }
    }
}
function getNodeSvgGeometry(node) {
    const tag = node?.tagName?.toLowerCase();
    if (tag === 'circle') {
        return {
            type: 'circle',
            coordinates: [
                getNodeNumberProperty(node, 'cx'),
                getNodeNumberProperty(node, 'cy')
            ]
        };
    } else if (tag === 'line') {
        return {
            type: 'line',
            coordinates: [
                [
                    getNodeNumberProperty(node, 'x1'),
                    getNodeNumberProperty(node, 'y1')
                ],
                [
                    getNodeNumberProperty(node, 'x2'),
                    getNodeNumberProperty(node, 'y2')
                ]
            ]
        };
    } else if (tag === 'polyline') {
        return {
            type: 'polyline',
            coordinates: getNodePoints(node)
        };
    } else if (tag === 'polygon') {
        return {
            type: 'polygon',
            coordinates: getNodePoints(node)
        };
    } else if (tag === 'rect') {
        return {
            type: 'rect',
            coordinates: [
                [
                    getNodeNumberProperty(node, 'x'),
                    getNodeNumberProperty(node, 'y')
                ],
                [
                    getNodeNumberProperty(node, 'x') + getNodeNumberProperty(node, 'width'),
                    getNodeNumberProperty(node, 'y')
                ],
                [
                    getNodeNumberProperty(node, 'x') + getNodeNumberProperty(node, 'width'),
                    getNodeNumberProperty(node, 'y') + getNodeNumberProperty(node, 'height')
                ],
                [
                    getNodeNumberProperty(node, 'x'),
                    getNodeNumberProperty(node, 'y') + getNodeNumberProperty(node, 'height')
                ],
                [
                    getNodeNumberProperty(node, 'x'),
                    getNodeNumberProperty(node, 'y')
                ]
            ]
        };
    } else {
        throw new Error(`Unsupported SVG element: ${tag}`);
    }
}
function getNodeNumberProperty(node, prop) {
    const value = node?.properties?.[prop];
    return Number(value) || 0;
}
function getNodePoints(node) {
    const points = node?.properties?.points;
    if (points) {
        return String(points).trim().split(/\s+/).map((coordStr)=>{
            const coord = coordStr.split(',').map((numberStr)=>Number(numberStr));
            return [
                coord[0],
                coord[1]
            ];
        });
    }
    return [];
}
function pointsToString(coordinates) {
    return coordinates.map((coordinate)=>coordinate.join(',')).join(' ');
}
function svgGeometriesToSvgString(geometries) {
    return `<svg xmlns="http://www.w3.org/2000/svg">
  ${geometries.map(svgGeometryToString).join('\n')}
</svg>`;
}
function svgGeometryToString(geometry) {
    if (geometry.type === 'circle') {
        return elementToString('circle', {
            ...geometry.attributes,
            cx: geometry.coordinates[0],
            cy: geometry.coordinates[1]
        });
    } else if (geometry.type === 'line') {
        return elementToString('line', {
            ...geometry.attributes,
            x1: geometry.coordinates[0][0],
            y1: geometry.coordinates[0][1],
            x2: geometry.coordinates[1][0],
            y2: geometry.coordinates[1][1]
        });
    } else if (geometry.type === 'polyline') {
        return elementToString('polyline', {
            ...geometry.attributes,
            points: pointsToString(geometry.coordinates)
        });
    } else if (geometry.type === 'polygon') {
        return elementToString('polygon', {
            ...geometry.attributes,
            points: pointsToString(geometry.coordinates)
        });
    } else if (geometry.type === 'rect') {
        return elementToString('rect', {
            ...geometry.attributes,
            x: geometry.coordinates[0][0],
            y: geometry.coordinates[0][1],
            width: geometry.coordinates[1][0] - geometry.coordinates[0][0],
            height: geometry.coordinates[2][1] - geometry.coordinates[0][1]
        });
    } else {
        throw new Error('Unknown SVG element');
    }
}
function elementToString(tag, attributes) {
    const attributeStrings = Object.entries(attributes).map(([key, value])=>`${key}="${value}"`);
    return `<${tag} ${attributeStrings.join(' ')} />`;
}
function mapToResourceMaskSvgPolygon(map) {
    return {
        type: 'polygon',
        attributes: {
            'data-image-id': encodeURIComponent(map.resource.id)
        },
        coordinates: map.resourceMask
    };
}
function convertSvgToGeojson(geometry) {
    if (geometry.type === 'circle') {
        return {
            type: 'Point',
            coordinates: geometry.coordinates
        };
    } else if (geometry.type === 'line') {
        return {
            type: 'LineString',
            coordinates: geometry.coordinates
        };
    } else if (geometry.type === 'polyline') {
        return {
            type: 'LineString',
            coordinates: geometry.coordinates
        };
    } else if (geometry.type === 'rect') {
        return {
            type: 'Polygon',
            coordinates: [
                geometry.coordinates
            ]
        };
    } else if (geometry.type === 'polygon') {
        return {
            type: 'Polygon',
            coordinates: [
                geometry.coordinates
            ]
        };
    } else {
        throw new Error(`Unsupported SVG geometry`);
    }
}

})()),
"[project]/node_modules/@allmaps/stdlib/dist/projection.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "lonLatToWebMecator": ()=>lonLatToWebMecator,
    "webMercatorToLonLat": ()=>webMercatorToLonLat
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/geometry.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
function lonLatToWebMecator([lon, lat]) {
    const rMajor = 6378137.0;
    const x = rMajor * (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(lon);
    const scale = x / lon;
    const y = 180.0 / Math.PI * Math.log(Math.tan(Math.PI / 4.0 + lat * (Math.PI / 180.0) / 2.0)) * scale;
    return [
        x,
        y
    ];
}
function webMercatorToLonLat([x, y]) {
    const rMajor = 6378137.0;
    const shift = Math.PI * rMajor;
    const lon = x / shift * 180.0;
    let lat = y / shift * 180.0;
    lat = 180 / Math.PI * (2 * Math.atan(Math.exp(lat * Math.PI / 180.0)) - Math.PI / 2.0);
    return [
        lon,
        lat
    ];
}

})()),
"[project]/node_modules/@allmaps/stdlib/dist/index.js [app-client] (ecmascript) <locals>": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({});
;
;
;
;
;
;
;
;
;
;
;
;

})()),
"[project]/node_modules/@allmaps/stdlib/dist/index.js [app-client] (ecmascript) <module evaluation>": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname }) => (() => {
"use strict";

__turbopack_esm__({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$background$2d$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/background-color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$bbox$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/bbox.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$cache$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/cache.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$color$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/color.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$fetch$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/fetch.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geojson$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/geojson.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$geometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/geometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$main$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/main.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$masks$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/masks.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$svg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/svg.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$projection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/projection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$allmaps$2f$stdlib$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_import__("[project]/node_modules/@allmaps/stdlib/dist/index.js [app-client] (ecmascript) <locals>");
"__TURBOPACK__ecmascript__hoisting__location__";

})()),
"[project]/node_modules/@placemarkio/geojson-rewind/dist/rewind.es.mjs [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "rewindFeature": ()=>rewindFeature,
    "rewindFeatureCollection": ()=>rewindFeatureCollection,
    "rewindGeometry": ()=>rewindGeometry
});
function rewindGeometry(geometry, outer = false) {
    switch(geometry.type){
        case 'Polygon':
            {
                if (!geometry.coordinates) return geometry;
                return {
                    ...geometry,
                    coordinates: rewindRings(geometry.coordinates, outer)
                };
            }
        case 'MultiPolygon':
            {
                if (!geometry.coordinates) return geometry;
                return {
                    ...geometry,
                    coordinates: geometry.coordinates.map((polygon)=>rewindRings(polygon, outer))
                };
            }
        case 'GeometryCollection':
            {
                return {
                    ...geometry,
                    geometries: geometry.geometries.map((geometry)=>{
                        return rewindGeometry(geometry, outer);
                    })
                };
            }
        default:
            {
                return geometry;
            }
    }
}
function rewindRings(rings, outer) {
    if (rings.length === 0) return rings;
    const rewound = [];
    for(let i = 0; i < rings.length; i++){
        rewound.push(rewindRing(rings[i], i === 0 ? outer : !outer));
    }
    return rewound;
}
/**
 * Compute the area of a ring to decide whether to wind it
 * clockwise or not.
 */ function rewindRing(ring, dir) {
    let area = 0;
    let err = 0;
    for(let i = 0, len = ring.length, j = len - 1; i < len; j = i++){
        const k = (ring[i][0] - ring[j][0]) * (ring[j][1] + ring[i][1]);
        const m = area + k;
        err += Math.abs(area) >= Math.abs(k) ? area - m + k : k - m + area;
        area = m;
    }
    if (area + err >= 0 !== !!dir) return ring.slice().reverse();
    return ring;
}
/**
 * # Wind the rings of polygons and multipolygons.
 *
 * This creates a copy of the input.
 *
 * - outer as false is the default, which is the GeoJSON RFC way.
 * - outer as true is for d3-geo.
 */ function rewindFeature(feature, winding = 'RFC7946') {
    const geometry = feature.geometry;
    if (!geometry) return feature;
    const geometryRewound = rewindGeometry(geometry, winding === 'd3');
    if (geometryRewound === geometry) {
        return feature;
    }
    return {
        ...feature,
        geometry: geometryRewound
    };
}
function rewindFeatureCollection(featureCollection, outer = 'RFC7946') {
    return {
        ...featureCollection,
        features: featureCollection.features.map((feature)=>rewindFeature(feature, outer))
    };
}
;
 //# sourceMappingURL=rewind.es.mjs.map

})()),
"[project]/node_modules/svg-parser/dist/svg-parser.esm.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "parse": ()=>parse
});
function getLocator(source, options) {
    if (options === void 0) {
        options = {};
    }
    var offsetLine = options.offsetLine || 0;
    var offsetColumn = options.offsetColumn || 0;
    var originalLines = source.split('\n');
    var start = 0;
    var lineRanges = originalLines.map(function(line, i) {
        var end = start + line.length + 1;
        var range = {
            start: start,
            end: end,
            line: i
        };
        start = end;
        return range;
    });
    var i = 0;
    function rangeContains(range, index) {
        return range.start <= index && index < range.end;
    }
    function getLocation(range, index) {
        return {
            line: offsetLine + range.line,
            column: offsetColumn + index - range.start,
            character: index
        };
    }
    function locate(search, startIndex) {
        if (typeof search === 'string') {
            search = source.indexOf(search, startIndex || 0);
        }
        var range = lineRanges[i];
        var d = search >= range.end ? 1 : -1;
        while(range){
            if (rangeContains(range, search)) return getLocation(range, search);
            i += d;
            range = lineRanges[i];
        }
    }
    return locate;
}
function locate(source, search, options) {
    if (typeof options === 'number') {
        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');
    }
    return getLocator(source, options)(search, options && options.startIndex);
}
var validNameCharacters = /[a-zA-Z0-9:_-]/;
var whitespace = /[\s\t\r\n]/;
var quotemark = /['"]/;
function repeat(str, i) {
    var result = '';
    while(i--){
        result += str;
    }
    return result;
}
function parse(source) {
    var header = '';
    var stack = [];
    var state = metadata;
    var currentElement = null;
    var root = null;
    function error(message) {
        var ref = locate(source, i);
        var line = ref.line;
        var column = ref.column;
        var before = source.slice(0, i);
        var beforeLine = /(^|\n).*$/.exec(before)[0].replace(/\t/g, '  ');
        var after = source.slice(i);
        var afterLine = /.*(\n|$)/.exec(after)[0];
        var snippet = "" + beforeLine + afterLine + "\n" + repeat(' ', beforeLine.length) + "^";
        throw new Error(message + " (" + line + ":" + column + "). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues  thanks!\n\n" + snippet);
    }
    function metadata() {
        while(i < source.length && source[i] !== '<' || !validNameCharacters.test(source[i + 1])){
            header += source[i++];
        }
        return neutral();
    }
    function neutral() {
        var text = '';
        while(i < source.length && source[i] !== '<'){
            text += source[i++];
        }
        if (/\S/.test(text)) {
            currentElement.children.push({
                type: 'text',
                value: text
            });
        }
        if (source[i] === '<') {
            return tag;
        }
        return neutral;
    }
    function tag() {
        var char = source[i];
        if (char === '?') {
            return neutral;
        } // <?xml...
        if (char === '!') {
            if (source.slice(i + 1, i + 3) === '--') {
                return comment;
            }
            if (source.slice(i + 1, i + 8) === '[CDATA[') {
                return cdata;
            }
            if (/doctype/i.test(source.slice(i + 1, i + 8))) {
                return neutral;
            }
        }
        if (char === '/') {
            return closingTag;
        }
        var tagName = getName();
        var element = {
            type: 'element',
            tagName: tagName,
            properties: {},
            children: []
        };
        if (currentElement) {
            currentElement.children.push(element);
        } else {
            root = element;
        }
        var attribute;
        while(i < source.length && (attribute = getAttribute())){
            element.properties[attribute.name] = attribute.value;
        }
        var selfClosing = false;
        if (source[i] === '/') {
            i += 1;
            selfClosing = true;
        }
        if (source[i] !== '>') {
            error('Expected >');
        }
        if (!selfClosing) {
            currentElement = element;
            stack.push(element);
        }
        return neutral;
    }
    function comment() {
        var index = source.indexOf('-->', i);
        if (!~index) {
            error('expected -->');
        }
        i = index + 2;
        return neutral;
    }
    function cdata() {
        var index = source.indexOf(']]>', i);
        if (!~index) {
            error('expected ]]>');
        }
        currentElement.children.push(source.slice(i + 7, index));
        i = index + 2;
        return neutral;
    }
    function closingTag() {
        var tagName = getName();
        if (!tagName) {
            error('Expected tag name');
        }
        if (tagName !== currentElement.tagName) {
            error("Expected closing tag </" + tagName + "> to match opening tag <" + currentElement.tagName + ">");
        }
        allowSpaces();
        if (source[i] !== '>') {
            error('Expected >');
        }
        stack.pop();
        currentElement = stack[stack.length - 1];
        return neutral;
    }
    function getName() {
        var name = '';
        while(i < source.length && validNameCharacters.test(source[i])){
            name += source[i++];
        }
        return name;
    }
    function getAttribute() {
        if (!whitespace.test(source[i])) {
            return null;
        }
        allowSpaces();
        var name = getName();
        if (!name) {
            return null;
        }
        var value = true;
        allowSpaces();
        if (source[i] === '=') {
            i += 1;
            allowSpaces();
            value = getAttributeValue();
            if (!isNaN(value) && value.trim() !== '') {
                value = +value;
            } // TODO whitelist numeric attributes?
        }
        return {
            name: name,
            value: value
        };
    }
    function getAttributeValue() {
        return quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();
    }
    function getUnquotedAttributeValue() {
        var value = '';
        do {
            var char = source[i];
            if (char === ' ' || char === '>' || char === '/') {
                return value;
            }
            value += char;
            i += 1;
        }while (i < source.length)
        return value;
    }
    function getQuotedAttributeValue() {
        var quotemark = source[i++];
        var value = '';
        var escaped = false;
        while(i < source.length){
            var char = source[i++];
            if (char === quotemark && !escaped) {
                return value;
            }
            if (char === '\\' && !escaped) {
                escaped = true;
            }
            value += escaped ? "\\" + char : char;
            escaped = false;
        }
    }
    function allowSpaces() {
        while(i < source.length && whitespace.test(source[i])){
            i += 1;
        }
    }
    var i = metadata.length;
    while(i < source.length){
        if (!state) {
            error('Unexpected character');
        }
        state = state();
        i += 1;
    }
    if (state !== neutral) {
        error('Unexpected end of input');
    }
    if (root.tagName === 'svg') {
        root.metadata = header;
    }
    return {
        type: 'root',
        children: [
            root
        ]
    };
}
;
 //# sourceMappingURL=svg-parser.esm.js.map

})()),
"[project]/node_modules/@turf/helpers/dist/es/index.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

/**
 * @module helpers
 */ /**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */ __turbopack_esm__({
    "areaFactors": ()=>areaFactors,
    "bearingToAzimuth": ()=>bearingToAzimuth,
    "convertArea": ()=>convertArea,
    "convertLength": ()=>convertLength,
    "degreesToRadians": ()=>degreesToRadians,
    "earthRadius": ()=>earthRadius,
    "factors": ()=>factors,
    "feature": ()=>feature,
    "featureCollection": ()=>featureCollection,
    "geometry": ()=>geometry,
    "geometryCollection": ()=>geometryCollection,
    "isNumber": ()=>isNumber,
    "isObject": ()=>isObject,
    "lengthToDegrees": ()=>lengthToDegrees,
    "lengthToRadians": ()=>lengthToRadians,
    "lineString": ()=>lineString,
    "lineStrings": ()=>lineStrings,
    "multiLineString": ()=>multiLineString,
    "multiPoint": ()=>multiPoint,
    "multiPolygon": ()=>multiPolygon,
    "point": ()=>point,
    "points": ()=>points,
    "polygon": ()=>polygon,
    "polygons": ()=>polygons,
    "radiansToDegrees": ()=>radiansToDegrees,
    "radiansToLength": ()=>radiansToLength,
    "round": ()=>round,
    "unitsFactors": ()=>unitsFactors,
    "validateBBox": ()=>validateBBox,
    "validateId": ()=>validateId
});
var earthRadius = 6371008.8;
var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: earthRadius / 111325,
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1000,
    kilometres: earthRadius / 1000,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1000,
    millimetres: earthRadius * 1000,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936
};
var unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.37,
    kilometers: 1 / 1000,
    kilometres: 1 / 1000,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1000,
    millimetres: 1000,
    nauticalmiles: 1 / 1852,
    radians: 1 / earthRadius,
    yards: 1.0936133
};
var areaFactors = {
    acres: 0.000247105,
    centimeters: 10000,
    centimetres: 10000,
    feet: 10.763910417,
    hectares: 0.0001,
    inches: 1550.003100006,
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    miles: 3.86e-7,
    millimeters: 1000000,
    millimetres: 1000000,
    yards: 1.195990046
};
function feature(geom, properties, options) {
    if (options === void 0) {
        options = {};
    }
    var feat = {
        type: "Feature"
    };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
function geometry(type, coordinates, _options) {
    if (_options === void 0) {
        _options = {};
    }
    switch(type){
        case "Point":
            return point(coordinates).geometry;
        case "LineString":
            return lineString(coordinates).geometry;
        case "Polygon":
            return polygon(coordinates).geometry;
        case "MultiPoint":
            return multiPoint(coordinates).geometry;
        case "MultiLineString":
            return multiLineString(coordinates).geometry;
        case "MultiPolygon":
            return multiPolygon(coordinates).geometry;
        default:
            throw new Error(type + " is invalid");
    }
}
function point(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    if (!coordinates) {
        throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
        throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
        throw new Error("coordinates must contain numbers");
    }
    var geom = {
        type: "Point",
        coordinates: coordinates
    };
    return feature(geom, properties, options);
}
function points(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    return featureCollection(coordinates.map(function(coords) {
        return point(coords, properties);
    }), options);
}
function polygon(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    for(var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++){
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for(var j = 0; j < ring[ring.length - 1].length; j++){
            // Check if first point of Polygon contains two numbers
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error("First and last Position are not equivalent.");
            }
        }
    }
    var geom = {
        type: "Polygon",
        coordinates: coordinates
    };
    return feature(geom, properties, options);
}
function polygons(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    return featureCollection(coordinates.map(function(coords) {
        return polygon(coords, properties);
    }), options);
}
function lineString(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
        type: "LineString",
        coordinates: coordinates
    };
    return feature(geom, properties, options);
}
function lineStrings(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    return featureCollection(coordinates.map(function(coords) {
        return lineString(coords, properties);
    }), options);
}
function featureCollection(features, options) {
    if (options === void 0) {
        options = {};
    }
    var fc = {
        type: "FeatureCollection"
    };
    if (options.id) {
        fc.id = options.id;
    }
    if (options.bbox) {
        fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
}
function multiLineString(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    var geom = {
        type: "MultiLineString",
        coordinates: coordinates
    };
    return feature(geom, properties, options);
}
function multiPoint(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    var geom = {
        type: "MultiPoint",
        coordinates: coordinates
    };
    return feature(geom, properties, options);
}
function multiPolygon(coordinates, properties, options) {
    if (options === void 0) {
        options = {};
    }
    var geom = {
        type: "MultiPolygon",
        coordinates: coordinates
    };
    return feature(geom, properties, options);
}
function geometryCollection(geometries, properties, options) {
    if (options === void 0) {
        options = {};
    }
    var geom = {
        type: "GeometryCollection",
        geometries: geometries
    };
    return feature(geom, properties, options);
}
function round(num, precision) {
    if (precision === void 0) {
        precision = 0;
    }
    if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}
function radiansToLength(radians, units) {
    if (units === void 0) {
        units = "kilometers";
    }
    var factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
function lengthToRadians(distance, units) {
    if (units === void 0) {
        units = "kilometers";
    }
    var factor = factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
function lengthToDegrees(distance, units) {
    return radiansToDegrees(lengthToRadians(distance, units));
}
function bearingToAzimuth(bearing) {
    var angle = bearing % 360;
    if (angle < 0) {
        angle += 360;
    }
    return angle;
}
function radiansToDegrees(radians) {
    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}
function degreesToRadians(degrees) {
    var radians = degrees % 360;
    return radians * Math.PI / 180;
}
function convertLength(length, originalUnit, finalUnit) {
    if (originalUnit === void 0) {
        originalUnit = "kilometers";
    }
    if (finalUnit === void 0) {
        finalUnit = "kilometers";
    }
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
function convertArea(area, originalUnit, finalUnit) {
    if (originalUnit === void 0) {
        originalUnit = "meters";
    }
    if (finalUnit === void 0) {
        finalUnit = "kilometers";
    }
    if (!(area >= 0)) {
        throw new Error("area must be a positive number");
    }
    var startFactor = areaFactors[originalUnit];
    if (!startFactor) {
        throw new Error("invalid original units");
    }
    var finalFactor = areaFactors[finalUnit];
    if (!finalFactor) {
        throw new Error("invalid final units");
    }
    return area / startFactor * finalFactor;
}
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
}
function isObject(input) {
    return !!input && input.constructor === Object;
}
function validateBBox(bbox) {
    if (!bbox) {
        throw new Error("bbox is required");
    }
    if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
    }
    if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
    }
    bbox.forEach(function(num) {
        if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
        }
    });
}
function validateId(id) {
    if (!id) {
        throw new Error("id is required");
    }
    if ([
        "string",
        "number"
    ].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
    }
}

})()),
"[project]/node_modules/@turf/invariant/dist/es/index.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "collectionOf": ()=>collectionOf,
    "containsNumber": ()=>containsNumber,
    "featureOf": ()=>featureOf,
    "geojsonType": ()=>geojsonType,
    "getCoord": ()=>getCoord,
    "getCoords": ()=>getCoords,
    "getGeom": ()=>getGeom,
    "getType": ()=>getType
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/es/index.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
            return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
            return coord.coordinates;
        }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    // Feature
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    } else {
        // Geometry
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
function containsNumber(coordinates) {
    if (coordinates.length > 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(coordinates[0]) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isNumber"])(coordinates[1])) {
        return true;
    }
    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error("coordinates must only contain numbers");
}
function geojsonType(value, type, name) {
    if (!type || !name) {
        throw new Error("type and name required");
    }
    if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
    }
}
function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
    }
}
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) {
        throw new Error("No featureCollection passed");
    }
    if (!name) {
        throw new Error(".collectionOf() requires a name");
    }
    if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
    }
    for(var _i = 0, _a = featureCollection.features; _i < _a.length; _i++){
        var feature = _a[_i];
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
        }
    }
}
function getGeom(geojson) {
    if (geojson.type === "Feature") {
        return geojson.geometry;
    }
    return geojson;
}
function getType(geojson, _name) {
    if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
    }
    return geojson.type;
}

})()),
"[project]/node_modules/@turf/bearing/dist/es/index.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "default": ()=>bearing
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/es/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/es/index.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
function bearing(start, end, options) {
    if (options === void 0) {
        options = {};
    }
    // Reverse calculation
    if (options.final === true) {
        return calculateFinalBearing(start, end);
    }
    var coordinates1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(start);
    var coordinates2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(end);
    var lon1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[0]);
    var lon2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[0]);
    var lat1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[1]);
    var lat2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[1]);
    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToDegrees"])(Math.atan2(a, b));
}
/**
 * Calculates Final Bearing
 *
 * @private
 * @param {Coord} start starting Point
 * @param {Coord} end ending Point
 * @returns {number} bearing
 */ function calculateFinalBearing(start, end) {
    // Swap start & end
    var bear = bearing(end, start);
    bear = (bear + 180) % 360;
    return bear;
}

})()),
"[project]/node_modules/@turf/destination/dist/es/index.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

// http://en.wikipedia.org/wiki/Haversine_formula
// http://www.movable-type.co.uk/scripts/latlong.html
__turbopack_esm__({
    "default": ()=>destination
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/es/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/es/index.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
function destination(origin, distance, bearing, options) {
    if (options === void 0) {
        options = {};
    }
    // Handle input
    var coordinates1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(origin);
    var longitude1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[0]);
    var latitude1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[1]);
    var bearingRad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(bearing);
    var radians = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["lengthToRadians"])(distance, options.units);
    // Main
    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
    var lng = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToDegrees"])(longitude2);
    var lat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToDegrees"])(latitude2);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["point"])([
        lng,
        lat
    ], options.properties);
}

})()),
"[project]/node_modules/@turf/distance/dist/es/index.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/invariant/dist/es/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/helpers/dist/es/index.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html
/**
 * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name distance
 * @param {Coord | Point} from origin point or coordinate
 * @param {Coord | Point} to destination point or coordinate
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @returns {number} distance between the two points
 * @example
 * var from = turf.point([-75.343, 39.984]);
 * var to = turf.point([-75.534, 39.123]);
 * var options = {units: 'miles'};
 *
 * var distance = turf.distance(from, to, options);
 *
 * //addToMap
 * var addToMap = [from, to];
 * from.properties.distance = distance;
 * to.properties.distance = distance;
 */ function distance(from, to, options) {
    if (options === void 0) {
        options = {};
    }
    var coordinates1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(from);
    var coordinates2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$invariant$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCoord"])(to);
    var dLat = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[1] - coordinates1[1]);
    var dLon = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[0] - coordinates1[0]);
    var lat1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates1[1]);
    var lat2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["degreesToRadians"])(coordinates2[1]);
    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$helpers$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["radiansToLength"])(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}
const __TURBOPACK__default__export__ = distance;

})()),
"[project]/node_modules/@turf/midpoint/dist/es/index.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/bearing/dist/es/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/destination/dist/es/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@turf/distance/dist/es/index.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
;
;
;
/**
 * Takes two {@link Point|points} and returns a point midway between them.
 * The midpoint is calculated geodesically, meaning the curvature of the earth is taken into account.
 *
 * @name midpoint
 * @param {Coord} point1 first point
 * @param {Coord} point2 second point
 * @returns {Feature<Point>} a point midway between `pt1` and `pt2`
 * @example
 * var point1 = turf.point([144.834823, -37.771257]);
 * var point2 = turf.point([145.14244, -37.830937]);
 *
 * var midpoint = turf.midpoint(point1, point2);
 *
 * //addToMap
 * var addToMap = [point1, point2, midpoint];
 * midpoint.properties['marker-color'] = '#f00';
 */ function midpoint(point1, point2) {
    var dist = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$distance$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(point1, point2);
    var heading = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$bearing$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(point1, point2);
    var midpoint = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turf$2f$destination$2f$dist$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(point1, dist / 2, heading);
    return midpoint;
}
const __TURBOPACK__default__export__ = midpoint;

})()),
"[project]/node_modules/wkt-parser/parser.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "default": ()=>__TURBOPACK__default__export__
});
const __TURBOPACK__default__export__ = parseString;
var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
// const ignoredChar = /[\s_\-\/\(\)]/g;
function Parser(text) {
    if (typeof text !== 'string') {
        throw new Error('not a string');
    }
    this.text = text.trim();
    this.level = 0;
    this.place = 0;
    this.root = null;
    this.stack = [];
    this.currentObject = null;
    this.state = NEUTRAL;
}
Parser.prototype.readCharicter = function() {
    var char = this.text[this.place++];
    if (this.state !== QUOTED) {
        while(whitespace.test(char)){
            if (this.place >= this.text.length) {
                return;
            }
            char = this.text[this.place++];
        }
    }
    switch(this.state){
        case NEUTRAL:
            return this.neutral(char);
        case KEYWORD:
            return this.keyword(char);
        case QUOTED:
            return this.quoted(char);
        case AFTERQUOTE:
            return this.afterquote(char);
        case NUMBER:
            return this.number(char);
        case ENDED:
            return;
    }
};
Parser.prototype.afterquote = function(char) {
    if (char === '"') {
        this.word += '"';
        this.state = QUOTED;
        return;
    }
    if (endThings.test(char)) {
        this.word = this.word.trim();
        this.afterItem(char);
        return;
    }
    throw new Error('havn\'t handled "' + char + '" in afterquote yet, index ' + this.place);
};
Parser.prototype.afterItem = function(char) {
    if (char === ',') {
        if (this.word !== null) {
            this.currentObject.push(this.word);
        }
        this.word = null;
        this.state = NEUTRAL;
        return;
    }
    if (char === ']') {
        this.level--;
        if (this.word !== null) {
            this.currentObject.push(this.word);
            this.word = null;
        }
        this.state = NEUTRAL;
        this.currentObject = this.stack.pop();
        if (!this.currentObject) {
            this.state = ENDED;
        }
        return;
    }
};
Parser.prototype.number = function(char) {
    if (digets.test(char)) {
        this.word += char;
        return;
    }
    if (endThings.test(char)) {
        this.word = parseFloat(this.word);
        this.afterItem(char);
        return;
    }
    throw new Error('havn\'t handled "' + char + '" in number yet, index ' + this.place);
};
Parser.prototype.quoted = function(char) {
    if (char === '"') {
        this.state = AFTERQUOTE;
        return;
    }
    this.word += char;
    return;
};
Parser.prototype.keyword = function(char) {
    if (keyword.test(char)) {
        this.word += char;
        return;
    }
    if (char === '[') {
        var newObjects = [];
        newObjects.push(this.word);
        this.level++;
        if (this.root === null) {
            this.root = newObjects;
        } else {
            this.currentObject.push(newObjects);
        }
        this.stack.push(this.currentObject);
        this.currentObject = newObjects;
        this.state = NEUTRAL;
        return;
    }
    if (endThings.test(char)) {
        this.afterItem(char);
        return;
    }
    throw new Error('havn\'t handled "' + char + '" in keyword yet, index ' + this.place);
};
Parser.prototype.neutral = function(char) {
    if (latin.test(char)) {
        this.word = char;
        this.state = KEYWORD;
        return;
    }
    if (char === '"') {
        this.word = '';
        this.state = QUOTED;
        return;
    }
    if (digets.test(char)) {
        this.word = char;
        this.state = NUMBER;
        return;
    }
    if (endThings.test(char)) {
        this.afterItem(char);
        return;
    }
    throw new Error('havn\'t handled "' + char + '" in neutral yet, index ' + this.place);
};
Parser.prototype.output = function() {
    while(this.place < this.text.length){
        this.readCharicter();
    }
    if (this.state === ENDED) {
        return this.root;
    }
    throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
};
function parseString(txt) {
    var parser = new Parser(txt);
    return parser.output();
}

})()),
"[project]/node_modules/wkt-parser/process.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "sExpr": ()=>sExpr
});
function mapit(obj, key, value) {
    if (Array.isArray(key)) {
        value.unshift(key);
        key = null;
    }
    var thing = key ? {} : obj;
    var out = value.reduce(function(newObj, item) {
        sExpr(item, newObj);
        return newObj;
    }, thing);
    if (key) {
        obj[key] = out;
    }
}
function sExpr(v, obj) {
    if (!Array.isArray(v)) {
        obj[v] = true;
        return;
    }
    var key = v.shift();
    if (key === 'PARAMETER') {
        key = v.shift();
    }
    if (v.length === 1) {
        if (Array.isArray(v[0])) {
            obj[key] = {};
            sExpr(v[0], obj[key]);
            return;
        }
        obj[key] = v[0];
        return;
    }
    if (!v.length) {
        obj[key] = true;
        return;
    }
    if (key === 'TOWGS84') {
        obj[key] = v;
        return;
    }
    if (key === 'AXIS') {
        if (!(key in obj)) {
            obj[key] = [];
        }
        obj[key].push(v);
        return;
    }
    if (!Array.isArray(key)) {
        obj[key] = {};
    }
    var i;
    switch(key){
        case 'UNIT':
        case 'PRIMEM':
        case 'VERT_DATUM':
            obj[key] = {
                name: v[0].toLowerCase(),
                convert: v[1]
            };
            if (v.length === 3) {
                sExpr(v[2], obj[key]);
            }
            return;
        case 'SPHEROID':
        case 'ELLIPSOID':
            obj[key] = {
                name: v[0],
                a: v[1],
                rf: v[2]
            };
            if (v.length === 4) {
                sExpr(v[3], obj[key]);
            }
            return;
        case 'PROJECTEDCRS':
        case 'PROJCRS':
        case 'GEOGCS':
        case 'GEOCCS':
        case 'PROJCS':
        case 'LOCAL_CS':
        case 'GEODCRS':
        case 'GEODETICCRS':
        case 'GEODETICDATUM':
        case 'EDATUM':
        case 'ENGINEERINGDATUM':
        case 'VERT_CS':
        case 'VERTCRS':
        case 'VERTICALCRS':
        case 'COMPD_CS':
        case 'COMPOUNDCRS':
        case 'ENGINEERINGCRS':
        case 'ENGCRS':
        case 'FITTED_CS':
        case 'LOCAL_DATUM':
        case 'DATUM':
            v[0] = [
                'name',
                v[0]
            ];
            mapit(obj, key, v);
            return;
        default:
            i = -1;
            while(++i < v.length){
                if (!Array.isArray(v[i])) {
                    return sExpr(v, obj[key]);
                }
            }
            return mapit(obj, key, v);
    }
}

})()),
"[project]/node_modules/wkt-parser/index.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

__turbopack_esm__({
    "default": ()=>__TURBOPACK__default__export__
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/wkt-parser/parser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/wkt-parser/process.js [app-client] (ecmascript)");
"__TURBOPACK__ecmascript__hoisting__location__";
var D2R = 0.01745329251994329577;
;
;
function rename(obj, params) {
    var outName = params[0];
    var inName = params[1];
    if (!(outName in obj) && inName in obj) {
        obj[outName] = obj[inName];
        if (params.length === 3) {
            obj[outName] = params[2](obj[outName]);
        }
    }
}
function d2r(input) {
    return input * D2R;
}
function cleanWKT(wkt) {
    if (wkt.type === 'GEOGCS') {
        wkt.projName = 'longlat';
    } else if (wkt.type === 'LOCAL_CS') {
        wkt.projName = 'identity';
        wkt.local = true;
    } else {
        if (typeof wkt.PROJECTION === 'object') {
            wkt.projName = Object.keys(wkt.PROJECTION)[0];
        } else {
            wkt.projName = wkt.PROJECTION;
        }
    }
    if (wkt.AXIS) {
        var axisOrder = '';
        for(var i = 0, ii = wkt.AXIS.length; i < ii; ++i){
            var axis = [
                wkt.AXIS[i][0].toLowerCase(),
                wkt.AXIS[i][1].toLowerCase()
            ];
            if (axis[0].indexOf('north') !== -1 || (axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north') {
                axisOrder += 'n';
            } else if (axis[0].indexOf('south') !== -1 || (axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south') {
                axisOrder += 's';
            } else if (axis[0].indexOf('east') !== -1 || (axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east') {
                axisOrder += 'e';
            } else if (axis[0].indexOf('west') !== -1 || (axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west') {
                axisOrder += 'w';
            }
        }
        if (axisOrder.length === 2) {
            axisOrder += 'u';
        }
        if (axisOrder.length === 3) {
            wkt.axis = axisOrder;
        }
    }
    if (wkt.UNIT) {
        wkt.units = wkt.UNIT.name.toLowerCase();
        if (wkt.units === 'metre') {
            wkt.units = 'meter';
        }
        if (wkt.UNIT.convert) {
            if (wkt.type === 'GEOGCS') {
                if (wkt.DATUM && wkt.DATUM.SPHEROID) {
                    wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a;
                }
            } else {
                wkt.to_meter = wkt.UNIT.convert;
            }
        }
    }
    var geogcs = wkt.GEOGCS;
    if (wkt.type === 'GEOGCS') {
        geogcs = wkt;
    }
    if (geogcs) {
        //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
        //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
        //}
        if (geogcs.DATUM) {
            wkt.datumCode = geogcs.DATUM.name.toLowerCase();
        } else {
            wkt.datumCode = geogcs.name.toLowerCase();
        }
        if (wkt.datumCode.slice(0, 2) === 'd_') {
            wkt.datumCode = wkt.datumCode.slice(2);
        }
        if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
            wkt.datumCode = 'nzgd49';
        }
        if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
            if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
                wkt.sphere = true;
            }
            wkt.datumCode = 'wgs84';
        }
        if (wkt.datumCode.slice(-6) === '_ferro') {
            wkt.datumCode = wkt.datumCode.slice(0, -6);
        }
        if (wkt.datumCode.slice(-8) === '_jakarta') {
            wkt.datumCode = wkt.datumCode.slice(0, -8);
        }
        if (~wkt.datumCode.indexOf('belge')) {
            wkt.datumCode = 'rnb72';
        }
        if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
            wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
            if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
                wkt.ellps = 'intl';
            }
            wkt.a = geogcs.DATUM.SPHEROID.a;
            wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
        }
        if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
            wkt.datum_params = geogcs.DATUM.TOWGS84;
        }
        if (~wkt.datumCode.indexOf('osgb_1936')) {
            wkt.datumCode = 'osgb36';
        }
        if (~wkt.datumCode.indexOf('osni_1952')) {
            wkt.datumCode = 'osni52';
        }
        if (~wkt.datumCode.indexOf('tm65') || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
            wkt.datumCode = 'ire65';
        }
        if (wkt.datumCode === 'ch1903+') {
            wkt.datumCode = 'ch1903';
        }
        if (~wkt.datumCode.indexOf('israel')) {
            wkt.datumCode = 'isr93';
        }
    }
    if (wkt.b && !isFinite(wkt.b)) {
        wkt.b = wkt.a;
    }
    function toMeter(input) {
        var ratio = wkt.to_meter || 1;
        return input * ratio;
    }
    var renamer = function(a) {
        return rename(wkt, a);
    };
    var list = [
        [
            'standard_parallel_1',
            'Standard_Parallel_1'
        ],
        [
            'standard_parallel_1',
            'Latitude of 1st standard parallel'
        ],
        [
            'standard_parallel_2',
            'Standard_Parallel_2'
        ],
        [
            'standard_parallel_2',
            'Latitude of 2nd standard parallel'
        ],
        [
            'false_easting',
            'False_Easting'
        ],
        [
            'false_easting',
            'False easting'
        ],
        [
            'false-easting',
            'Easting at false origin'
        ],
        [
            'false_northing',
            'False_Northing'
        ],
        [
            'false_northing',
            'False northing'
        ],
        [
            'false_northing',
            'Northing at false origin'
        ],
        [
            'central_meridian',
            'Central_Meridian'
        ],
        [
            'central_meridian',
            'Longitude of natural origin'
        ],
        [
            'central_meridian',
            'Longitude of false origin'
        ],
        [
            'latitude_of_origin',
            'Latitude_Of_Origin'
        ],
        [
            'latitude_of_origin',
            'Central_Parallel'
        ],
        [
            'latitude_of_origin',
            'Latitude of natural origin'
        ],
        [
            'latitude_of_origin',
            'Latitude of false origin'
        ],
        [
            'scale_factor',
            'Scale_Factor'
        ],
        [
            'k0',
            'scale_factor'
        ],
        [
            'latitude_of_center',
            'Latitude_Of_Center'
        ],
        [
            'latitude_of_center',
            'Latitude_of_center'
        ],
        [
            'lat0',
            'latitude_of_center',
            d2r
        ],
        [
            'longitude_of_center',
            'Longitude_Of_Center'
        ],
        [
            'longitude_of_center',
            'Longitude_of_center'
        ],
        [
            'longc',
            'longitude_of_center',
            d2r
        ],
        [
            'x0',
            'false_easting',
            toMeter
        ],
        [
            'y0',
            'false_northing',
            toMeter
        ],
        [
            'long0',
            'central_meridian',
            d2r
        ],
        [
            'lat0',
            'latitude_of_origin',
            d2r
        ],
        [
            'lat0',
            'standard_parallel_1',
            d2r
        ],
        [
            'lat1',
            'standard_parallel_1',
            d2r
        ],
        [
            'lat2',
            'standard_parallel_2',
            d2r
        ],
        [
            'azimuth',
            'Azimuth'
        ],
        [
            'alpha',
            'azimuth',
            d2r
        ],
        [
            'srsCode',
            'name'
        ]
    ];
    list.forEach(renamer);
    if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
        wkt.long0 = wkt.longc;
    }
    if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
        wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
        wkt.lat_ts = wkt.lat1;
    } else if (!wkt.lat_ts && wkt.lat0 && wkt.projName === 'Polar_Stereographic') {
        wkt.lat_ts = wkt.lat0;
        wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90);
    }
}
function __TURBOPACK__default__export__(wkt) {
    var lisp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(wkt);
    var type = lisp.shift();
    var name = lisp.shift();
    lisp.unshift([
        'name',
        name
    ]);
    lisp.unshift([
        'type',
        type
    ]);
    var obj = {};
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$wkt$2d$parser$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sExpr"])(lisp, obj);
    cleanWKT(obj);
    return obj;
}

})()),
"[project]/node_modules/mgrs/mgrs.js [app-client] (ecmascript)": (({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, k: __turbopack_refresh__ }) => (() => {
"use strict";

/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */ __turbopack_esm__({
    "default": ()=>__TURBOPACK__default__export__,
    "forward": ()=>forward,
    "inverse": ()=>inverse,
    "toPoint": ()=>toPoint
});
var NUM_100K_SETS = 6;
/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */ var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';
/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */ var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';
var A = 65; // A
var I = 73; // I
var O = 79; // O
var V = 86; // V
var Z = 90; // Z
const __TURBOPACK__default__export__ = {
    forward: forward,
    inverse: inverse,
    toPoint: toPoint
};
function forward(ll, accuracy) {
    accuracy = accuracy || 5; // default accuracy 1m
    return encode(LLtoUTM({
        lat: ll[1],
        lon: ll[0]
    }), accuracy);
}
;
function inverse(mgrs) {
    var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
        return [
            bbox.lon,
            bbox.lat,
            bbox.lon,
            bbox.lat
        ];
    }
    return [
        bbox.left,
        bbox.bottom,
        bbox.right,
        bbox.top
    ];
}
;
function toPoint(mgrs) {
    var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
        return [
            bbox.lon,
            bbox.lat
        ];
    }
    return [
        (bbox.left + bbox.right) / 2,
        (bbox.top + bbox.bottom) / 2
    ];
}
;
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */ function degToRad(deg) {
    return deg * (Math.PI / 180.0);
}
/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */ function radToDeg(rad) {
    return 180.0 * (rad / Math.PI);
}
/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */ function LLtoUTM(ll) {
    var Lat = ll.lat;
    var Long = ll.lon;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var k0 = 0.9996;
    var LongOrigin;
    var eccPrimeSquared;
    var N, T, C, A, M;
    var LatRad = degToRad(Lat);
    var LongRad = degToRad(Long);
    var LongOriginRad;
    var ZoneNumber;
    // (int)
    ZoneNumber = Math.floor((Long + 180) / 6) + 1;
    //Make sure the longitude 180.00 is in Zone 60
    if (Long === 180) {
        ZoneNumber = 60;
    }
    // Special zone for Norway
    if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
        ZoneNumber = 32;
    }
    // Special zones for Svalbard
    if (Lat >= 72.0 && Lat < 84.0) {
        if (Long >= 0.0 && Long < 9.0) {
            ZoneNumber = 31;
        } else if (Long >= 9.0 && Long < 21.0) {
            ZoneNumber = 33;
        } else if (Long >= 21.0 && Long < 33.0) {
            ZoneNumber = 35;
        } else if (Long >= 33.0 && Long < 42.0) {
            ZoneNumber = 37;
        }
    }
    LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
    // in middle of
    // zone
    LongOriginRad = degToRad(LongOrigin);
    eccPrimeSquared = eccSquared / (1 - eccSquared);
    N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
    T = Math.tan(LatRad) * Math.tan(LatRad);
    C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
    A = Math.cos(LatRad) * (LongRad - LongOriginRad);
    M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
    var UTMEasting = k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0;
    var UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0));
    if (Lat < 0.0) {
        UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
    }
    return {
        northing: Math.round(UTMNorthing),
        easting: Math.round(UTMEasting),
        zoneNumber: ZoneNumber,
        zoneLetter: getLetterDesignator(Lat)
    };
}
/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */ function UTMtoLL(utm) {
    var UTMNorthing = utm.northing;
    var UTMEasting = utm.easting;
    var zoneLetter = utm.zoneLetter;
    var zoneNumber = utm.zoneNumber;
    // check the ZoneNummber is valid
    if (zoneNumber < 0 || zoneNumber > 60) {
        return null;
    }
    var k0 = 0.9996;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var eccPrimeSquared;
    var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
    var N1, T1, C1, R1, D, M;
    var LongOrigin;
    var mu, phi1Rad;
    // remove 500,000 meter offset for longitude
    var x = UTMEasting - 500000.0;
    var y = UTMNorthing;
    // We must know somehow if we are in the Northern or Southern
    // hemisphere, this is the only time we use the letter So even
    // if the Zone letter isn't exactly correct it should indicate
    // the hemisphere correctly
    if (zoneLetter < 'N') {
        y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
    }
    // There are 60 zones with zone 1 being at West -180 to -174
    LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
    // in middle of
    // zone
    eccPrimeSquared = eccSquared / (1 - eccSquared);
    M = y / k0;
    mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
    phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu);
    // double phi1 = ProjMath.radToDeg(phi1Rad);
    N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
    T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
    C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
    R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
    D = x / (N1 * k0);
    var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
    lat = radToDeg(lat);
    var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
    lon = LongOrigin + radToDeg(lon);
    var result;
    if (utm.accuracy) {
        var topRight = UTMtoLL({
            northing: utm.northing + utm.accuracy,
            easting: utm.easting + utm.accuracy,
            zoneLetter: utm.zoneLetter,
            zoneNumber: utm.zoneNumber
        });
        result = {
            top: topRight.lat,
            right: topRight.lon,
            bottom: lat,
            left: lon
        };
    } else {
        result = {
            lat: lat,
            lon: lon
        };
    }
    return result;
}
/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */ function getLetterDesignator(lat) {
    //This is here as an error flag to show that the Latitude is
    //outside MGRS limits
    var LetterDesignator = 'Z';
    if (84 >= lat && lat >= 72) {
        LetterDesignator = 'X';
    } else if (72 > lat && lat >= 64) {
        LetterDesignator = 'W';
    } else if (64 > lat && lat >= 56) {
        LetterDesignator = 'V';
    } else if (56 > lat && lat >= 48) {
        LetterDesignator = 'U';
    } else if (48 > lat && lat >= 40) {
        LetterDesignator = 'T';
    } else if (40 > lat && lat >= 32) {
        LetterDesignator = 'S';
    } else if (32 > lat && lat >= 24) {
        LetterDesignator = 'R';
    } else if (24 > lat && lat >= 16) {
        LetterDesignator = 'Q';
    } else if (16 > lat && lat >= 8) {
        LetterDesignator = 'P';
    } else if (8 > lat && lat >= 0) {
        LetterDesignator = 'N';
    } else if (0 > lat && lat >= -8) {
        LetterDesignator = 'M';
    } else if (-8 > lat && lat >= -16) {
        LetterDesignator = 'L';
    } else if (-16 > lat && lat >= -24) {
        LetterDesignator = 'K';
    } else if (-24 > lat && lat >= -32) {
        LetterDesignator = 'J';
    } else if (-32 > lat && lat >= -40) {
        LetterDesignator = 'H';
    } else if (-40 > lat && lat >= -48) {
        LetterDesignator = 'G';
    } else if (-48 > lat && lat >= -56) {
        LetterDesignator = 'F';
    } else if (-56 > lat && lat >= -64) {
        LetterDesignator = 'E';
    } else if (-64 > lat && lat >= -72) {
        LetterDesignator = 'D';
    } else if (-72 > lat && lat >= -80) {
        LetterDesignator = 'C';
    }
    return LetterDesignator;
}
/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */ function encode(utm, accuracy) {
    // prepend with leading zeroes
    var seasting = "00000" + utm.easting, snorthing = "00000" + utm.northing;
    return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}
/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */ function get100kID(easting, northing, zoneNumber) {
    var setParm = get100kSetForZone(zoneNumber);
    var setColumn = Math.floor(easting / 100000);
    var setRow = Math.floor(northing / 100000) % 20;
    return getLetter100kID(setColumn, setRow, setParm);
}
/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */ function get100kSetForZone(i) {
    var setParm = i % NUM_100K_SETS;
    if (setParm === 0) {
        setParm = NUM_100K_SETS;
    }
    return setParm;
}
/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */ function getLetter100kID(column, row, parm) {
    // colOrigin and rowOrigin are the letters at the origin of the set
    var index = parm - 1;
    var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
    var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);
    // colInt and rowInt are the letters to build to return
    var colInt = colOrigin + column - 1;
    var rowInt = rowOrigin + row;
    var rollover = false;
    if (colInt > Z) {
        colInt = colInt - Z + A - 1;
        rollover = true;
    }
    if (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) {
        colInt++;
    }
    if (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) {
        colInt++;
        if (colInt === I) {
            colInt++;
        }
    }
    if (colInt > Z) {
        colInt = colInt - Z + A - 1;
    }
    if (rowInt > V) {
        rowInt = rowInt - V + A - 1;
        rollover = true;
    } else {
        rollover = false;
    }
    if (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) {
        rowInt++;
    }
    if (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) {
        rowInt++;
        if (rowInt === I) {
            rowInt++;
        }
    }
    if (rowInt > V) {
        rowInt = rowInt - V + A - 1;
    }
    var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
    return twoLetter;
}
/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */ function decode(mgrsString) {
    if (mgrsString && mgrsString.length === 0) {
        throw "MGRSPoint coverting from nothing";
    }
    var length = mgrsString.length;
    var hunK = null;
    var sb = "";
    var testChar;
    var i = 0;
    // get Zone number
    while(!/[A-Z]/.test(testChar = mgrsString.charAt(i))){
        if (i >= 2) {
            throw "MGRSPoint bad conversion from: " + mgrsString;
        }
        sb += testChar;
        i++;
    }
    var zoneNumber = parseInt(sb, 10);
    if (i === 0 || i + 3 > length) {
        // A good MGRS string has to be 4-5 digits long,
        // ##AAA/#AAA at least.
        throw "MGRSPoint bad conversion from: " + mgrsString;
    }
    var zoneLetter = mgrsString.charAt(i++);
    // Should we check the zone letter here? Why not.
    if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
        throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
    }
    hunK = mgrsString.substring(i, i += 2);
    var set = get100kSetForZone(zoneNumber);
    var east100k = getEastingFromChar(hunK.charAt(0), set);
    var north100k = getNorthingFromChar(hunK.charAt(1), set);
    // We have a bug where the northing may be 2000000 too low.
    // How
    // do we know when to roll over?
    while(north100k < getMinNorthing(zoneLetter)){
        north100k += 2000000;
    }
    // calculate the char index for easting/northing separator
    var remainder = length - i;
    if (remainder % 2 !== 0) {
        throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
    }
    var sep = remainder / 2;
    var sepEasting = 0.0;
    var sepNorthing = 0.0;
    var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
    if (sep > 0) {
        accuracyBonus = 100000.0 / Math.pow(10, sep);
        sepEastingString = mgrsString.substring(i, i + sep);
        sepEasting = parseFloat(sepEastingString) * accuracyBonus;
        sepNorthingString = mgrsString.substring(i + sep);
        sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
    }
    easting = sepEasting + east100k;
    northing = sepNorthing + north100k;
    return {
        easting: easting,
        northing: northing,
        zoneLetter: zoneLetter,
        zoneNumber: zoneNumber,
        accuracy: accuracyBonus
    };
}
/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */ function getEastingFromChar(e, set) {
    // colOrigin is the letter at the origin of the set for the
    // column
    var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
    var eastingValue = 100000.0;
    var rewindMarker = false;
    while(curCol !== e.charCodeAt(0)){
        curCol++;
        if (curCol === I) {
            curCol++;
        }
        if (curCol === O) {
            curCol++;
        }
        if (curCol > Z) {
            if (rewindMarker) {
                throw "Bad character: " + e;
            }
            curCol = A;
            rewindMarker = true;
        }
        eastingValue += 100000.0;
    }
    return eastingValue;
}
/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */ function getNorthingFromChar(n, set) {
    if (n > 'V') {
        throw "MGRSPoint given invalid Northing " + n;
    }
    // rowOrigin is the letter at the origin of the set for the
    // column
    var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
    var northingValue = 0.0;
    var rewindMarker = false;
    while(curRow !== n.charCodeAt(0)){
        curRow++;
        if (curRow === I) {
            curRow++;
        }
        if (curRow === O) {
            curRow++;
        }
        // fixing a bug making whole application hang in this loop
        // when 'n' is a wrong character
        if (curRow > V) {
            if (rewindMarker) {
                throw "Bad character: " + n;
            }
            curRow = A;
            rewindMarker = true;
        }
        northingValue += 100000.0;
    }
    return northingValue;
}
/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */ function getMinNorthing(zoneLetter) {
    var northing;
    switch(zoneLetter){
        case 'C':
            northing = 1100000.0;
            break;
        case 'D':
            northing = 2000000.0;
            break;
        case 'E':
            northing = 2800000.0;
            break;
        case 'F':
            northing = 3700000.0;
            break;
        case 'G':
            northing = 4600000.0;
            break;
        case 'H':
            northing = 5500000.0;
            break;
        case 'J':
            northing = 6400000.0;
            break;
        case 'K':
            northing = 7300000.0;
            break;
        case 'L':
            northing = 8200000.0;
            break;
        case 'M':
            northing = 9100000.0;
            break;
        case 'N':
            northing = 0.0;
            break;
        case 'P':
            northing = 800000.0;
            break;
        case 'Q':
            northing = 1700000.0;
            break;
        case 'R':
            northing = 2600000.0;
            break;
        case 'S':
            northing = 3500000.0;
            break;
        case 'T':
            northing = 4400000.0;
            break;
        case 'U':
            northing = 5300000.0;
            break;
        case 'V':
            northing = 6200000.0;
            break;
        case 'W':
            northing = 7000000.0;
            break;
        case 'X':
            northing = 7900000.0;
            break;
        default:
            northing = -1.0;
    }
    if (northing >= 0.0) {
        return northing;
    } else {
        throw "Invalid zone letter: " + zoneLetter;
    }
}

})()),
}]);

//# sourceMappingURL=node_modules_12d472._.js.map